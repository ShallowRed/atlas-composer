# Preset Export/Import System Analysis

## Executive Summary

The preset export/import system handles partial parameter transfer with gaps in both export capture and import application. The `translate` parameter (from parameter store) is neither exported nor imported, while `translateOffset` (from CompositeProjection layout) is exported and imported correctly.

## Current Architecture

### Data Sources

The system operates with three distinct data sources that store related but separate information:

1. **CompositeProjection SubProjection State**
   - Location: `CompositeProjection.subProjections[]`
   - Stores: `baseScale`, `scaleMultiplier`, `translateOffset`, `projectionType`, `bounds`, `clipExtent`
   - Source: D3 projection instances and internal metadata

2. **Parameter Store**
   - Location: `useParameterStore()`
   - Stores: `center`, `rotate`, `parallels`, `scale`, `baseScale`, `scaleMultiplier`, `translate`, `clipAngle`, `precision`
   - Source: User parameter adjustments via UI controls

3. **Territory Store**
   - Location: `useTerritoryStore()`
   - Stores: `projectionId`, `translation` (x, y), `scale` (multiplier)
   - Source: Territory-level configuration and layout

### Parameter Types and Meanings

**Scale Parameters (3 interconnected values):**
- `baseScale`: Base scale before multiplier (e.g., 3780)
- `scaleMultiplier`: Adjustment factor (e.g., 1.4)
- `scale`: Final calculated value (baseScale × scaleMultiplier = 5292)

**Translation Parameters (2 distinct concepts):**
- `translateOffset`: Territory layout position relative to map center [x, y] pixels - stored in CompositeProjection
- `translate`: Parameter override from parameter store [x, y] pixels - optional adjustment on top of translateOffset

**Positioning Parameters (projection-type dependent):**
- `center`: Geographic center [lon, lat] - used by cylindrical/azimuthal projections
- `rotate`: Three-axis rotation [λ, φ, γ] - used by conic projections

**Projection-Specific Parameters:**
- `parallels`: Standard parallels [south, north] - for conic projections
- `clipAngle`: Clipping angle in degrees - for azimuthal projections
- `precision`: Adaptive sampling precision - all projections

## Export Flow Analysis

### What Gets Exported

**From CompositeProjection.exportConfig() (line 967-985):**
```typescript
{
  territoryCode, territoryName, projectionType,
  center: sp.projection.center?.(),         // D3 projection center
  scale: sp.projection.scale(),             // D3 projection scale
  rotate: sp.projection.rotate?.(),         // D3 projection rotate
  translateOffset: sp.translateOffset,      // Layout offset
  bounds: sp.bounds,                        // Geographic bounds
  baseScale: sp.baseScale,                  // Metadata
  scaleMultiplier: sp.scaleMultiplier,      // Metadata
  clipExtent: sp.clipExtent,                // Layout clipping
  parallels: sp.projection.parallels?.()    // D3 projection parallels
}
```

**Transformed by CompositeExportService.exportToJSON() (line 142-155):**
```typescript
parameters: {
  center,          // ✅ From D3 projection
  rotate,          // ✅ From D3 projection
  scale,           // ✅ From D3 projection
  baseScale,       // ✅ From metadata
  scaleMultiplier, // ✅ From metadata
  parallels        // ✅ From D3 projection
}
layout: {
  translateOffset, // ✅ From metadata
  clipExtent       // ✅ From metadata
}
```

### What Does NOT Get Exported

**Missing from Parameter Store:**
- `translate` - Parameter override adjustment ❌ NOT EXPORTED
- `clipAngle` - Azimuthal projection clipping ❌ NOT EXPORTED
- `precision` - Adaptive sampling precision ❌ NOT EXPORTED

**Why Missing:**
The export relies on `CompositeProjection.exportConfig()` which reads from D3 projection instances and internal metadata. It does NOT read from the parameter store, so parameter-store-only values (`translate`, `clipAngle`, `precision`) are lost.

**Special Case - D3 Projection Values:**
- `center`, `rotate`, `scale`, `parallels` come from D3 projection instances
- These values MAY differ from parameter store if parameters were changed but `updateTerritoryParameters` wasn't called
- Export captures the "current applied state" not the "parameter store state"

## Import Flow Analysis

### What Gets Imported

**Step 1: BaseScale Pre-setting (line 201-217)**
```typescript
subProj.baseScale = territory.parameters.baseScale  // ✅ Direct assignment
```

**Step 2: Store Application (line 219-270)**
```typescript
// Territory Store:
territoryStore.setTerritoryProjection()    // ✅ projectionId
territoryStore.setTerritoryTranslation()   // ✅ translateOffset (as x, y)
territoryStore.setTerritoryScale()         // ✅ scaleMultiplier

// Parameter Store:
parameterStore.setTerritoryParameters({
  center,          // ✅ Applied
  rotate,          // ✅ Applied
  parallels,       // ✅ Applied
  scale,           // ✅ Applied
  baseScale,       // ✅ Applied
  scaleMultiplier  // ✅ Applied
})

// CompositeProjection:
updateTerritoryProjection()      // ✅ Updates projection type
updateTerritoryParameters()      // ✅ Applies params from parameter store
```

**Step 3: Sync Final Values (line 273-291)**
```typescript
updateTranslationOffset()  // ✅ translateOffset
updateScale()              // ✅ scaleMultiplier (with override check)
```

### What Does NOT Get Imported

**Missing Parameters:**
- `translate` - Not in export, not imported ❌
- `clipAngle` - Not in export, not imported ❌
- `precision` - Not in export, not imported ❌

**Why Missing:**
These parameters are not in the exported JSON, so import cannot restore them.

## Identified Gaps

### Gap 1: translate Parameter Not Exported

**Issue:**
The `translate` parameter from parameter store is NOT exported because `CompositeProjection.exportConfig()` doesn't have access to it.

**Impact:**
User adjustments to territory translation via parameter controls are lost on export.

**Location:**
- Export: `composite-projection.ts:967` - `exportConfig()` doesn't read parameter store
- Import: Would need to be in export first

**Affected Use Case:**
Advanced users who adjust translation via "Translate X/Y" parameter sliders lose these adjustments.

### Gap 2: clipAngle Parameter Not Exported

**Issue:**
The `clipAngle` parameter for azimuthal projections is NOT exported.

**Impact:**
Clipping angle adjustments for azimuthal projections (stereographic, azimuthal-equal-area) are lost.

**Location:**
- Export: `composite-projection.ts:967` - D3 projections don't expose clipAngle via getter
- Import: Would need to be in export first

**Affected Use Case:**
Users working with polar projections lose clipping angle configuration.

### Gap 3: precision Parameter Not Exported

**Issue:**
The `precision` parameter for adaptive sampling is NOT exported.

**Impact:**
Custom precision settings are lost, reverting to defaults.

**Location:**
- Export: `composite-projection.ts:967` - D3 projections don't expose precision via getter
- Import: Would need to be in export first

**Affected Use Case:**
Performance tuning via precision adjustment is not preserved.

### Gap 4: Parameter Store vs D3 Projection Divergence

**Issue:**
Export captures D3 projection state, not parameter store state. If parameters are changed in parameter store but `updateTerritoryParameters()` is not called, export captures stale values.

**Impact:**
Inconsistent state between what user sees in UI and what gets exported.

**Location:**
- Parameter Store: `stores/parameters.ts` - Holds intended values
- D3 Projection: `CompositeProjection.subProjections[].projection` - Holds applied values
- Export: `composite-projection.ts:973-975` - Reads from D3 projection

**Affected Use Case:**
Rare edge case where parameter changes don't trigger re-render before export.

### Gap 5: Dual Import Application

**Issue:**
Import applies scale and translate values twice:
1. Via parameter store (line 236-245)
2. Via `updateTranslationOffset()` and `updateScale()` (line 278-285)

**Impact:**
Redundant operations, potential for inconsistency if one fails.

**Location:**
- `composite-import-service.ts:232-250` - First application
- `composite-import-service.ts:273-291` - Second application

**Affected Use Case:**
No immediate user impact, but architectural complexity.

## Current Flow Diagrams

### Export Flow

```
User triggers export
  ↓
CompositeExportService.exportToJSON()
  ↓
CompositeProjection.exportConfig()
  → Reads D3 projection.center()      ✅ Captured
  → Reads D3 projection.rotate()      ✅ Captured
  → Reads D3 projection.scale()       ✅ Captured
  → Reads D3 projection.parallels()   ✅ Captured
  → Reads subProj.baseScale           ✅ Captured
  → Reads subProj.scaleMultiplier     ✅ Captured
  → Reads subProj.translateOffset     ✅ Captured
  → Reads subProj.clipExtent          ✅ Captured
  → Does NOT read parameter store     ❌ translate, clipAngle, precision lost
  ↓
JSON file saved
```

### Import Flow

```
User selects import file
  ↓
CompositeImportService.importFromFile()
  → Validates JSON
  ↓
User confirms import
  ↓
CompositeImportService.applyToStores()
  ↓
PHASE 1: Direct baseScale assignment
  → subProj.baseScale = exported.baseScale
  ↓
PHASE 2: Store application
  → territoryStore.setTerritoryProjection()    ✅
  → territoryStore.setTerritoryTranslation()   ✅
  → territoryStore.setTerritoryScale()         ✅
  → parameterStore.setTerritoryParameters()    ✅ (but incomplete)
  → updateTerritoryProjection()                ✅
  → updateTerritoryParameters()                ✅
  ↓
PHASE 3: Sync final values
  → updateTranslationOffset()                  ✅ (redundant)
  → updateScale()                              ✅ (redundant)
  ↓
Configuration applied
```

## Architectural Issues

### Issue 1: Multiple Sources of Truth

**Problem:**
Three separate systems store overlapping information:
- Parameter store: User-intended values
- CompositeProjection: Applied D3 projection values + metadata
- Territory store: High-level territory configuration

**Consequence:**
Synchronization complexity, potential for divergence, unclear ownership.

**Example:**
Scale is stored as:
- `parameterStore.scale` (final value or override)
- `parameterStore.baseScale` + `parameterStore.scaleMultiplier`
- `subProj.baseScale` + `subProj.scaleMultiplier` (in CompositeProjection)
- `territoryStore.scale` (as multiplier)
- `projection.scale()` (D3 instance)

### Issue 2: Export Reads D3, Not Parameter Store

**Problem:**
Export captures applied D3 projection state, not parameter store intent.

**Consequence:**
- Parameter-store-only values (translate, clipAngle, precision) lost
- Potential for stale values if parameters changed but not applied

**Why This Design:**
Historical - export was designed to capture actual projection state, not configuration intent.

### Issue 3: Redundant Import Operations

**Problem:**
Import applies values twice through different code paths:
1. Parameter store → updateTerritoryParameters() → D3 projection
2. Direct calls to updateTranslationOffset() / updateScale()

**Consequence:**
Increased complexity, potential for partial failure states.

### Issue 4: No Single Parameter Definition

**Problem:**
Parameters are defined in multiple places:
- `ProjectionParameters` interface (types)
- `PARAMETER_KEYS` array (validation)
- Export JSON structure (export-config.ts)
- Individual getter/setter logic scattered across files

**Consequence:**
Adding new parameters requires changes in 4+ files with no central registry.

### Issue 5: Implicit Parameter Flow

**Problem:**
No clear contract for how parameters flow through the system:
- Some read from D3 projection (center, rotate, scale)
- Some read from metadata (baseScale, scaleMultiplier, translateOffset)
- Some read from parameter store (translate, clipAngle, precision)
- No documentation of which source is authoritative for each parameter

**Consequence:**
Developers cannot easily understand or extend the system.

## Architectural Improvements Needed

### Improvement 1: Single Source of Truth

**Proposal:**
Make parameter store the authoritative source for ALL projection parameters.

**Changes:**
- Move baseScale, scaleMultiplier, translateOffset into parameter store
- Export reads from parameter store, not D3 projections
- CompositeProjection always syncs from parameter store
- D3 projections become pure rendering artifacts

**Benefits:**
- No divergence between stores
- Export captures user intent, not applied state
- Clearer ownership model

**Implementation:**
1. Add `translateOffset` to `ProjectionParameters` interface
2. Modify `CompositeProjection.initialize()` to read translateOffset from params
3. Modify `exportConfig()` to read from parameter provider instead of D3 instances
4. Remove baseScale/scaleMultiplier from SubProjection metadata (keep in parameter store only)

### Improvement 2: Complete Parameter Coverage

**Proposal:**
Export ALL parameters from ProjectionParameters interface.

**Changes:**
- Add `translate`, `clipAngle`, `precision` to export JSON schema
- Modify `exportConfig()` to include these parameters
- Modify import to apply these parameters

**Benefits:**
- Complete state preservation
- No lost user customizations
- Feature parity between export/import and runtime state

**Implementation:**
1. Update `ExportedTerritory.parameters` type to include translate, clipAngle, precision
2. Modify `CompositeProjection.exportConfig()` to read from parameter provider
3. Modify import to apply these parameters to parameter store

### Improvement 3: Unified Parameter Registry

**Proposal:**
Create central parameter registry that defines all parameters in one place.

**Structure:**
```typescript
interface ParameterDefinition {
  key: string
  type: 'number' | 'tuple2' | 'tuple3'
  source: 'projection' | 'parameter-store' | 'metadata'
  exportable: boolean
  importable: boolean
  validation?: ParameterConstraint
}

const PARAMETER_REGISTRY: ParameterDefinition[] = [
  { key: 'center', type: 'tuple2', source: 'projection', exportable: true, importable: true },
  { key: 'rotate', type: 'tuple3', source: 'projection', exportable: true, importable: true },
  { key: 'translate', type: 'tuple2', source: 'parameter-store', exportable: true, importable: true },
  // ... all parameters
]
```

**Benefits:**
- Single definition for each parameter
- Clear source and capabilities
- Automated export/import logic
- Easy to add new parameters

**Implementation:**
1. Create `src/core/parameters/parameter-registry.ts`
2. Define all parameters with metadata
3. Use registry in export/import services
4. Generate validation rules from registry

### Improvement 4: Simplified Import Flow

**Proposal:**
Single-pass import that applies all parameters once through parameter store.

**Changes:**
- Remove redundant PHASE 3 (updateTranslationOffset, updateScale)
- Consolidate all parameter application into parameter store
- Single call to `updateTerritoryParameters()` applies everything

**Benefits:**
- Simpler code
- Atomic operation
- No redundant updates

**Implementation:**
1. Remove lines 273-291 from composite-import-service.ts
2. Ensure parameter store has all necessary values
3. Rely on single updateTerritoryParameters() call to apply everything

### Improvement 5: Export from Parameter Store

**Proposal:**
Export reads parameter store as source of truth, not D3 projections.

**Changes:**
- Pass parameter provider to `exportConfig()`
- Read parameters from parameter store for each territory
- Only read baseScale/scaleMultiplier from SubProjection metadata if not in parameter store

**Benefits:**
- Export captures configuration intent
- No divergence issues
- Complete parameter coverage

**Implementation:**
```typescript
exportConfig(parameterProvider?: ProjectionParameterProvider) {
  return {
    subProjections: this.subProjections.map(sp => {
      const params = parameterProvider?.getEffectiveParameters(sp.territoryCode) || {}
      return {
        territoryCode: sp.territoryCode,
        // Export from parameter store:
        center: params.center || sp.projection.center?.(),
        rotate: params.rotate || sp.projection.rotate?.(),
        parallels: params.parallels || sp.projection.parallels?.(),
        translate: params.translate, // NEW - was missing
        clipAngle: params.clipAngle, // NEW - was missing
        precision: params.precision, // NEW - was missing
        // Export from metadata:
        baseScale: params.baseScale || sp.baseScale,
        scaleMultiplier: params.scaleMultiplier || sp.scaleMultiplier,
        translateOffset: sp.translateOffset,
        // ... rest
      }
    })
  }
}
```

## Migration Path

### Phase 1: Add Missing Parameters to Export/Import (Low Risk)

**Changes:**
1. Add `translate`, `clipAngle`, `precision` to `ExportedTerritory` interface
2. Modify `exportConfig()` to capture these from D3 projections
3. Modify import to apply these to parameter store

**Risk:** Low - additive changes only
**Effort:** 2-3 hours
**Benefit:** Complete parameter preservation

### Phase 2: Parameter Store as Primary Source (Medium Risk)

**Changes:**
1. Move translateOffset into parameter store
2. Modify CompositeProjection to read translateOffset from params
3. Keep backward compatibility with old export format

**Risk:** Medium - changes initialization flow
**Effort:** 4-6 hours
**Benefit:** Reduced divergence, clearer ownership

### Phase 3: Unified Parameter Registry (High Impact)

**Changes:**
1. Create parameter registry
2. Refactor export/import to use registry
3. Auto-generate validation from registry

**Risk:** Medium - large refactor but well-defined
**Effort:** 8-12 hours
**Benefit:** Maintainable, extensible architecture

### Phase 4: Single Source of Truth (High Risk)

**Changes:**
1. Eliminate baseScale/scaleMultiplier from SubProjection metadata
2. Single parameter store as authority
3. D3 projections as pure rendering artifacts

**Risk:** High - fundamental architecture change
**Effort:** 16-20 hours
**Benefit:** Simplified mental model, no synchronization complexity

## Recommendations

### Immediate (< 1 day)

1. **Fix translate parameter export/import** - Add missing translate parameter to preserve user adjustments
2. **Add logging** - Log when parameters diverge between stores for debugging
3. **Document current state** - Update presets.llm.txt with gap analysis

### Short Term (1-2 weeks)

1. **Complete parameter coverage** - Add clipAngle, precision to export/import
2. **Remove redundant import phase** - Simplify import to single-pass application
3. **Export from parameter store** - Change export source from D3 to parameter store

### Long Term (1-2 months)

1. **Unified parameter registry** - Central definition for all parameters
2. **Parameter store as single source** - Eliminate synchronization complexity
3. **Comprehensive testing** - Round-trip export/import validation for all parameter combinations

## File References

**Export:**
- `src/services/export/composite-export-service.ts` - Export orchestration
- `src/services/projection/composite-projection.ts:967` - Raw export from projection

**Import:**
- `src/services/export/composite-import-service.ts` - Import orchestration
- `src/components/ui/import/ImportModal.vue` - UI entry point

**Parameter Management:**
- `src/stores/parameters.ts` - Parameter store
- `src/types/projection-parameters.ts` - Parameter type definitions
- `src/services/parameters/unified-parameter-constraints.ts` - Validation

**Projection:**
- `src/services/projection/composite-projection.ts` - Core projection management

**Configuration:**
- `src/stores/territory.ts` - Territory-level configuration
- `src/stores/config.ts` - Atlas configuration
