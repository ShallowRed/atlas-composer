# Atlas Composer - Improvement Plan

## Objective
Targeted improvements in architecture, user experience, performance, and maintainability while keeping complexity manageable.

## Affected Domains
- [ ] Vue Architecture (docs/vue-architecture.llm.txt)
- [ ] Services (docs/services.llm.txt)
- [ ] Export System (docs/export.llm.txt)
- [ ] Atlas System (docs/atlases.llm.txt)
- [ ] Architecture (docs/architecture.llm.txt)

## Context
- Architecture: docs/architecture.llm.txt
- Vue Layer: docs/vue-architecture.llm.txt
- Services: docs/services.llm.txt
- Export System: docs/export.llm.txt
- Projections: docs/projections.llm.txt

## Current State

### Project Metrics
- Total Lines: ~20,761 (TS + Vue)
- Components: 35 Vue components
- Services: 28 TypeScript files
- Composables: 11 composition functions
- Stores: 4 Pinia stores
- Atlases: 6 configurations
- Test Suites: 13 suites, 251 tests (100% passing)
- Type Coverage: 100%

### Strengths
- Clean service layer with clear domain boundaries
- Comprehensive TypeScript coverage
- Modern Vue 3 Composition API + Pinia
- Zero-dependency projection loader
- LLM-optimized documentation
- JSON-driven atlas system with validation

## Implementation Phases

### Phase 1: Shareable URLs Fix (PRIORITY)
**Status**: INVESTIGATION REQUIRED
**Effort**: 2-4 hours
**User Feedback**: "not really working yet"

Current implementation:
- useUrlState composable exists
- ShareButton component integrated but missing
- i18n translations complete
- URL state restoration in MapView.vue

Investigation tasks:
- [ ] File: src/composables/useUrlState.ts
  - Add unit tests for serialization/deserialization
  - Test edge cases: long names, many territories, special chars
  - Verify all store state is captured in serializeState()
  
- [ ] File: src/views/MapView.vue
  - Check timing: restoreFromUrl() vs initialize() order
  - Verify no race conditions with URL restoration
  - Add console logging to track state restoration flow

- [ ] Manual testing
  - Create complex config → copy URL → paste in new tab
  - Verify all settings restored correctly
  - Test URL length limits (2048 chars browser limit)

- [ ] Resolution
  - Fix identified serialization/restoration bugs
  - Add error handling and user feedback
  - Document known limitations
  - Consider localStorage with short hash if URL length is issue

### Phase 2: Code Quality (OPTIONAL)
**Status**: ON-DEMAND
**Note**: Current code is working well - only refactor if clear benefit

#### 2.1 Service Layer Audit
- [ ] Audit: Document current service patterns (instance vs static)
- [ ] Analysis: Identify when each pattern is appropriate
- [ ] Review: Are there actual inconsistencies causing issues?
- [ ] Decision: Refactor only if clear benefit demonstrated

#### 2.2 File Organization Review
- [ ] Review: Are large files (618 lines, 435 lines) problematic?
- [ ] Check: Do they violate single responsibility?
- [ ] Assess: Would splitting improve maintainability?
- [ ] Decision: Only split if improves understanding

#### 2.3 Naming Conventions
- [ ] Document: Current naming patterns (camelCase vs kebab-case)
- [ ] Identify: Actual inconsistencies vs domain differences
- [ ] Propose: Guidelines for new code only
- [ ] Decision: Refactor only if causing confusion

### Phase 3: Performance (CONDITIONAL)
**Status**: PROFILE FIRST
**Prerequisite**: ALL items require benchmarking before implementation

#### 3.1 Memoization
**Prerequisites**: Performance profiling of projection calculations
- [ ] Profile projection calculation times
- [ ] Identify hotspots (>50ms)
- [ ] If needed: Add memoization to slow operations only
- [ ] Implement cache invalidation strategy

#### 3.2 Rendering
**Prerequisites**: Frame rate monitoring, user feedback
- [ ] Monitor frame rates during interactions
- [ ] Identify rendering bottlenecks
- [ ] Test with maximum territories (stress test)
- [ ] If needed: Add debouncing to parameter changes
- [ ] If needed: Implement virtual scrolling (>50 items)
- [ ] If needed: Use v-memo for static content

#### 3.3 Code Splitting
**Prerequisites**: Bundle size analysis, load time profiling
- [ ] Measure current bundle size and load times
- [ ] Identify heavy components/chunks (>100KB)
- [ ] If needed: Lazy load projection definitions by family
- [ ] If needed: Use defineAsyncComponent for heavy components
- [ ] If needed: Split export system into separate chunk

### Phase 4: Extended Features (LOW PRIORITY)

#### 4.1 Enhanced Export Options
**Status**: REQUIREMENTS NEEDED
- [ ] User research: What formats are actually needed?
- [ ] Requirements: Styling options (colors, stroke width, labels)?
- [ ] Complexity: Balance features vs overwhelming users
- [ ] Implementation: Based on validated user needs

#### 4.2 User Documentation
**Status**: NEEDS ASSESSMENT
- [ ] Assess: Is lack of docs blocking users?
- [ ] Research: What format would be most valuable?
- [ ] Decision: Implement based on user feedback

## Guidelines

### Anti-Patterns to Avoid
1. Over-engineering: No abstraction layers without clear benefit
2. Feature creep: Each feature must serve core value proposition
3. Premature optimization: Profile before optimizing
4. Breaking changes: Maintain backward compatibility for exports
5. State explosion: Keep state management simple

### Success Metrics
- User Experience: Time to first projection < 30s, config save/load < 1s
- Code Quality: 100% tests passing, 100% type coverage, files < 400 lines
- Performance: Page load < 2s, projection render < 500ms, 60 FPS interactions

## Documentation Updates

After implementation:
- [ ] docs/architecture.llm.txt - Update with new patterns
- [ ] docs/vue-architecture.llm.txt - Document new components
- [ ] docs/services.llm.txt - Update service patterns
- [ ] docs/export.llm.txt - Add new export features

## Verification

- [ ] All existing tests pass
- [ ] New features have test coverage
- [ ] TypeScript compilation succeeds
- [ ] Performance benchmarks pass (if applicable)
- [ ] Documentation updated
- [ ] No regression in existing functionality

## Status
Status: PLANNED
Last Updated: 2025-10-12