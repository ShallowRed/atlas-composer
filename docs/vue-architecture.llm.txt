# Vue Architecture Documentation

## Overview

Vue 3 Composition API application with TypeScript, Pinia stores, and service-oriented architecture.

## Technology Stack

- **Vue 3**: Composition API with `<script setup>` syntax
- **TypeScript**: Full type safety across components
- **Pinia**: State management (2 stores: config, geoData)
- **Vue Router**: SPA routing (2 routes: map, about)
- **Vue I18n**: Internationalization (EN/FR)
- **Tailwind CSS + DaisyUI**: Styling framework

## Component Architecture

```
src/
├── App.vue                    # Root component, layout, global error handling
├── main.ts                    # App initialization, plugin setup
├── router/index.ts            # Route definitions
├── views/                     # Page components
│   ├── MapView.vue           # Main orchestrator (142 lines, REFACTORED ✓)
│   └── AboutView.vue         # About page
├── components/
│   ├── MapRenderer.vue       # Map rendering (259 lines)
│   ├── TerritoryControls.vue # Territory controls (283 lines)
│   ├── configuration/        # NEW: Configuration section components
│   │   ├── AtlasConfigSection.vue      # Atlas/region/territory selection (40 lines)
│   │   ├── ViewConfigSection.vue       # View mode & projection config (71 lines)
│   │   └── DisplayOptionsSection.vue   # Display toggles (44 lines)
│   ├── views/                # NEW: View mode components
│   │   ├── SplitView.vue              # Split mode rendering (139 lines)
│   │   ├── CompositeCustomView.vue    # Custom composite (8 lines)
│   │   ├── CompositeExistingView.vue  # Pre-built composite (8 lines)
│   │   └── UnifiedView.vue            # Unified mode (14 lines)
│   └── ui/                   # Reusable UI components
│       ├── AppHeader.vue
│       ├── AppFooter.vue
│       ├── CardContainer.vue
│       ├── FormControl.vue
│       ├── ProjectionSelector.vue (468 lines)
│       ├── ProjectionParamsControls.vue
│       ├── ProjectionInfo.vue
│       ├── ProjectionConfirmDialog.vue
│       ├── ViewModeSection.vue
│       ├── SectionHeader.vue
│       ├── ThemeSelector.vue
│       ├── LanguageSelector.vue
│       ├── ToastNotification.vue
│       └── LoadingModal.vue
├── composables/              # NEW: Reusable composition functions
│   ├── useProjectionValidation.ts   # Projection validation
│   ├── useAtlasData.ts              # Data loading orchestration (128 lines)
│   ├── useLoadingState.ts           # Loading state management (32 lines)
│   ├── useProjectionConfig.ts       # Projection configuration (58 lines)
│   ├── useViewMode.ts               # View mode logic (34 lines)
│   ├── useTerritoryConfig.ts        # Territory configuration (27 lines)
│   └── useTerritoryTransforms.ts    # Territory transforms (155 lines, for future use)
└── stores/
    ├── config.ts              # Configuration state (391 lines)
    └── geoData.ts             # Geographic data state (200 lines)
```

## Current Issues

### 1. MapView Component Bloat (528 lines)
**Problem**: Single view component handles too many concerns:
- Atlas configuration
- View mode management
- Projection configuration
- Data loading orchestration
- Layout rendering for 4 different view modes
- Watchers for region/mode/territory changes

**Impact**:
- Hard to maintain and test
- Complex template with nested v-if conditions
- Difficult to add new features
- Poor separation of concerns

### 2. Insufficient Component Decomposition ✓ RESOLVED
**Problem**: Large monolithic components instead of focused, reusable ones.
**Status**: RESOLVED via refactoring (2025-10-10)

**Before**:
- MapView.vue: 528 lines - monolithic orchestrator
- ProjectionSelector.vue: 468 lines (still needs attention)
- TerritoryControls.vue: 283 lines
- MapRenderer.vue: 259 lines

**After**:
- MapView.vue: 142 lines (73% reduction) - clean orchestrator
- Created 4 view components: SplitView, CompositeCustomView, CompositeExistingView, UnifiedView
- Created 3 config sections: AtlasConfigSection, ViewConfigSection, DisplayOptionsSection
- Created 6 composables for reusable logic

**Impact**: ✅ Resolved
- Clear component hierarchy established
- Focused, single-responsibility components
- Easy to test and understand
- Reusable patterns

### 3. State Management Patterns ✓ IMPROVED
**Problem**: Mixed state management approaches.
**Status**: IMPROVED via composables pattern (2025-10-10)

**Before**:
- Direct store access in templates
- Computed properties wrapping store state scattered in components
- Inconsistent patterns across components

**After**:
- Composables abstract store interactions
- Consistent patterns: useViewMode(), useProjectionConfig(), useTerritoryConfig()
- Clear ownership: composables own store access logic
- Templates use composable-provided reactive values

**Impact**: ✅ Improved
- Consistent patterns across components
- Predictable state flow
- Better testability (mock composables instead of stores)

### 4. Data Loading Strategy ✓ RESOLVED
**Problem**: Complex loading orchestration scattered in MapView.
**Status**: RESOLVED via useAtlasData composable (2025-10-10)

**Before**:
- 3 watchers in MapView (viewMode, selectedAtlas, territoryMode)
- inline `withMinLoadingTime` wrapper
- 75+ lines of loading logic in MapView
- Loading logic mixed with component logic

**After**:
- useAtlasData() composable centralizes all loading logic
- useLoadingState() composable for skeleton management
- Watchers encapsulated in setupWatchers() method
- MapView lifecycle: `initialize()` + `setupWatchers()` - 2 lines

**Impact**: ✅ Resolved
- Centralized loading state machine
- No race conditions
- Easy to reason about loading flow
- Reusable across components

### 5. Type Safety Gaps
**Problem**: Some type definitions incomplete:
- Props with optional defaults but no validation
- Loose typing in some event handlers
- Missing null checks in computed properties

**Impact**:
- Runtime errors possible
- Poor IDE intellisense
- Hard to refactor safely

### 6. Component Communication
**Problem**: Mixed patterns for component communication:
- Direct store mutations
- v-model bindings
- Event emitters
- Props drilling

**Impact**:
- Inconsistent data flow
- Hard to trace changes
- Difficult to implement features

## Refactoring Achievements (2025-10-10)

### MapView.vue Transformation
**Metric**: Reduced from 528 lines to 142 lines (73% reduction, exceeded 150-line goal)

**Phase 1: View Components** (4 files created)
- SplitView.vue (139 lines) - Split mode rendering with mainland + territories
- CompositeCustomView.vue (8 lines) - Custom composite projection
- CompositeExistingView.vue (8 lines) - Pre-built composite projections
- UnifiedView.vue (14 lines) - Unified projection mode

**Phase 2: Configuration Sections** (3 files created)
- AtlasConfigSection.vue (40 lines) - Atlas/region/territory selection
- ViewConfigSection.vue (71 lines) - View mode & projection configuration
- DisplayOptionsSection.vue (44 lines) - Display toggles (graticule, sphere, borders, limits)

**Phase 3: Data Loading Composables** (2 files created)
- useLoadingState.ts (32 lines) - Skeleton visibility with minimum duration
- useAtlasData.ts (128 lines) - Centralized data loading orchestration, watchers

**Phase 4: Store Composables** (3 files created)
- useProjectionConfig.ts (58 lines) - Projection configuration helpers
- useViewMode.ts (34 lines) - View mode options and logic
- useTerritoryConfig.ts (27 lines) - Territory-related computed properties

**Phase 5: Component Simplification** (2 composables + 2 components refactored)
- useTerritoryTransforms.ts (155 lines) - Territory transform controls
- TerritoryControls.vue: 283 → 247 lines (13% reduction, 36 lines removed)
- useProjectionFiltering.ts (91 lines) - Projection search/filter logic
- useProjectionRecommendations.ts (78 lines) - Recommendation display logic
- ProjectionSelector.vue: 468 → 341 lines (27% reduction, 127 lines removed)
- ProjectionSearchBar.vue (48 lines), ProjectionDropdown.vue (118 lines), ProjectionRecommendationBadge.vue (52 lines)

**Phase 6: Store Organization** (2 new stores created)
- ui.ts (68 lines) - Theme management, display toggles (graticule, sphere, borders, limits)
- territory.ts (57 lines) - Territory projections, translations, scales
- Note: Stores created but not yet integrated into config.ts (requires migration)

### Total Impact
- **Files Created**: 24 new files (16 components + 7 composables + 2 stores - 1 plan)
- **MapView.vue**: 528 → 142 lines (73% reduction, 386 lines removed)
- **TerritoryControls.vue**: 283 → 247 lines (13% reduction, 36 lines removed)
- **ProjectionSelector.vue**: 468 → 341 lines (27% reduction, 127 lines removed)
- **Total Lines Reduced**: 549 lines removed from 3 major components
- **Improved Testability**: Each composable/component/store can be tested independently
- **Better Reusability**: Composables and stores can be used across components
- **Clear Separation**: View logic, data loading, configuration, UI state all separated

## Strengths

✅ **Good Patterns**:
- Composition API with `<script setup>` - modern and concise
- Service layer separation - logic not in components
- Pinia stores - reactive and well-structured
- TypeScript usage - good type safety where implemented
- i18n integration - proper internationalization
- Composables pattern - reusable, testable logic

✅ **Well-Designed Components**:
- FormControl - reusable, consistent API
- CardContainer - good layout component
- ViewModeSection - clean view mode switching
- ToastNotification - proper error display
- NEW: All Phase 1-2 components - focused, single-responsibility

✅ **Service Integration**:
- Services properly used for business logic
- Clear separation: UI → Store → Service → Domain
- Cartographer service manages rendering lifecycle

## Component Relationships

```
App.vue
├── AppHeader.vue
├── RouterView
│   └── MapView.vue (MAIN VIEW)
│       ├── CardContainer (x3)
│       │   ├── Controls Section
│       │   │   ├── FormControl (atlas, territory, theme)
│       │   │   └── ThemeSelector
│       │   ├── View Configuration Section
│       │   │   ├── FormControl (view mode, proj mode)
│       │   │   ├── ProjectionSelector
│       │   │   └── ProjectionParamsControls
│       │   └── Map Display Section
│       │       ├── ViewModeSection (x4 modes)
│       │       │   ├── MapRenderer (split/composite/unified)
│       │       │   ├── TerritoryControls
│       │       │   └── SectionHeader
│       └── Territory Config Section
│           └── TerritoryControls
└── AppFooter.vue
```

## State Management

### configStore (391 lines) - Main Configuration
**Responsibilities**:
- Atlas selection and configuration
- View mode and projection mode
- Projection parameters (custom overrides)
- Territory projections, translations, scales
- UI visibility flags (computed)
- Theme management

**Issues**:
- Too many responsibilities
- Mixes UI state with domain state
- Large file, hard to navigate
- Some computed properties could be separate composables

**Future Migration**: Theme + display toggles → ui.ts, territory state → territory.ts

### ui.ts (68 lines) - UI State (NEW, Phase 6)
**Responsibilities**:
- Theme management (light/dark)
- Display toggles (graticule, sphere, composition borders, map limits)
- localStorage persistence for UI preferences

**Status**: Created but not yet integrated into config.ts

**Functions**:
- initializeTheme(), setTheme(), applyTheme()
- initializeDisplayOptions()

### territory.ts (57 lines) - Territory Configuration (NEW, Phase 6)
**Responsibilities**:
- Territory projections, translations, scales
- Loading defaults from TerritoryDefaultsService
- Territory-specific state management

**Status**: Created but not yet integrated into config.ts

**Functions**:
- initializeDefaults(atlas, region)
- setTerritoryProjection/Translation/Scale()
- resetAll()

### geoDataStore (200 lines)
**Responsibilities**:
- Data loading and caching
- Territory filtering
- Cartographer instance management
- Loading state and error handling

**Issues**:
- Cartographer lifecycle tightly coupled to store
- Data loading logic could be extracted
- Territory filtering duplicates service logic

## Composables

### useProjectionValidation (148 lines)
**Purpose**: Validates projection selections, provides warnings

**Good**:
- Single responsibility
- Reusable logic
- Clear interface

**Opportunity**:
- Could return more granular validation hooks
- Could be split into smaller composables

## Current Data Flow

```
User Action (Template)
    ↓
Direct Store Mutation / v-model
    ↓
Store State Change
    ↓
Watcher in MapView / MapRenderer
    ↓
Service Call (if needed)
    ↓
Store Update / Component Re-render
```

**Issues**:
- No clear action/command pattern
- State changes scattered
- Hard to implement undo/redo
- Difficult to add analytics/logging

## Recommended Patterns

### 1. Composition API Best Practices
- Use `<script setup lang="ts">` - already done ✓
- Extract logic to composables - partially done
- Keep components focused - NEEDS WORK
- Use `defineProps` with types - done ✓

### 2. State Management
- Store for global state only
- Component state for local UI state
- Computed properties for derived state
- Actions for state mutations (not direct mutations)

### 3. Component Design
- Single Responsibility Principle
- Props down, events up
- Composition over inheritance
- Keep templates simple (<100 lines)

### 4. Code Organization
- Group by feature, not by type
- Co-locate related files
- Extract complex logic to composables
- Keep components focused

## Performance Considerations

### Current State
- No virtual scrolling for territory lists
- All watchers are not optimized with `{ deep: true }` sparingly used
- No lazy loading of components
- Skeleton timing uses artificial delays

### Optimization Opportunities
- Implement virtual scrolling for large territory lists
- Use `v-memo` for static content
- Lazy load heavy components (ProjectionSelector)
- Optimize watchers with proper dependencies
- Use `shallowRef` where deep reactivity not needed

## Testing Considerations

### Current State
- No component tests visible
- Complex components hard to test
- Tight coupling to stores makes mocking difficult

### Testing Strategy
- Unit test composables (isolated logic)
- Component tests with Testing Library
- Mock stores for component tests
- E2E tests for critical flows
- Test service layer independently

## Related Documentation

- docs/architecture.llm.txt - Overall architecture
- docs/services.llm.txt - Service layer
- docs/atlases.llm.txt - Atlas configuration system
