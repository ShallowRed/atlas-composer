# Vue Architecture

## Overview

Vue 3 Composition API application with TypeScript, Pinia stores, and composable-based logic extraction.

**Stack**: Vue 3, TypeScript, Pinia, Vue Router, Vue I18n, Tailwind CSS, DaisyUI
**Test Framework**: Vitest + @vue/test-utils
**Test Coverage**: 175 tests (100% passing)

## Project Structure

```
src/
├── App.vue                    # Root component, layout
├── main.ts                    # App initialization
├── router/index.ts            # Route definitions
├── views/
│   ├── MapView.vue           # Main view (simplified with useViewState)
│   └── AboutView.vue         # About page
├── components/
│   ├── MapRenderer.vue       # D3 map rendering (147 lines)
│   ├── TerritoryControls.vue # [UNUSED] Territory controls (superseded by view-mode controls, can be deleted)
│   ├── configuration/        # View-mode-specific control components (4 components)
│   │   ├── CompositeCustomControls.vue   # Composite-custom mode controls
│   │   ├── UnifiedControls.vue           # Unified mode controls
│   │   ├── SplitControls.vue             # Split mode controls
│   │   └── BuiltInCompositeControls.vue # Composite-existing mode controls
│   └── ui/                   # 28 reusable UI components organized in subdirectories
│       ├── layout/           # Layout and page structure components
│       ├── primitives/       # Core reusable UI elements
│       ├── forms/            # Form controls and inputs
│       ├── settings/         # Settings and preferences
│       ├── projections/      # Projection-related components (3 components)
│       ├── parameters/       # Parameter control components (3 components)
│       ├── presets/          # Preset management components
│       ├── import/           # Import-related components
│       └── export/           # Export-related components
├── composables/              # 16 composition functions including useAtlasConfig, useParameterProvider, useViewState, useTerritoryCursor, useClipExtentEditor, useProjectionPanning, useMapWatchers, useTerritoryParameters
├── stores/                   # 4 Pinia stores
└── types/                    # TypeScript definitions
```

## Component Hierarchy

```
App.vue
├── AppHeader.vue (navigation, language, theme)
├── RouterView
│   └── MapView.vue (main coordinator)
│       ├── MapRenderer.vue (D3 rendering engine)
│       └── View-Mode Controls (rendered conditionally)
│           ├── CompositeCustomControls (composite-custom mode)
│           ├── UnifiedControls (unified mode)
│           ├── SplitControls (split mode)
│           └── BuiltInCompositeControls (built-in-composite mode)
└── AppFooter.vue (credits, links)
```

## Key Components

### MapView.vue (142 lines)
**Role**: Main coordinator component
**Responsibilities**:
- Orchestrates child components
- Manages layout and sections
- Renders view-mode-specific control components
- No business logic (delegates to composables)
- Uses: useAtlasData, useLoadingState, useViewState

### MapRenderer.vue (376 lines)
**Role**: D3 rendering engine with interactive features
**Responsibilities**:
- SVG canvas management
- D3 projection rendering via MapRenderCoordinator
- Territory positioning
- Interactive feature integration (panning via useProjectionPanning, dragging via useTerritoryCursor, clip extent editing via useClipExtentEditor)
- Reactive map updates via useMapWatchers
- Uses: MapRenderCoordinator, MapSizeCalculator, useProjectionPanning, useTerritoryCursor, useClipExtentEditor, useMapWatchers
**Tests**: 13 tests covering props, rendering, store integration
**Interactive Features**:
- **Projection Panning**: Via useProjectionPanning composable for azimuthal, cylindrical, and pseudocylindrical projections
- **Territory Dragging**: Via useTerritoryCursor composable for composite-custom mode
- **Clip Extent Editing**: Via useClipExtentEditor composable for corner handle editing
**Watchers**: All reactive dependencies handled by useMapWatchers composable
**Cursor Coordination**: Territory dragging > Clip extent editing > Projection panning priority

### View-Mode Control Components (src/components/configuration/)

Dedicated control components for each view mode provide focused, maintainable interfaces.

#### CompositeCustomControls.vue
**Role**: Controls for composite-custom mode (full territory configuration with positioning)
**Responsibilities**:
- PresetSelector for loading saved configurations
- ImportControls for JSON import
- GlobalProjectionControls (canvas dimensions, reference scale)
- Territory accordion with per-territory controls:
  - ProjectionDropdown for projection selection (handles cartographer updates)
  - TerritoryParameterControls for parameter editing (projection-independent)
- Reset to defaults button for all territories
**Pattern**: Calls `handleProjectionChange()` to update both parameter store and cartographer
**Reactivity**: Uses `getTerritoryProjection()` helper for direct parameter store access
- Reset to defaults functionality
- Uses: useTerritoryTransforms, projectionRegistry, parameterStore

#### UnifiedControls.vue
**Role**: Controls for unified mode (single projection for entire atlas)
**Responsibilities**:
- ViewPresetSelector for preset selection
- ProjectionDropdown for global projection selection
- Projection parameter controls (rotate, center, parallels, scale)
- Fitting mode toggle (auto/manual)
- Reset functionality
**Parameter Access**:
- Reads: `parameterStore.globalEffectiveParameters` for current values
- Writes: `configStore.setCustomRotate()`, `setCustomCenter()`, etc. (delegates to parameterStore)
- Parameter inheritance: Registry → Atlas → Global
- Uses: configStore, parameterStore, projectionRegistry, parameter helpers

#### SplitControls.vue
**Role**: Controls for split mode (separate projections per territory without positioning)
**Responsibilities**:
- ViewPresetSelector for preset selection
- Territory accordion with per-territory controls:
  - ProjectionDropdown for projection selection
  - TerritoryParameterControls for parameter editing (no transform controls)
- No global positioning or reference scale
**Pattern**: Each territory has independent projection selection with parameter editing
**Reactivity**: Uses `getTerritoryProjection()` helper for direct parameter store access
- Uses: useTerritoryTransforms, projectionRegistry, parameterStore

#### BuiltInCompositeControls.vue
**Role**: Controls for built-in-composite mode (d3-composite-projections)
**Responsibilities**:
- ViewPresetSelector for preset selection
- ProjectionDropdown for selecting pre-built composite projections
- Limited projection parameter controls (rotate, scale if applicable)
- Fitting mode toggle (auto/manual)
- Reset functionality
- Uses: configStore, projectionRegistry, parameter helpers

### TerritoryControls.vue [UNUSED - Can be deleted]
**Role**: Original territory transform and parameter controls (pre-refactoring)
**Status**: Superseded by view-mode-specific control components
**Note**: This file is not imported anywhere and can be safely deleted.

### ProjectionSelector.vue (114 lines)
**Role**: Projection selection interface
**Responsibilities**:
- Projection search/filter
- Projection dropdown
- Recommendation badges
- Uses: useProjectionFiltering, useProjectionRecommendations

### UI Components (30 components organized in 8 subdirectories)

**Layout Components** (src/components/ui/layout/):
- **AppHeader**: Application header with navigation, language selector, and theme selector
- **AppFooter**: Application footer with credits and links
- **MainLayout**: Main application layout structure
- **ScrollableContent**: Scrollable content wrapper

**Primitive Components** (src/components/ui/primitives/):
- **AccordionItem**: Collapsible content item with title/subtitle
- **Alert**: Status/notification messages with type variants (info, success, warning, error)
- **ButtonGroup**: Toggle button group for exclusive selection with full-width layout
- **CardContainer**: Card wrapper with title, icon, and scrollable content. Supports optional actions slot for buttons in header (e.g., ShareButton in MapView main card)
- **LabelWithIcon**: Label wrapper with optional icon
- **Modal**: Standardized dialog wrapper with slots for title, content, and actions

**Form Controls** (src/components/ui/forms/):
- **CheckboxControl**: Checkboxes for boolean settings (42 lines)
- **RangeSlider**: Range input with label, icon, value display, and customizable styling
- **DropdownControl**: Accessible DaisyUI dropdown selections with icon/badge support (590 lines, 42 tests)
  - Two modes: standard (fieldset wrapper) and inline (for navbar use)
  - Manual JS-controlled dropdown (overrides DaisyUI CSS focus behavior)
  - Supports emoji/text icons and icon classes (detects 'ri-' prefix)
  - Supports badges for visual indicators (e.g., projection recommendations)
  - Supports option groups with category labels
  - Full keyboard navigation:
    - Up/Down arrows: when open only, immediately select previous/next option and stay open
    - Left/Right arrows: when closed only, cycle through options with looping (first↔last)
    - Enter/Space: select focused option and close dropdown (or open if closed)
    - Escape: close dropdown
    - Home/End: jump to first/last option (when open)
    - Tab: close dropdown and move focus
    - Click: select option and close dropdown
  - Automatic scroll behavior: focused option scrolls into view during keyboard navigation
  - ARIA attributes for screen readers (role, aria-expanded, aria-selected, aria-activedescendant)
  - Focus management with CSS highlighting (no DOM focus to avoid blur conflicts)
  - Thick visible focus state (2px outline + background color) for accessibility
  - Selected option highlighted with primary color when dropdown open
  - Translation support with Vue I18n ($t() integration)
  - isNavigating flag prevents blur events during arrow navigation
  - Exports DropdownOption and DropdownOptionGroup interfaces
  - Comprehensive test suite covers rendering, state management, selection, keyboard navigation, accessibility, and edge cases
- **ToggleControl**: Toggle switches for boolean settings (42 lines)

**Settings Components** (src/components/ui/settings/):
- **LanguageSelector**: Language selection dropdown using DropdownControl in inline mode
  - Uses inline prop for navbar integration (no fieldset wrapper)
  - Converts SUPPORTED_LOCALES to DropdownOption format
  - Uses setLocale() for language switching
  - Ghost button style with translate icon
- **ThemeSelector**: Theme selection interface using DropdownControl with option groups
  - Groups themes into light and dark categories
  - 35 theme options across 2 groups
- **ShareButton**: Shareable URL generator with clipboard copy functionality
  - Uses useUrlState composable to generate shareable URLs
  - One-click copy to clipboard with visual feedback
  - Three states: default (Share), success (Copied!), error (Failed to copy)
  - Auto-resets after 2 seconds (success) or 3 seconds (error)
  - Displays full URL in tooltip on hover
  - Ghost button style with share/check/error icons (Remix icons)
  - Positioned in MapView main content card header (top right corner)
  - Fully tested (9 tests covering rendering, copy, state transitions, timeout handling)

**Projection Components** (src/components/ui/projections/):
- **ProjectionDropdown**: Projection selection component with info modal
  - Uses DropdownControl with recommendation badges (Remix icons)
  - Displays badge icons to left of projection names
  - Badge system: ri-star-fill (excellent), ri-star-line (good), ri-star-half-line (usable)
  - Includes info button that opens ProjectionInfo modal
  - Supports loading skeleton state
  - Automatically transforms recommendation badges with CSS classes (text-success, text-info, text-base-content)
- **ProjectionInfo**: Projection information display
- **ProjectionParamsControls**: Projection parameter adjustment controls with latitude lock toggle

**Parameter Components** (src/components/ui/parameters/):
- **GlobalProjectionControls**: Global projection parameter controls for composite projections
  - Provides UI controls for canvas dimensions (width/height) with aspect ratio lock
  - Provides reference scale slider for adjusting base scale across all territories
  - Canvas dimensions control actual SVG display size via MapSizeCalculator
  - Reference scale serves as base multiplier for all territory scale calculations
  - Updates configStore.canvasDimensions and configStore.referenceScale reactively
  - Watchers in MapRenderer trigger automatic re-rendering on parameter changes
  - Used in TerritoryControls component for composite-custom mode
- **TerritoryParameterControls**: Territory-specific parameter editing interface (projection-independent)
  - Uses unified `ProjectionParameters` interface across all parameter operations
  - Integrates with `parameterStore` for reactive parameter management
  - Template conditions use computed properties for parameter group visibility
  - Provides parameter controls for individual territories (no projection selection)
  - Uses dynamic projection family detection via projectionRegistry
  - Supports all projection families (CONIC, AZIMUTHAL, CYLINDRICAL, etc.)
  - Parameter groups: Position (center/rotate), Projection-specific (parallels), View & Scale (projection scale/clipAngle), Advanced (precision/translate)
  - Validation feedback with real-time error/warning display via `ParameterRegistry`
  - Parameter inheritance indicators and override functionality
  - Reset controls for clearing territory-specific overrides
  - **View-mode awareness**: Uses `isCompositeMode` computed to filter composite-specific parameters (translateOffset, pixelClipExtent) in split mode
  - **Single responsibility**: Focuses solely on parameter editing; projection selection handled by parent components
- **TerritorySetManager**: Territory customization UI for composite-custom mode
  - Manages which territories are included in custom composite projection
  - Displays active territories with remove buttons (btn-soft style with close icon)
  - Displays available territories with add buttons (btn-ghost style with add icon)
  - Filters out mainland from available territories (mainland always visible)
  - Limits available territories to those loaded from preset (territories with data)
  - Calls configStore.addTerritoryToComposite() and removeTerritoryFromComposite()
  - Triggers re-render via geoDataStore.triggerRender() after add/remove operations
  - Used in CompositeCustomControls and TerritoriesControl components
- **ParameterControlGroup**: Reusable parameter control group wrapper
  - Provides consistent styling and layout for parameter sections
  - Supports title, description, and collapsible content areas
- **ParameterValidationFeedback**: Parameter validation feedback display
  - Shows validation errors and warnings with contextual messaging
  - Integrates with parameter validation system for real-time feedback

**Import Components** (src/components/ui/import/):
- **ImportControls**: Import and export control buttons
- **ImportModal**: Modal for importing configurations

**Export Components** (src/components/ui/export/):
- **CompositeExportDialog**: Dialog for exporting composite configurations
- **ToastNotification**: Toast notification display

**Preset Components** (src/components/ui/presets/):
- **PresetSelector**: Dropdown for manual preset selection and loading
  - Displays available presets for current atlas with metadata-based labels
  - Handles async preset loading, validation, and application to stores
  - Integrates with parameter store and CompositeProjection for complete preset application
  - Manages loading states and error display
  - Critical feature: Updates CompositeProjection via `updateTerritoryParameters()` after parameter store changes

**Composition Patterns**:
- RangeSlider used in ProjectionParamsControls (6 instances) and TerritoryControls (3 instances)
- ButtonGroup used in CompositeExportDialog (3 instances)
- Modal used in CompositeExportDialog for standardized dialogs
- Alert used in ProjectionParamsControls and TerritoryControls for status messages
- DropdownControl used in AtlasConfigSection (5 instances), ThemeSelector (1 instance), LanguageSelector (1 instance), ProjectionDropdown (1 instance)
  - Supports emoji/text icons (flag emojis: 🇫🇷, 🇵🇹, 🇪🇸, 🇪🇺, 🇺🇸, 🌍)
  - Supports icon classes (remix icons: ri-layout-grid-line, etc.)
  - Supports icon badges (projection recommendations: ri-star-fill, ri-star-line, ri-star-half-line)
  - Icon badges positioned to left of option label
  - Badge CSS classes automatically applied (text-success, text-info, text-base-content)
  - Group titles display category icons (via PROJECTION_CATEGORY_ICONS from projection-icons.ts)
  - Full a11y: ARIA attributes, keyboard navigation (Arrow keys, Enter, Space, Escape, Home, End, Tab)
  - Focus management with visible focus states (WCAG AA compliant)
  - Translation support with Vue I18n integration
- ToggleControl used in DisplayOptionsSection (4 instances) and TerritoryControls (1 instance)

## Composables (14 functions)

### Data Loading
**useAtlasLoader** (24 lines)
- Reactive async atlas configuration loading
- Uses VueUse's useAsyncState for loading state management
- Loads atlas config on-demand via registry.loadAtlasAsync()
- Returns: { atlasConfig (Ref<LoadedAtlasConfig | null>), isLoading, error }
- Used by: configStore for lazy atlas loading

**useAtlasData** (128 lines)
- Orchestrates all data loading
- initialize(), loadDataForViewMode(), reinitialize(), reloadUnifiedData()
- setupWatchers() - Consolidates all data loading watchers
- Returns: { showSkeleton, initialize, loadDataForViewMode, reinitialize, reloadUnifiedData, setupWatchers }
- Tests: 13 tests

**useLoadingState** (32 lines)
- Manages skeleton loading state
- withMinLoadingTime() - Ensures minimum loading duration
- Returns: { showSkeleton, withMinLoadingTime }

### Store Abstraction
**useAtlasConfig** (51 lines) - NEW (2025-10-19)
- Centralized atlas configuration access
- Provides: currentAtlasConfig, atlasService, isAtlasLoaded, atlasId
- Eliminates repeated configStore.currentAtlasConfig patterns
- Returns computed refs for reactive atlas state
- Used by: useTerritoryTransforms.ts, and other composables needing atlas config
- Tests: 6 tests covering basic functionality and reactivity
- Pattern: Single source of truth for atlas configuration access

**useParameterProvider** (55 lines) - NEW (2025-10-19)
- Standardized parameter provider adapter
- Provides: parameterProvider object with getEffectiveParameters() and getExportableParameters()
- Connects parameter store to services (Cartographer, export services)
- Single implementation eliminating duplicate adapter code
- Used by: CompositeExportDialog.vue, and services needing projection parameters
- Tests: 5 tests covering delegation and consistency
- Pattern: Adapter pattern for parameter store integration

**useProjectionConfig** (58 lines)
- Projection configuration helpers
- compositeProjectionOptions, getMainlandProjection(), getTerritoryProjection()
- Returns: { compositeProjectionOptions, getMainlandProjection, getTerritoryProjection }
- Tests: 8 tests

**useViewMode** (34 lines)
- View mode options
- Returns: { viewModeOptions }

**useTerritoryConfig** (27 lines)
- Territory configuration state
- Returns: { hasTerritoriesForProjectionConfig }

### Component Logic
**useTerritoryTransforms** (312 lines)
- Territory projection management
- Translation and scale controls (reads scale from parameter store)
- Reset functions
- Empty state logic: shouldShowEmptyState computed (determines when to show "no territories" alert)
- Uses: useAtlasConfig composable for centralized atlas access
- Used by: TerritoryControls.vue

**useTerritoryParameters** (72 lines)
- Territory-specific parameter management for custom composite mode
- Encapsulates parameter state, validation, and inheritance logic
- Integrates with parameter store for reactive parameter updates
- Provides parameter constraints and validation results by projection family
- Used by: TerritoryParameterControls.vue

**useViewState** (110 lines) - NEW
- View mode boolean flags for template readability
- Card UI helpers (title, icon)
- Compound visibility conditions
- Exports: isCompositeMode, isCompositeCustomMode, isCompositeExistingMode, isSplitMode, isUnifiedMode
- Exports: cardTitle, cardIcon, shouldShowRightSidebar, shouldShowProjectionParams, shouldShowTerritoryControls
- Tests: 13 tests (100% passing)
- Used by: MapView.vue, DisplayOptionsSection.vue
- Pattern: Wraps configStore.viewMode checks with semantic computed properties

**useProjectionRecommendations** (78 lines)
- Projection recommendation badge system
- getBadge(): Returns Remix icon class (ri-star-fill, ri-star-line, ri-star-half-line)
- getCssClass(): Returns color class (text-success, text-info, text-base-content)
- getTooltip(): Returns localized recommendation reason
- getRecommendation(): Returns full recommendation object
- Used by: ProjectionDropdown.vue

**useTerritoryCursor** (477 lines)
- Territory drag-to-move functionality for composite-custom mode with D3.js integration
- SVG coordinate mapping: getSVGScale() calculates screen-to-canvas pixel ratio from CTM (Current Transformation Matrix)
- Accurate drag movement: Converts screen pixel deltas to SVG canvas pixels by dividing by scale factor
- D3 DOM manipulation: Uses D3 selections for all SVG element interaction and styling
- Visual feedback system: updateTerritoryVisualFeedback() with hover/drag states using D3 styling
- Temporary border creation: createTemporaryBorder() generates borders when composition borders disabled
- Smart border detection: Detects existing borders vs. creating temporary ones for consistent UX
- D3-based overlay system: createBorderZoneOverlays() uses D3 data binding for interactive zones
  - Accepts optional onTerritoryClick callback for territory selection coordination
  - Click events fire callback with territoryCode before mousedown (enables selection workflow)
- Mouse event handling: startDrag(), handleMouseMove(), stopDrag() with scale-adjusted coordinate application
- Territory validation: isTerritoryDraggable() prevents mainland territory dragging
- Cursor management: getCursorStyle() provides grab/grabbing feedback
- Tooltip interference prevention: disableTooltipPointerEvents() using D3 selections and MutationObserver
- Clean resource management: Automatic cleanup of temporary borders and observers
- Used by: MapRenderer.vue for territory dragging interaction and clip extent editor integration

**useClipExtentEditor** (302 lines)
- Interactive clip extent corner editing for composite-custom mode with D3.js integration
- Territory selection system: selectedTerritoryCode tracks which territory shows corner handles
- Selection methods: selectTerritory(), deselectTerritory(), toggleTerritorySelection()
- Prevents visual clutter: Only selected territory displays corner handles (4 corners per territory)
- SVG coordinate mapping: getSVGScale() for accurate screen-to-canvas pixel conversion (same as useTerritoryCursor)
- Corner handle rendering: renderClipExtentHandles() creates draggable circular handles using D3 data binding
  - Filters geoDataStore.filteredTerritories to only selected territory
  - Calculates corner positions from pixelClipExtent `[x1, y1, x2, y2]` relative to territory center
  - Creates 4 handles: top-left (0), top-right (1), bottom-right (2), bottom-left (3)
  - Blue circular handles with hover effects (r=6→8, opacity=0.7→1.0)
  - Handles positioned at absolute canvas coordinates: `territoryCenter + translateOffset + clipExtentCorner`
- Corner drag interaction: startCornerDrag(), handleCornerMouseMove(), stopCornerDrag()
  - Tracks dragCornerIndex to determine which two values update (x1/x2 and y1/y2)
  - Converts screen pixel deltas to canvas pixels using scale factor
  - Updates pixelClipExtent parameter via parameterStore.setTerritoryParameter()
  - Re-renders handles during drag for real-time visual feedback
  - Rounds values to integers for clean parameter values
- Coordinate system: Works in canvas pixel space matching translateOffset coordinate system
- Integration with useTerritoryCursor: MapRenderer passes toggleTerritorySelection as onTerritoryClick callback
- Click workflow: User clicks territory border zone → toggles selection → handles appear/disappear for that territory
- Used by: MapRenderer.vue for interactive clip extent editing

**useProjectionPanning** (162 lines)
- Interactive projection panning for azimuthal, cylindrical, and pseudocylindrical projections
- Pan state management: isPanning, drag coordinates, rotation start values
- Projection capability detection: supportsPanning, supportsLatitudePanning
- Mouse event handlers: handleMouseDown(), handleMouseMove(), handleMouseUp()
- Rotation calculations: Converts pixel deltas to degrees (~0.5° per pixel)
  - Longitude wrapping: -180° to 180° range
  - Latitude clamping: -90° to 90° range (prevents pole flipping)
  - Natural drag direction: drag right moves map right (positive dx increases longitude)
- Integration with configStore.setCustomRotate() for rotation updates
- Respects configStore.rotateLatitudeLocked for latitude lock behavior
- Cursor feedback: 'grab' when available, 'grabbing' while panning, 'default' when disabled
- Global event listener management with cleanup
- Uses getRelevantParameters() to determine projection family support
- Works with projectionRegistry for projection metadata
- Tests: 19 tests covering capability detection, cursor styles, drag behavior, rotation calculations
- Used by: MapRenderer.vue for interactive map rotation

**useMapWatchers** (155 lines)
- Consolidates all MapRenderer watch statements into single composable
- Watches globalEffectiveParameters: Updates cartographer.updateProjectionParams() and triggers re-render
- Watches projectionFittingMode: Updates cartographer.updateFittingMode() and triggers re-render
- Watches canvasDimensions: Updates cartographer.updateCanvasDimensions() and triggers re-render
- Watches referenceScale: Updates cartographer.updateReferenceScale() and triggers re-render
- **Simple mode watcher**: Tracks configuration dependencies and `parameterStore.territoryParametersVersion` for territory projection/parameter changes
- **Composite mode watcher**: Tracks composite-specific dependencies without deprecated properties
- Deep watching with 'post' flush for optimal reactivity
- Accepts props object (mode, geoData, projection, preserveScale) and callbacks object
- Centralizes watcher lifecycle management with cleanup function
- Used by: MapRenderer.vue for reactive map updates

**useUrlState** (220 lines)
- URL state serialization/deserialization for shareable links
- serializeState(): Encodes current configuration to URL query parameters
- deserializeState(): Restores configuration from URL parameters
- updateUrl(): Updates browser URL with current state
- restoreFromUrl(): Restores state from URL on page load
- shareableUrl: Computed property with full shareable URL
- copyShareableUrl(): Copies URL to clipboard
- enableAutoSync(): Optional automatic URL syncing on state changes
- Territory settings optimization: Only includes values different from atlas-specific defaults
- Comprehensive test suite: 11 tests covering serialization round-trips, edge cases, malformed input
- Used by: MapView.vue (restoration), ShareButton.vue (URL generation)

### Validation
**useProjectionValidation** (148 lines)
- Projection selection validation
- Warning generation
- Validation state management

## View Orchestration

### ViewOrchestrationService (382 lines)
**Location**: `src/services/view/view-orchestration-service.ts`

**Purpose**: Centralized component visibility logic for all view states. Determines what UI elements should be visible or enabled based on current application state.

**Architecture**:
- Pure static service (no instance state)
- Takes `ViewState` snapshot as input
- Returns boolean visibility/enabled flags
- All methods are deterministic and testable

**ViewState Interface**:
```typescript
interface ViewState {
  viewMode: ViewMode                          // composite-custom, built-in-composite, split, unified
  atlasConfig: AtlasConfig                    // Current atlas configuration
  hasPresets: boolean                         // Presets available for current atlas
  hasOverseasTerritories: boolean             // Filtered territories exist
  isPresetLoading: boolean                    // Preset data loading state
  showProjectionSelector: boolean             // From ProjectionUIService
  showIndividualProjectionSelectors: boolean  // From ProjectionUIService
  isMainlandInTerritories: boolean            // Mainland in filtered list
  showMainland: boolean                       // Atlas has mainland config
}
```

**Visibility Methods** (20+ methods):

**Main Layout**:
- `shouldShowRightSidebar()` - Show sidebar in non-unified modes
- `shouldShowBottomBar()` - Always visible (display options)

**Sidebar Content**:
- `shouldShowProjectionParams()` - Show in unified, built-in-composite modes
- `shouldShowTerritoryControls()` - Show in split, composite-custom modes

**Territory Controls Sub-components**:
- `shouldShowPresetSelector()` - Show in composite-custom with presets
- `shouldShowImportControls()` - Show in composite-custom or split modes
- `shouldShowGlobalProjectionControls()` - Show in composite-custom mode
- `shouldShowTerritoryParameterControls()` - Show in composite-custom mode
- `shouldShowMainlandAccordion()` - Show when mainland available (showMainland or isMainlandInTerritories)
- `shouldShowProjectionDropdown()` - Show in non-composite-custom modes

**Empty States**:
- `shouldShowEmptyState()` - No territories and no mainland available
- `getEmptyStateMessage()` - Returns appropriate i18n key for empty state

**Control States**:
- `isTerritorySelectDisabled()` - Disable if no hasTerritorySelector or in built-in-composite
- `isViewModeDisabled()` - Disable if only one supported view mode

**Layout Variants**:
- `shouldShowCompositeRenderer()` - Show for both composite modes
- `shouldShowSplitView()` - Show in split mode
- `shouldShowUnifiedView()` - Show in unified mode

**Display Options**:
- `shouldShowCompositionBordersToggle()` - Show in composite modes
- `shouldShowScalePreservationToggle()` - Show in split mode

**Integration Pattern**:
The service is used via `useViewState` composable, which:
1. Aggregates state from stores into `ViewState` object
2. Wraps all service methods in computed refs for reactivity
3. Exposes `viewOrchestration` object to components

**Example Usage** (in components):
```vue
<script setup>
const { viewOrchestration } = useViewState()
</script>

<template>
  <CardContainer v-show="viewOrchestration.shouldShowRightSidebar.value">
    <ProjectionParamsControls v-if="viewOrchestration.shouldShowProjectionParams.value" />
    <TerritoryControls v-else-if="viewOrchestration.shouldShowTerritoryControls.value" />
  </CardContainer>
</template>
```

**Benefits**:
1. Single source of truth for all visibility logic
2. Pure functions enable comprehensive unit testing (61 tests)
3. Type-safe visibility decisions with explicit ViewState interface
4. Eliminates scattered conditional logic across components
5. Easier to reason about view state transitions
6. Consistent behavior across all UI elements

**Test Coverage**: 61 unit tests covering all visibility methods and state combinations

**Used by**: MapView.vue, TerritoryControls.vue, AtlasConfigSection.vue, DisplayOptionsSection.vue (via useViewState composable)

## State Management

### configStore (357 lines)
**Domain**: Configuration state and UI control
**Responsibilities**:
- Atlas selection (current atlas, region, territories)
- Lazy atlas loading via useAtlasLoader composable with reactive async state
- Current atlas config reactively updated when atlas finishes loading
- atlasService computed re-evaluates on atlas load completion (depends on currentAtlasConfig.value?.id)
- View mode (composite, split, unified)
- Projection parameter delegation to parameterStore (setCustomRotate, setCustomCenter, etc.)
- Projection control options (rotateLatitudeLocked, projectionFittingMode)
- Global projection parameters (referenceScale, canvasDimensions)
  - referenceScale: Base scale multiplier for all territories in composite projections
  - canvasDimensions: Canvas size specification (width/height) controlling SVG display size
  - Both values loaded from presets and editable via GlobalProjectionControls
  - Watchers in MapRenderer trigger re-rendering on changes
- Global parameter access: Delegates to parameterStore.globalEffectiveParameters for unified parameter retrieval
- Territory parameter initialization on atlas change via AtlasCoordinator
- Loads preset parameters into parameter store
- **Territory set management**: activeTerritoryCodes ref (Set<string>) tracks included territories in custom composite mode
  - addTerritoryToComposite(code): Adds territory to active set (creates new Set for reactivity)
  - removeTerritoryFromComposite(code): Removes territory from active set (creates new Set for reactivity)
  - setActiveTerritories(codes[]): Replaces entire active set (used for preset loading and reset)
  - Initialized from preset territory codes during preset loading
  - Reset to preset defaults via useTerritoryTransforms.resetTransforms()
**Used by**: All configuration components, MapRenderer, TerritoryControls, GlobalProjectionControls, TerritorySetManager

### geoDataStore (215 lines)
**Domain**: Geographic data and rendering coordination
**Responsibilities**:
- GeoJSON data caching
- Territory data management
- Loading states
- Cartographer initialization with parameter provider injection
- Parameter provider adapter for connecting parameter store to rendering
- **Territory filtering**: filteredTerritories computed filters territories based on view mode
  - Custom composite mode: Filters by configStore.activeTerritoryCodes (user-customizable set)
  - Built-in composite mode: Returns all territories from preset (no filtering)
  - Split/unified modes: Filters by territory mode from atlas configuration
  - Used by MapRenderer and territory UI components for rendering active territories
**Used by**: MapRenderer, data loading composables, TerritorySetManager

### ui.ts (81 lines)
**Domain**: UI state
**Responsibilities**:
- Theme management (light/dark)
- Display toggles (graticule, sphere, composition borders, map limits)
  - showGraticule: Display coordinate grid lines (default: false)
  - showSphere: Display sphere outline (default: false)
  - showCompositionBorders: Display territory region borders - default: true for improved clip extent editing UX
  - showMapLimits: Display viewport bounds rectangle (default: false)
**Used by**: ThemeSelector, DisplayOptionsSection, MapRenderer

### parameterStore (295 lines)
**Domain**: Unified parameter registry integration
**Responsibilities**:
- Parameter registry integration with ProjectionParameterManager
- Global parameter state management with registry validation
- Territory-specific parameter overrides with registry constraints
- Territory projections via projectionId parameter
- Territory positions via translateOffset parameter tuple [x, y]
- Territory scales via scaleMultiplier parameter
- Territory clip extents via pixelClipExtent parameter
- Parameter inheritance: territory > global > atlas > registry defaults
- Registry-based parameter validation with family-specific constraint checking
- Reactive version tracking via territoryParametersVersion for UI updates
- Registry-driven constraint resolution for UI components
- Helper methods for backward compatibility: getTerritoryProjection(), setTerritoryProjection(), getTerritoryTranslation(), setTerritoryTranslation()
**Used by**: All territory controls, MapRenderer, TerritoryControls, composables, export/import services

**Note**: Territory configuration is fully managed through the parameter system. Territory projections and positions are stored as parameters with proper validation, inheritance, and constraint checking.
- Complete parameter export using registry definitions (getExportableParameters)
- ProjectionParameterProvider interface implementation for rendering
**Registry Integration**:
- All parameter operations validated through parameter registry
- Registry-based constraint resolution for UI controls
- Registry metadata drives parameter display and validation
- Type-safe parameter operations with registry enforcement
**Used by**: TerritoryParameterControls (registry constraints), useTerritoryParameters, MapRenderer (watches version), geoDataStore (parameter provider), export system

## Data Flow

```
User Action (Template)
    ↓
v-model / Event Handler
    ↓
Composable Logic (if needed)
    ↓
Store Action/Mutation
    ↓
Store State Change
    ↓
Watcher in Composable (useAtlasData)
    ↓
Service Call
    ↓
Store Update → Component Re-render
```

**Key Pattern**: Centralized data loading in useAtlasData composable with setupWatchers()

## Parameter Registry Integration Architecture

### Registry-Based Parameter Flow

```
Parameter Edit (TerritoryParameterControls)
    • Uses registry constraints for min/max/step values
    • Registry-based validation in real-time
    ↓
parameterStore.setTerritoryParameter()
    • Registry validation before storing
    • Parameter registry default fallbacks
    • Increments territoryParametersVersion
    • Emits @parameter-changed event
    ↓                                    ↓
Event Handler                      MapRenderer Watch
(handleParameterChange)            (territoryParametersVersion)
    ↓                                    ↓
cartographer.updateTerritoryParameters() triggers renderMap()
    ↓
CompositeProjection.updateTerritoryParameters()
    • Calls parameterProvider.getEffectiveParameters()
    • Registry-based parameter resolution with inheritance
    • Applies parameters to D3 projection using registry metadata
    • Sets compositeProjection = null (forces rebuild)
    ↓
renderMap() with registry-validated parameters
```

### Enhanced Parameter Provider Pattern

**Purpose**: Registry-integrated parameter resolution for rendering

**Implementation**:
- `ProjectionParameterProvider` interface with `getEffectiveParameters()` and `getExportableParameters()` methods
- geoDataStore creates adapter connecting parameterStore to Cartographer
- Adapter uses registry-based parameter resolution for complete coverage
- Cartographer passes provider to CompositeProjection for rendering and export

**Registry Benefits**:
- Parameter inheritance with registry defaults as final fallback
- Type-safe parameter operations with registry constraint validation
- Complete parameter coverage for export (registry defines all exportable parameters)
- UI constraint resolution (min/max/step) directly from registry metadata

**Benefits**:
- No circular dependencies
- Clean separation of concerns
- Testable via dependency injection
- Parameter inheritance handled by parameter store

## Type Safety

### vue-props.ts (130 lines)
Centralized prop type definitions:
- MapRendererProps
- ViewComponentProps
- TerritoryControlsProps
- ProjectionSelectorProps
- DisplayOptionsSectionProps
- All props include default values exported as constants

### composables.ts (240 lines)
Composable return type interfaces:
- LoadingState
- ProjectionConfig
- TerritoryConfig
- ViewModeConfig
- TerritoryTransforms
- AtlasData
- ProjectionFiltering

### Central Export
All types exported from `src/types/index.ts` for consistent imports.

## Testing

**Framework**: Vitest + @vue/test-utils
**Coverage**: 122 tests (100% passing)

### Test Files
- `src/components/__tests__/MapRenderer.spec.ts` (10 tests)
  - Props validation, rendering, store integration, computed properties
- `src/composables/__tests__/useProjectionConfig.spec.ts` (8 tests)
  - Projection helpers, i18n integration
- `src/composables/__tests__/useAtlasData.spec.ts` (13 tests)
  - Data loading orchestration, watchers, error handling

### Test Infrastructure
- i18n mocking with createI18n
- Store mocking with createPinia/setActivePinia
- withSetup() helper for composable testing with Vue context
- Promise rejection handling with .catch(() => {})

## Patterns

### Composition API
- All components use `<script setup lang="ts">`
- Logic extracted to composables
- Props defined with defineProps<Type>()
- Events defined with defineEmits<Type>()

### State Management
- Global state: Pinia stores
- Local state: component refs
- Derived state: computed properties
- Store abstraction: composables wrap store access

### Component Design
- Single Responsibility Principle
- Props down, events up
- Composition over inheritance
- Templates under 100 lines

### Code Organization
- Feature-based grouping (composables/, stores/, components/ui/)
- Co-located tests (__tests__ folders)
- Centralized types (src/types/)
- Average component size: 70 lines

## Performance

### Current Optimizations
- Watchers centralized in useAtlasData.setupWatchers()
- Loading state with withMinLoadingTime()
- Shallow component hierarchy
- Composables enable code splitting

### Future Opportunities
- Virtual scrolling for large territory lists
- v-memo for static map content
- Lazy loading for ProjectionSelector
- shallowRef for large GeoJSON objects
- Computed property memoization

## Integration Points

### Services
Components never call services directly. Flow:
1. Component action
2. Store mutation
3. Watcher in useAtlasData
4. Service call
5. Store update
6. Component re-render

### D3/Observable Plot
- MapRenderer.vue owns D3 integration
- CartographerService coordinates rendering
- Services handle D3 projection creation

### I18n
- Vue I18n plugin for translations
- useI18n() composable in components
- Locale files: src/i18n/locales/en.json, fr.json

## Conditional Rendering Patterns

### Template Readability Guidelines

**Pattern**: Extract complex conditionals into computed properties
**Rationale**: Improves template readability and maintainability

**Before** (inline conditionals):
```vue
<CardContainer
  v-show="(
    configStore.viewMode === 'unified'
    || configStore.viewMode === 'built-in-composite'
    || configStore.showProjectionSelector
    || configStore.showIndividualProjectionSelectors
  )"
>
```

**After** (composable with semantic flags):
```vue
<CardContainer v-show="shouldShowRightSidebar">
```

### Visibility Logic Architecture

**configStore**: Provides computed properties via ProjectionUIService
- `showProjectionSelector`, `showIndividualProjectionSelectors`
- These delegate to ProjectionUIService.shouldShow*() methods
- Single source of truth for component visibility rules

**useViewState**: Provides view mode flags and UI helpers
- Boolean flags: `isCompositeMode`, `isSplitMode`, `isUnifiedMode`, etc.
- Compound conditions: `shouldShowRightSidebar`, `shouldShowProjectionParams`
- Card helpers: `cardTitle`, `cardIcon`
- Does NOT duplicate configStore logic

**Best Practice**: Use configStore.show* for component visibility, useViewState for view mode checks

## Territory Customization Workflow (Custom Composite Mode)

### Overview
Custom composite mode allows users to select which territories to include in the composite projection. Territory set customization is managed through configStore.activeTerritoryCodes and visualized via TerritorySetManager component.

### Territory Set State Flow

**Initialization**:
1. Preset loaded via PresetLoader.loadPreset()
2. Territory codes extracted from preset.territories
3. configStore.setActiveTerritories(territoryCodes) initializes activeTerritoryCodes Set
4. InitializationService stores territory codes for validation

**Display Filtering**:
1. geoDataStore.filteredTerritories computed filters by activeTerritoryCodes
2. Only territories in activeTerritoryCodes Set are visible in UI and rendered on map
3. Mainland always visible (handled separately from overseas territories)

**User Interaction**:
1. User clicks "Add" button in TerritorySetManager
2. TerritorySetManager calls configStore.addTerritoryToComposite(code)
3. configStore adds code to activeTerritoryCodes Set (creates new Set for reactivity)
4. TerritorySetManager calls geoDataStore.triggerRender()
5. Map re-renders with new territory included

**Composition Border Filtering**:
1. MapRenderer passes filteredTerritoryCodes Set to MapOverlayService
2. MapOverlayService.renderCustomCompositeBorders() filters borders
3. Mainland border always rendered (checked via mainlandCode parameter)
4. Overseas territory borders only rendered if in filteredTerritoryCodes Set
5. Result: Visual borders match active territory set

**Reset to Defaults**:
1. User clicks reset button in TerritoriesControl
2. TerritoriesControl.resetToDefaults() calls useTerritoryTransforms.resetTransforms()
3. resetTransforms() extracts preset territory codes from presetDefaults
4. Calls configStore.setActiveTerritories(presetTerritoryCodes)
5. Calls geoDataStore.triggerRender()
6. Territory set and parameters restored to preset state

**Divergence Detection**:
1. TerritoriesControl.hasDivergingFromPreset computed checks territory set
2. Compares activeTerritoryCodes with preset territory codes (Set equality check)
3. If sets differ in size or membership, reset button enabled
4. Also checks parameter divergence for comprehensive reset detection

### Component Integration

**TerritorySetManager** (src/components/ui/parameters/TerritorySetManager.vue):
- Displays active territories with remove buttons
- Displays available territories with add buttons
- Filters out mainland from available list
- Limits available territories to those loaded from preset

**TerritoriesControl** (src/components/ui/parameters/TerritoriesControl.vue):
- Renders TerritorySetManager for territory selection
- Provides reset button enabled when territory set or parameters diverge
- Manages territory parameter controls via accordion

**CompositeCustomControls** (src/components/configuration/CompositeCustomControls.vue):
- Top-level component for custom composite mode
- Integrates PresetSelector, TerritorySetManager, and parameter controls
- Coordinates territory projection and parameter management

### State Management

**configStore** (src/stores/config.ts):
- activeTerritoryCodes: Set<string> - Active territory codes
- addTerritoryToComposite(code): Add territory to active set
- removeTerritoryFromComposite(code): Remove territory from active set
- setActiveTerritories(codes[]): Replace entire active set

**geoDataStore** (src/stores/geoData.ts):
- filteredTerritories: Computed property filtering by activeTerritoryCodes
- overseasTerritoriesData: All loaded territory data (source for filtering)
- triggerRender(): Force map re-render after territory set changes

### Design Decisions

**Why Set<string>**: O(1) membership checking for efficient filtering in computed properties and render loops.

**Why filter at display level**: Keeps data loading simple and avoids reloading data when changing territory set.

**Why limit to preset territories**: Adding arbitrary territories would require rebuilding CompositeProjection with new subProjections, which is architecturally complex. Limiting to preset territories ensures all territories have projection configurations and parameters.

**Why always show mainland**: Mainland is the primary territory in single-focus atlases and should always be visible for context.

**Why new Set for reactivity**: Vue 3 reactivity requires creating new object references when mutating Sets (ref unwrapping doesn't track Set mutations).

## Related Documentation

- docs/architecture.llm.rxt - Overall architecture
- docs/services.llm.txt - Service layer
- docs/atlases.llm.txt - Atlas configuration
- docs/projections.llm.txt - Projection system
