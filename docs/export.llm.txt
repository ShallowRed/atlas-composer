# Export System

## Overview
The export system generates standalone code for composite projections in multiple formats:
- D3.js (JavaScript and TypeScript)
- Observable Plot (JavaScript)

Exports allow users to use their custom composite projections outside Atlas Composer.

## Architecture

### Code Generation Pipeline
1. **Configuration Export** - Serialize composite projection state
2. **Code Generation** - Generate projection code in target format
3. **User Delivery** - Copy to clipboard with notifications

### Files
- `src/services/export/config-exporter.ts` - Configuration serialization
- `src/services/export/code-generator.ts` - Code generation (D3/Plot)
- `src/components/ui/ExportModal.vue` - UI component

## Configuration Export (config-exporter.ts)

### ExportedCompositeConfig Type
Serialized projection configuration with:
- `mainProjection` - Primary projection ID and parameters
- `territories[]` - Array of territory configurations
  - `id` - Territory identifier
  - `projectionId` - D3 projection name
  - `projectionParams` - All projection parameters (center, rotate, parallels, scale, translate)
  - `bounds` - Geographic bounds [[minLon, minLat], [maxLon, maxLat]]

### ConfigExporter.export()
Extracts configuration from stores and services:
- Reads from `configStore` (projection state)
- Reads from `territoryStore` (territory positions/scales)
- Uses `CompositeProjection` for territory projections
- Rounds all numeric values to 6 decimals for precision

## Code Generation (code-generator.ts)

### Formats

#### D3 JavaScript (generateD3JS)
Generates standalone JavaScript function:
```javascript
function createCompositeProjection(width, height) {
  const proj0 = d3.geoAzimuthalEqualArea()
    .center([2.5, 47])
    .rotate([-2.5, -47])
    // ... parameters
  
  const compositeProjection = d3.geoProjection(function(lon, lat) {
    // Stream multiplexing logic
  })
  
  return compositeProjection
}
```

#### D3 TypeScript (generateD3TS)
Adds TypeScript type annotations:
```typescript
function createCompositeProjection(
  width: number,
  height: number
): d3.GeoProjection {
  // ... same as JS with types
}
```

#### Observable Plot (generateObservablePlot)
Generates Plot-compatible projection function:
```javascript
function createCompositeProjection({ width, height }) {
  // Sub-projections
  // Stream multiplexing
  // Returns Plot-compatible projection
}
```

### Stream Multiplexing Protocol

All formats implement D3 stream protocol for routing geometry to sub-projections.

#### D3 Stream API Requirements
The stream protocol requires strict method call ordering:
1. `polygonStart()` - Begin a polygon (multi-ring)
2. `lineStart()` - Begin a ring/line
3. `point(lon, lat)` - Add point to current ring
4. `lineEnd()` - End current ring/line
5. `polygonEnd()` - End polygon

Polygons = polygonStart + (one or more rings) + polygonEnd
Each ring = lineStart + points + lineEnd

#### State Machine Implementation
Four tracking variables manage stream routing:
- `activeStream` - Currently selected sub-projection stream (null when undecided)
- `polygonActive` - Whether inside polygon (between polygonStart/polygonEnd)
- `polygonStarted` - Whether polygonStart() was called on active stream
- `ringActive` - Whether inside ring (between lineStart/lineEnd)

#### Stream Methods

**point(lon, lat)**
Routes point to appropriate sub-projection based on geographic bounds:
1. Find matching stream by checking if `[lon, lat]` falls within territory bounds
2. If first point of ring (`!ringActive`):
   - Set `activeStream` to matched stream
   - Set `ringActive = true`
   - If in polygon and not started, call `s.polygonStart()` and set `polygonStarted = true`
   - Call `s.lineStart()`
3. Call `s.point(lon, lat)` on active stream

**lineStart()**
Marks start of new ring:
- Reset `ringActive = false`
- Active stream determined by first point

**lineEnd()**
Marks end of ring:
- Call `activeStream.lineEnd()` if stream exists
- If NOT in polygon, reset `activeStream = null` (single-ring features)
- If in polygon, preserve `activeStream` for multi-ring polygons

**polygonStart()**
Marks start of polygon:
- Set `polygonActive = true`
- Reset `polygonStarted = false`
- Reset `activeStream = null` (critical for feature independence)

**polygonEnd()**
Marks end of polygon:
- Call `activeStream.polygonEnd()` if stream exists and started
- Reset all state: `activeStream = null`, `polygonActive = false`, `polygonStarted = false`

#### Feature Independence
Critical requirement: Each GeoJSON feature must independently select its stream.

The `activeStream = null` reset in `polygonStart()` ensures:
- First polygon (mainland) selects stream based on its first point
- Second polygon (overseas territory) selects different stream based on its first point
- No stream leakage between features

Without this reset, all features would use the same stream (first feature's stream), causing territories to disappear or render in wrong locations.

#### Geographic Bounds Routing
Each territory has bounds `[[minLon, minLat], [maxLon, maxLat]]`.

Point routing checks if point falls within any territory's bounds:
```javascript
const epsilon = 1e-6
const isInBounds = 
  lon >= bounds[0][0] - epsilon && 
  lon <= bounds[1][0] + epsilon &&
  lat >= bounds[0][1] - epsilon && 
  lat <= bounds[1][1] + epsilon
```

Epsilon (1e-6) provides small tolerance for floating point comparisons.

### Number Precision

JavaScript floating point arithmetic can produce precision errors:
- `-61.46000000000001` instead of `-61.46`
- `-17.110000000000003` instead of `-17.11`

Solution: Round all coordinates to 6 decimals in generated code.

Helper functions:
```typescript
roundNumber(n: number, decimals = 6): number {
  const factor = 10 ** decimals
  return Math.round(n * factor) / factor
}

formatNumberArray(arr: number[]): string {
  return `[${arr.map(n => roundNumber(n)).join(', ')}]`
}
```

Applied to all projection parameters:
- center, rotate, parallels, scale, translate, bounds

### Projection Name Mapping

D3 projection IDs use kebab-case (e.g., `azimuthal-equal-area`).
D3 function names use camelCase (e.g., `d3.geoAzimuthalEqualArea`).

Mapping logic:
```typescript
const projectionMap: Record<string, string> = {
  'azimuthal-equal-area': 'geoAzimuthalEqualArea',
  'azimuthal-equidistant': 'geoAzimuthalEquidistant',
  // ... 20+ projections
}
```

Function: `getD3ProjectionFunction(projectionId: string): string`
- Returns D3 function name for projection ID
- Used in code generation templates

## UI Integration (ExportModal.vue)

### Features
- Format selection (D3 JS/TS, Observable Plot)
- One-click copy to clipboard
- Success/error notifications
- Modal dialog with proper keyboard navigation

### Component Dependencies
- Uses `ConfigExporter` for serialization
- Uses `CodeGenerator` for code generation
- Uses `useToast` composable for notifications
- Integrates with `uiStore` for modal state

## Testing

### Test Coverage
- ✅ 15 tests for config export (config-exporter.spec.ts)
- ✅ 25 tests for code generation (code-generator.spec.ts)
- Tests validate:
  - Configuration serialization
  - D3 JS/TS code generation
  - Observable Plot code generation
  - Projection name mapping
  - Number formatting and rounding
  - Stream multiplexing logic

### Known Limitations
- No validation of generated code syntax (future: AST parsing)
- No runtime testing of generated projections (future: headless browser tests)

## Usage Example

Generated code can be used in Observable notebooks, standalone HTML, or Node.js:

```javascript
// In Observable Plot
Plot.plot({
  projection: createCompositeProjection,
  marks: [
    Plot.geo(world, {stroke: "currentColor"})
  ]
})

// In D3
const svg = d3.select("svg")
const projection = createCompositeProjection(960, 500)
const path = d3.geoPath(projection)
svg.selectAll("path")
  .data(features)
  .join("path")
  .attr("d", path)
```

## Import Support

### CompositeImportService
Re-imports exported JSON configurations back into Atlas Composer.
Process:
1. Parse and validate JSON structure
2. Check version compatibility (currently v1.0)
3. Validate required fields (metadata, territories, parameters)
4. Warn if atlas ID mismatch (but allows import)
5. Apply configuration to stores (configStore, territoryStore)
6. Reconstruct CompositeProjection from imported data

UI Integration:
- ImportModal.vue component with drag-drop file upload
- Validation result display (errors/warnings)
- Configuration preview before applying
- Integrated in ViewConfigSection.vue alongside Export button

## Standalone Projection Loader

### Purpose
Pure JavaScript/TypeScript module for using exported configurations outside Atlas Composer.
**Zero-dependency** plugin architecture - users register projection factories at runtime.

### Architecture: Zero Dependencies
The loader has NO dependencies on d3-geo or d3-geo-projection. Instead, users register projection factories before loading configurations. This approach provides:
- No version conflicts
- Smaller bundle size (user includes only needed projections)
- Tree-shakeable imports
- Support for custom projection implementations
- Future-proof design

### API

#### Registration (Required First Step)
```typescript
import * as d3 from 'd3-geo'
import { 
  registerProjection, 
  registerProjections,
  loadCompositeProjection 
} from './standalone-projection-loader'

// Option 1: Register projections individually
registerProjection('mercator', () => d3.geoMercator())
registerProjection('albers', () => d3.geoAlbers())

// Option 2: Bulk registration using helper
import { d3ProjectionFactories } from './d3-projection-helpers'
registerProjections(d3ProjectionFactories)

// Now load configuration
const projection = loadCompositeProjection(config, { width: 800, height: 600 })
```

#### Loading Projections
```typescript
import { loadFromJSON, validateConfig } from './standalone-projection-loader'

// Load from JSON string
const projection = loadFromJSON(jsonString, { width: 800, height: 600 })

// Or parse first, then load
const config = JSON.parse(jsonString)
validateConfig(config)  // throws if invalid
const projection = loadCompositeProjection(config, { 
  width: 800, 
  height: 600,
  debug: true  // log territory selection
})

// Use with D3
const path = d3.geoPath(projection)
```

#### Registry Management
```typescript
import { 
  getRegisteredProjections,
  isProjectionRegistered,
  unregisterProjection,
  clearProjections 
} from './standalone-projection-loader'

// Check what's registered
const projections = getRegisteredProjections()  // ['mercator', 'albers', ...]

// Check if specific projection is registered
if (!isProjectionRegistered('mercator')) {
  registerProjection('mercator', () => d3.geoMercator())
}

// Cleanup
unregisterProjection('mercator')
clearProjections()  // remove all
```

### Features
- **Zero dependencies** - no d3-geo, no d3-geo-projection
- Plugin architecture with runtime registration
- No Atlas Composer dependencies
- Works in browser, Node.js, Observable notebooks
- D3 stream multiplexing for geometry routing
- Geographic bounds-based territory selection
- Supports 14+ standard D3 projections + custom projections
- Type-safe with TypeScript definitions
- Tree-shakeable - import only needed projections

### Type Definitions
Self-contained types without external dependencies:
- `ProjectionLike` - D3-compatible projection interface with getter/setter pattern
- `ProjectionFactory` - Factory function type `() => ProjectionLike`
- `StreamLike` - D3 stream protocol interface
- `LoaderOptions` - Configuration options (width, height, debug, etc.)

### D3 Projection Helpers (Optional Companion)
`d3-projection-helpers.ts` provides ready-to-use D3 mappings:
```typescript
import { 
  d3ProjectionFactories,    // All projections
  mercator,                  // Individual (tree-shakeable)
  albers,
  registerAllD3Projections 
} from './d3-projection-helpers'

// Use bulk registration
registerProjections(d3ProjectionFactories)

// Or tree-shakeable individual imports
registerProjection('mercator', mercator)
registerProjection('albers', albers)
```

### Use Cases
- Embed Atlas Composer projections in custom D3 visualizations
- Server-side rendering with Node.js
- Observable notebooks and interactive documents
- Static site generation
- Sharing projections with users who don't have Atlas Composer
- Custom projection implementations for specialized use cases

### NPM Package Structure
```
@atlas-composer/projection-loader/
├── package.json (ZERO dependencies)
├── README.md
├── src/
│   ├── index.ts (standalone-projection-loader.ts)
│   └── d3-helpers.ts (d3-projection-helpers.ts) [optional]
├── dist/
│   ├── index.js (ESM)
│   ├── index.cjs (CommonJS)
│   └── index.d.ts (TypeScript types)
└── examples/
    ├── browser-basic.html
    ├── node-usage.js
    └── tree-shakeable.js
```

**Dependencies**: NONE
**devDependencies**: d3-geo, d3-geo-projection (for types and optional helpers)

User controls D3 version and includes only needed projections.

## Testing
- CompositeExportService: 15 tests covering export, validation, file creation
- CompositeImportService: 13 tests covering import, validation, store integration
- CodeGenerator: 25 tests covering all formats and code generation
- Standalone Loader: 19 tests covering loading, validation, projection functionality
Total: 72 tests for export/import system

## Future Enhancements
- Additional export formats (Leaflet, Mapbox GL JS adapters)
- Code minification option for generated code
- Browser preview of exported projection
- Version migration for config format upgrades
- Batch export for multiple configurations
