# Export System

## Overview
The export system generates standalone code for composite projections in multiple formats:
- D3.js (JavaScript and TypeScript)
- Observable Plot (JavaScript)

Exports allow users to use their custom composite projections outside Atlas Composer.

## Architecture

### Code Generation Pipeline
1. **Configuration Export** - Serialize composite projection state
2. **Code Generation** - Generate projection code in target format
3. **User Delivery** - Copy to clipboard with notifications

### Files
- `src/services/export/config-exporter.ts` - Configuration serialization
- `src/services/export/code-generator.ts` - Code generation (D3/Plot)
- `src/components/ui/ExportModal.vue` - UI component

## Configuration Export (config-exporter.ts)

### ExportedCompositeConfig Type
Serialized projection configuration with:
- `mainProjection` - Primary projection ID and parameters
- `territories[]` - Array of territory configurations
  - `id` - Territory identifier
  - `projectionId` - D3 projection name
  - `projectionParams` - All projection parameters (center, rotate, parallels, scale, translate)
  - `bounds` - Geographic bounds [[minLon, minLat], [maxLon, maxLat]]

### ConfigExporter.export()
Extracts configuration from stores and services:
- Reads from `configStore` (projection state)
- Reads from `territoryStore` (territory positions/scales)
- Uses `CompositeProjection` for territory projections
- Rounds all numeric values to 6 decimals for precision

## Code Generation (code-generator.ts)

### Formats

#### D3 JavaScript (generateD3JS)
Generates standalone JavaScript function:
```javascript
function createCompositeProjection(width, height) {
  const proj0 = d3.geoAzimuthalEqualArea()
    .center([2.5, 47])
    .rotate([-2.5, -47])
    // ... parameters
  
  const compositeProjection = d3.geoProjection(function(lon, lat) {
    // Stream multiplexing logic
  })
  
  return compositeProjection
}
```

#### D3 TypeScript (generateD3TS)
Adds TypeScript type annotations:
```typescript
function createCompositeProjection(
  width: number,
  height: number
): d3.GeoProjection {
  // ... same as JS with types
}
```

#### Observable Plot (generateObservablePlot)
Generates Plot-compatible projection function:
```javascript
function createCompositeProjection({ width, height }) {
  // Sub-projections
  // Stream multiplexing
  // Returns Plot-compatible projection
}
```

### Stream Multiplexing Protocol

All formats implement D3 stream protocol for routing geometry to sub-projections.

#### D3 Stream API Requirements
The stream protocol requires strict method call ordering:
1. `polygonStart()` - Begin a polygon (multi-ring)
2. `lineStart()` - Begin a ring/line
3. `point(lon, lat)` - Add point to current ring
4. `lineEnd()` - End current ring/line
5. `polygonEnd()` - End polygon

Polygons = polygonStart + (one or more rings) + polygonEnd
Each ring = lineStart + points + lineEnd

#### State Machine Implementation
Four tracking variables manage stream routing:
- `activeStream` - Currently selected sub-projection stream (null when undecided)
- `polygonActive` - Whether inside polygon (between polygonStart/polygonEnd)
- `polygonStarted` - Whether polygonStart() was called on active stream
- `ringActive` - Whether inside ring (between lineStart/lineEnd)

#### Stream Methods

**point(lon, lat)**
Routes point to appropriate sub-projection based on geographic bounds:
1. Find matching stream by checking if `[lon, lat]` falls within territory bounds
2. If first point of ring (`!ringActive`):
   - Set `activeStream` to matched stream
   - Set `ringActive = true`
   - If in polygon and not started, call `s.polygonStart()` and set `polygonStarted = true`
   - Call `s.lineStart()`
3. Call `s.point(lon, lat)` on active stream

**lineStart()**
Marks start of new ring:
- Reset `ringActive = false`
- Active stream determined by first point

**lineEnd()**
Marks end of ring:
- Call `activeStream.lineEnd()` if stream exists
- If NOT in polygon, reset `activeStream = null` (single-ring features)
- If in polygon, preserve `activeStream` for multi-ring polygons

**polygonStart()**
Marks start of polygon:
- Set `polygonActive = true`
- Reset `polygonStarted = false`
- Reset `activeStream = null` (critical for feature independence)

**polygonEnd()**
Marks end of polygon:
- Call `activeStream.polygonEnd()` if stream exists and started
- Reset all state: `activeStream = null`, `polygonActive = false`, `polygonStarted = false`

#### Feature Independence
Critical requirement: Each GeoJSON feature must independently select its stream.

The `activeStream = null` reset in `polygonStart()` ensures:
- First polygon (mainland) selects stream based on its first point
- Second polygon (overseas territory) selects different stream based on its first point
- No stream leakage between features

Without this reset, all features would use the same stream (first feature's stream), causing territories to disappear or render in wrong locations.

#### Geographic Bounds Routing
Each territory has bounds `[[minLon, minLat], [maxLon, maxLat]]`.

Point routing checks if point falls within any territory's bounds:
```javascript
const epsilon = 1e-6
const isInBounds = 
  lon >= bounds[0][0] - epsilon && 
  lon <= bounds[1][0] + epsilon &&
  lat >= bounds[0][1] - epsilon && 
  lat <= bounds[1][1] + epsilon
```

Epsilon (1e-6) provides small tolerance for floating point comparisons.

### Number Precision

JavaScript floating point arithmetic can produce precision errors:
- `-61.46000000000001` instead of `-61.46`
- `-17.110000000000003` instead of `-17.11`

Solution: Round all coordinates to 6 decimals in generated code.

Helper functions:
```typescript
roundNumber(n: number, decimals = 6): number {
  const factor = 10 ** decimals
  return Math.round(n * factor) / factor
}

formatNumberArray(arr: number[]): string {
  return `[${arr.map(n => roundNumber(n)).join(', ')}]`
}
```

Applied to all projection parameters:
- center, rotate, parallels, scale, translate, bounds

### Projection Name Mapping

D3 projection IDs use kebab-case (e.g., `azimuthal-equal-area`).
D3 function names use camelCase (e.g., `d3.geoAzimuthalEqualArea`).

Mapping logic:
```typescript
const projectionMap: Record<string, string> = {
  'azimuthal-equal-area': 'geoAzimuthalEqualArea',
  'azimuthal-equidistant': 'geoAzimuthalEquidistant',
  // ... 20+ projections
}
```

Function: `getD3ProjectionFunction(projectionId: string): string`
- Returns D3 function name for projection ID
- Used in code generation templates

## UI Integration (ExportModal.vue)

### Features
- Format selection (D3 JS/TS, Observable Plot)
- One-click copy to clipboard
- Success/error notifications
- Modal dialog with proper keyboard navigation

### Component Dependencies
- Uses `ConfigExporter` for serialization
- Uses `CodeGenerator` for code generation
- Uses `useToast` composable for notifications
- Integrates with `uiStore` for modal state

## Testing

### Test Coverage
- ✅ 15 tests for config export (config-exporter.spec.ts)
- ✅ 25 tests for code generation (code-generator.spec.ts)
- Tests validate:
  - Configuration serialization
  - D3 JS/TS code generation
  - Observable Plot code generation
  - Projection name mapping
  - Number formatting and rounding
  - Stream multiplexing logic

### Known Limitations
- No validation of generated code syntax (future: AST parsing)
- No runtime testing of generated projections (future: headless browser tests)

## Usage Example

Generated code can be used in Observable notebooks, standalone HTML, or Node.js:

```javascript
// In Observable Plot
Plot.plot({
  projection: createCompositeProjection,
  marks: [
    Plot.geo(world, {stroke: "currentColor"})
  ]
})

// In D3
const svg = d3.select("svg")
const projection = createCompositeProjection(960, 500)
const path = d3.geoPath(projection)
svg.selectAll("path")
  .data(features)
  .join("path")
  .attr("d", path)
```

## Future Enhancements
- Import support (apply exported config back to app)
- Additional formats (Leaflet, Mapbox GL JS)
- Code minification option
- Validation of generated code
- Browser preview of exported projection
