# Preset Management System

## Overview

The preset system manages saved projection configurations for all view modes using a unified architecture. A single loader handles all preset types, a single registry tracks all presets, and discriminated union types provide type-safe handling across the application.

## Preset Types

Four preset types exist in a discriminated union (`Preset`):

1. **composite-custom** - Custom composite projections with full per-territory configuration (exportable, round-trip capable)
2. **unified** - Single projection covering the entire atlas
3. **split** - Individual projections per territory group
4. **built-in-composite** - Predefined projections from d3-composite-projections library

## Architecture

### Core Layer (src/core/presets/)

**Types** (`types.ts`)
- Unified domain types with discriminated unions
- `LoadResult<T>` - Generic result type for all loading operations
- `Preset` - Discriminated union of CompositePreset | UnifiedPreset | SplitPreset | CompositeExistingPreset
- `PresetType` - Type discriminator ('composite-custom' | 'unified' | 'split' | 'built-in-composite')
- `PresetRegistry` - Unified registry for all preset types
- `BasePresetMetadata` - Shared metadata fields (id, name, description, atlasId)
- Configuration types: CompositeCustomConfig, UnifiedViewConfig, SplitViewConfig, CompositeExistingViewConfig

**Validators** (`validator.ts`)
- Unified validation with strategy pattern
- `validatePreset()` - Routes to appropriate validator based on preset type
- `validateCompositePreset()` - Validates composite preset structure and parameters
- `validateViewPreset()` - Validates view mode preset configuration
- Parameter validation using parameter registry
- Required parameter checks for preset integrity

**Converters** (`converter.ts`)
- Pure conversion functions between formats
- `convertToDefaults()` - Converts preset to TerritoryDefaults format
- `extractTerritoryParameters()` - Extracts projection parameters from preset
- Registry-driven parameter extraction

### Service Layer (src/services/presets/)

**PresetLoader** (`preset-loader.ts`)
- Unified loading service for all preset types
- Loads from single directory: `configs/presets/`
- Uses single registry: `configs/presets/registry.json` (version 2.0)
- Type-discriminated validation routing
- Methods:
  - `loadPreset(presetId)` - Returns `LoadResult<Preset>` with type discrimination
  - `listPresets(filters?)` - Filters by atlasId, type, or viewMode
  - `loadMetadata(presetId)` - Lightweight metadata loading
  - `loadRegistry()` - Cached registry access
- Re-exports core converters (`convertToDefaults`, `extractTerritoryParameters`)

**PresetApplicationService** (`preset-application-service.ts`)
- Centralizes preset application logic using strategy pattern
- Routes by preset.type to specialized handlers
- Methods:
  - `applyPreset(preset)` - Unified entry point for all types
  - `applyCompositeCustom(config)` - Handles composite-custom presets
  - `applyUnified(config)` - Handles unified view presets
  - `applySplit(config)` - Handles split view presets
  - `applyCompositeExisting(config)` - Handles built-in-composite presets
- Returns `ApplicationResult` (success, errors, warnings)
- Coordinates updates across configStore and parameterStore

**AtlasMetadataService** (`atlas-metadata-service.ts`)
- Provides clean API for accessing atlas projection metadata
- Loads metadata from preset files using PresetLoader
- Caches metadata for performance
- Fallback defaults for atlases without presets
- Static methods: getAtlasMetadata(), getCompositeProjections(), getProjectionPreferences()

### Integration Components

**AtlasCoordinator** (`src/services/atlas/atlas-coordinator.ts`)
- Orchestrates preset loading during atlas initialization
- Integrates preset data into atlas configuration
- Coordinates parameter store and territory store initialization
- Returns extracted territory parameters for rendering

**Parameter Store** (`src/stores/parameters.ts`)
- Manages projection parameters (center, rotate, parallels, scaleMultiplier, etc.)
- Uses unified parameter system with familyConstraints as single source of truth
- Supports parameter inheritance (territory overrides global defaults)
- Provides effective parameter resolution for each territory
- Tracks parameter changes and triggers re-renders

**Config Store** (`src/stores/config.ts`)
- Coordinates preset loading and application
- Delegates to PresetLoader for loading
- Delegates to PresetApplicationService for applying
- Methods:
  - `loadAvailableViewPresets()` - Lists available presets for current atlas/view mode (filters out composite-custom)
  - `loadViewPreset(presetId)` - Loads and applies a preset
  - `applyViewPresetConfig(preset)` - Applies preset using PresetApplicationService
  - `clearViewPreset()` - Clears current preset

## Loading Paths

The preset system uses two distinct loading paths based on preset type and use case:

### Composite-Custom Presets (Converter-Based Path)

Loaded using converter-based initialization (two entry points):

**1. Atlas Initialization (Primary Path):**
- **Trigger:** App startup, atlas change
- **Entry Point:** `AtlasCoordinator.handleAtlasChange()`
- **Process:**
  1. `PresetLoader.loadPreset(defaultPreset)` - Load from registry
  2. `convertToDefaults()` - Extract projections, translations, scales
  3. `extractTerritoryParameters()` - Extract all projection parameters
  4. Apply to stores (parameterStore, configStore, uiStore)
  5. CompositeProjection.initialize() reads parameters

**2. Runtime Preset Switching (Secondary Path):**
- **Trigger:** User selects different composite-custom preset in PresetSelector dropdown
- **Entry Point:** `PresetSelector.vue` (composite-custom mode only)
- **Process:**
  1. `PresetLoader.loadPreset(presetId)` - Load from registry
  2. Type check: if `preset.type === 'composite-custom'`
  3. `convertToDefaults()` + `extractTerritoryParameters()` - Same as initialization
  4. Manual store updates (parameterStore, configStore)
  5. CompositeProjection uses updated parameters on next render

**Not available:** Through view preset API (`loadAvailableViewPresets()` filters out composite-custom)

**Why separate from view presets:** Requires converter-based extraction and full parameter initialization, not simple parameter setting

### View Presets (Runtime Switching Path)

Loaded through view preset API for runtime switching:
- **Trigger:** User preset selection in UI
- **Entry Point:** `configStore.loadViewPreset(presetId)`
- **Process:**
  1. `PresetLoader.loadPreset(presetId)` - Load from registry
  2. `PresetApplicationService.applyPreset()` - Route to type-specific handler
  3. Direct parameter application to stores
- **Supported Types:** unified, split, built-in-composite
- **Why separate:** Simple projection switching without full reinitialization

### Data Flow

#### Path A: Atlas Initialization (Composite-Custom)
```
Application Startup / Atlas Change
  ↓
useAtlasData.initialize()
  ↓
configStore.initializeWithPresetMetadata()
  ↓
AtlasCoordinator.handleAtlasChange()
  ↓
PresetLoader.loadPreset(defaultPreset)
  → Registry lookup (type: 'composite-custom')
  → validateCompositePreset() [Full validation]
  → Returns LoadResult<CompositePreset>
  ↓
convertToDefaults(preset.config)
  → Extract projections map
  → Extract translations map
  → Extract scales map
  ↓
extractTerritoryParameters(preset.config)
  → Extract projection parameters
  → Extract layout properties
  → Return per-territory params
  ↓
Apply to Stores
  → parameterStore (projections, translations, scales, parameters)
  → configStore (referenceScale, canvasDimensions)
  → uiStore (display options)
  ↓
geoDataStore.initialize()
  ↓
CompositeProjection.initialize()
  → Reads parameters via ProjectionParameterProvider
  → Applies to D3 projections
  ↓
First Render (preset values applied)
```

#### Path A2: Composite-Custom Runtime Switching
```
User Selects Different Composite Preset (PresetSelector dropdown)
  ↓
PresetSelector.vue (composite-custom mode)
  ↓
PresetLoader.loadPreset(presetId)
  → Registry lookup (type: 'composite-custom')
  → validateCompositePreset() [Full validation]
  → Returns LoadResult<CompositePreset>
  ↓
Type Check: preset.type === 'composite-custom'
  ↓
convertToDefaults(preset.config)
  → Extract projections, translations, scales
  ↓
extractTerritoryParameters(preset.config)
  → Extract parameters and layout properties
  ↓
Manual Store Updates
  → parameterStore.setTerritoryProjection()
  → parameterStore.setTerritoryTranslation()
  → parameterStore.setTerritoryParameter()
  → parameterStore.initializeFromPreset()
  → configStore.referenceScale
  → configStore.canvasDimensions
  ↓
Render Update (new preset applied, CompositeProjection uses updated parameters)
```

#### Path B: View Preset Switching (Unified/Split/Built-in-Composite)
```
User Selects View Preset (ViewPresetSelector dropdown)
  ↓
configStore.loadViewPreset(presetId)
  ↓
PresetLoader.loadPreset(presetId)
  → Registry lookup (type: 'unified'|'split'|'built-in-composite')
  → validateViewPreset() [Simple validation]
  → Returns LoadResult<UnifiedPreset|SplitPreset|CompositeExistingPreset>
  ↓
PresetApplicationService.applyPreset(preset)
  → Routes by preset.type
  → applyUnified() / applySplit() / applyCompositeExisting()
  → Direct parameter application
  ↓
Update Stores
  → parameterStore (projection parameters)
  → configStore (projection ID, composite projection ID)
  ↓
Render Update (new projection applied)
```

## Unified Registry Format

Single registry file at `configs/presets/registry.json` contains all preset types:

```json
{
  "version": "2.0",
  "description": "Unified registry of all preset types",
  "presets": [
    {
      "id": "france-default",
      "atlasId": "france",
      "type": "composite-custom",
      "name": "France - Configuration standard",
      "description": "...",
      "pattern": "single-focus",
      "territories": 10
    },
    {
      "id": "france-unified",
      "atlasId": "france",
      "type": "unified",
      "name": "France - Vue unifiée",
      "description": "Projection Natural Earth centrée sur la France"
    },
    {
      "id": "france-split",
      "atlasId": "france",
      "type": "split",
      "name": "France - Vue séparée",
      "description": "Même projection conique pour tous les territoires"
    }
  ]
}
```

## Registry Format

The unified registry (`configs/presets/registry.json` v2.0) lists all preset types:

```json
{
  "version": "2.0",
  "description": "Unified registry of all preset types (composite-custom, unified, split, built-in-composite)",
  "presets": [
    {
      "id": "france-default",
      "name": "France - Composite personnalisée par défaut",
      "atlasId": "france",
      "type": "composite-custom",
      "pattern": "single-focus",
      "territoryCount": 9,
      "description": "Configuration alignée avec geoConicConformalFrance"
    },
    {
      "id": "france-unified",
      "atlasId": "france",
      "type": "unified",
      "name": "France - Vue unifiée",
      "description": "Projection Natural Earth centrée sur la France"
    },
    {
      "id": "france-split",
      "atlasId": "france",
      "type": "split",
      "name": "France - Vue séparée",
      "description": "Même projection conique pour tous les territoires"
    }
  ]
}
```

**Registry Entry Fields:**
- `id` - Preset identifier (matches filename without extension)
- `name` - Display name (can be string or i18n object)
- `atlasId` - Target atlas
- `type` - Preset type discriminator ('composite-custom' | 'unified' | 'split' | 'built-in-composite')
- `description` - Optional description
- `pattern` - (composite-custom only) Composite pattern type
- `territoryCount` - (composite-custom only) Number of territories configured

## Preset File Formats

### Composite-Custom Format

```json
{
  "version": "1.0",
  "metadata": {
    "atlasId": "france",
    "atlasName": "France",
    "exportDate": "2025-10-16T16:00:00.000Z",
    "createdWith": "d3-composite-projections alignment"
  },
  "pattern": "single-focus",
  "referenceScale": 2700,
  "territories": [
    {
      "code": "FR-MET",
      "name": "France Métropolitaine",
      "role": "primary",
      "projection": {
        "id": "conic-conformal",
        "family": "CONIC",
        "parameters": {
          "rotate": [-3, -46.2, 0],
          "parallels": [0, 60],
          "scaleMultiplier": 1
        }
      },
      "layout": {
        "translateOffset": [0, 0],
        "pixelClipExtent": [-268.92, -245.16, 260.99, 324]
      },
      "bounds": [[-6.5, 41], [10, 51.5]]
    }
  ]
}
```

### Field Definitions

**Metadata**
- `version`: Preset format version ("1.0")
- `metadata.atlasId`: Target atlas identifier
- `metadata.atlasName`: Human-readable atlas name
- `metadata.exportDate`: ISO 8601 timestamp
- `metadata.createdWith`: Application/source identifier

**Composite Configuration**
- `pattern`: "single-focus" | "equal-members"
- `referenceScale`: Base scale for all territories (overrides atlas config)
- `canvasDimensions`: Optional {width, height} in pixels

**Territory Configuration**
- `code`: Territory ISO code
- `name`: Territory display name
- `role`: "primary" | "secondary"
- `projection.id`: Projection identifier from registry
- `projection.family`: Projection family (CONIC, CYLINDRICAL, AZIMUTHAL, etc.)
- `projection.parameters`: Parameter object

**Projection Parameters**
- `rotate`: [λ, φ, γ] - Three-element rotation array (required for most projections)
- `parallels`: [φ1, φ2] - Standard parallels for conic projections
- `center`: [longitude, latitude] - Center point for cylindrical/azimuthal
- `scaleMultiplier`: Scale factor applied to referenceScale (default: 1)

**Layout Properties**
- `translateOffset`: [x, y] - Pixel offset from computed position
- `pixelClipExtent`: [x1, y1, x2, y2] | null - Pixel-based clipping bounds

**Geographic Bounds**
- `bounds`: [[west, south], [east, north]] - Territory bounding box in degrees

## Parameter Extraction

### PresetLoader.extractTerritoryParameters()

Extracts projection parameters from preset territories into parameter store format.
Handles the standard preset structure where projection ID is at `projection.id` (not in parameters).

**Extracted Parameters:**
- `projectionId`: Extracted from `projection.id` (required parameter)
- `center`: Geographic center point
- `rotate`: Three-axis rotation
- `parallels`: Standard parallels for conic projections
- `baseScale`: Base scale value before multiplier
- `scaleMultiplier`: Scale adjustment multiplier
- `clipAngle`: Clipping angle for azimuthal projections
- `precision`: Adaptive sampling precision
- `translateOffset`: Extracted from `layout.translateOffset` - pixel offset [x, y]
- `pixelClipExtent`: Extracted from `layout.pixelClipExtent` - clipping rectangle [x1, y1, x2, y2]

**Extraction Process:**
1. Extract `projectionId` from `territory.projection.id` (standard location in preset format)
2. Filter projection parameters through registry exportable list
3. Extract layout properties (`translateOffset`, `pixelClipExtent`) from `layout` section
4. Return combined parameter object with all exportable parameters

**Parameter Validation:**
Only extracts parameters that are:
- Defined in the territory configuration
- Registered in the parameter registry as exportable
- Have non-undefined values

**Layout Property Extraction:**
- Reads `territory.layout.translateOffset` and converts to parameter format
- Reads `territory.layout.pixelClipExtent` (4-element array) and converts to parameter format
- Layout properties stored in parameter store for unified parameter management
- Enables slider controls and interactive editing (dragging, corner editing) to work from preset values

### PresetLoader.convertToDefaults()

Converts preset format to TerritoryDefaults format for store initialization.

**Returns:**
- `projections`: Map of territory code → projection ID
- `translations`: Map of territory code → {x, y} pixel offsets
- `scales`: Map of territory code → scale multiplier (for parameter store initialization)

**Translation Handling:**
Extracts `translateOffset` from preset layout and stores as x/y translation values.

**Scale Handling:**
Extracts `scaleMultiplier` for parameter store initialization. Scale multipliers are stored in parameter store, not territory store.

## Scale Management

The scale system has three interconnected values that work together:

### Scale Value Types

**1. baseScale** (from preset parameters)
- Base scale value before any multiplier applied
- Represents the "reference" scale for the territory
- Stored in CompositeProjection subprojection metadata
- Example: 3780 for Guadeloupe

**2. scaleMultiplier** (from preset parameters or parameter store)
- Adjustment factor applied to baseScale
- Range: typically 0.5 - 2.0 (50% to 200%)
- Modified by "advanced parameters" scale slider (Échelle: 1.20×)
- Stored in parameter store (single source of truth)
- Example: 1.4 for Guadeloupe

**3. scale** (calculated or from parameter store)
- Final scale value applied to D3 projection
- Calculated as: `scale = baseScale × scaleMultiplier`
- Can be overridden by "view parameters" scale slider (Scale: 100-10000)
- Example: 3780 × 1.4 = 5292 for Guadeloupe

### Scale Application Flow

**Initialization (from preset):**
```
Preset provides:
  baseScale: 3780
  scaleMultiplier: 1.4
  scale: 5292 (= 3780 × 1.4)

CompositeProjection.initialize():
  1. Extracts baseScale and scaleMultiplier from params
  2. Applies: projection.scale(baseScale × scaleMultiplier)
  3. Stores both values in subprojection metadata
```

**User Changes Advanced Scale Slider (scaleMultiplier):**
```
User moves slider to 1.6×

updateScale(territoryCode, 1.6):
  1. Checks if scale parameter differs from baseScale × scaleMultiplier
  2. If not overridden: updates scaleMultiplier to 1.6
  3. Applies: projection.scale(baseScale × 1.6) = 6048
  4. Updates scale parameter to match: paramStore.setTerritoryParameter('scale', 6048)
  5. Keeps baseScale and scaleMultiplier in sync
```

**User Changes View Parameters Scale Slider (absolute scale):**
```
User moves slider to 8000

updateTerritoryParameters(territoryCode):
  1. Reads params.scale = 8000 from parameter store
  2. Applies: projection.scale(8000)
  3. Does NOT modify baseScale or scaleMultiplier
  4. Future scaleMultiplier updates blocked (8000 ≠ 3780 × 1.4)
```

### Scale Override Detection

**updateScale() logic:**
```typescript
const expectedScale = subProj.baseScale * subProj.scaleMultiplier
if (params.scale !== undefined && Math.abs(params.scale - expectedScale) > 0.1) {
  // User has overridden scale parameter - don't overwrite with multiplier
  return
}
// Otherwise: allow multiplier to update scale
```

**updateTerritoryParameters() logic:**
```typescript
if (params.scale !== undefined) {
  // User set scale parameter directly - use it
  correctScale = params.scale
} else {
  // Use calculated scale from baseScale × scaleMultiplier
  correctScale = subProj.baseScale * subProj.scaleMultiplier
}
projection.scale(correctScale)
```

### Scale Slider Behaviors

**Advanced Parameters Scale Slider** (Échelle: 0.5× - 2.0×)
- Modifies `scaleMultiplier` in parameter store
- Updates CompositeProjection via parameter provider
- Recalculates and syncs `scale` parameter to match
- Blocked if user has overridden scale parameter directly
- Used for relative adjustments to preset baseline

**View Parameters Scale Slider** (Scale: 100-10000)
- Sets `scale` parameter directly in parameter store
- Overrides calculated scale (baseScale × scaleMultiplier)
- Blocks future scaleMultiplier updates for that territory
- Used for absolute scale values independent of preset

## Projection Parameter Handling

### Parameter Types

**Center vs Rotate:**
- **Cylindrical/Azimuthal projections** (mercator, stereographic): Use `center` for positioning
- **Conic projections** (conic-conformal, albers): Use `rotate` for positioning

**CompositeProjection.initialize() applies parameters by projection type:**
```typescript
const isConicProjection = projectionType.includes('conic') || projectionType.includes('albers')

if (isConicProjection && projection.rotate && params.rotate) {
  projection.rotate(params.rotate)  // For conic: use rotate
} else if (params.center) {
  projection.center(params.center)   // For cylindrical: use center
} else if (projection.rotate && params.rotate) {
  projection.rotate(params.rotate)   // Fallback to rotate
}
```

### Parameter Provider Pattern

CompositeProjection receives parameters through ProjectionParameterProvider interface:
- Abstracts parameter source (parameter store, config, or defaults)
- Provides `getEffectiveParameters(territoryCode)` for parameter resolution
- Supports parameter inheritance (territory → global → default)

**getParametersForTerritory()** merges config and dynamic parameters:
```typescript
private getParametersForTerritory(territoryCode: string, configParams: TerritoryConfig) {
  if (this.parameterProvider) {
    const dynamicParams = this.parameterProvider.getEffectiveParameters(territoryCode)
    return {
      center: dynamicParams.center ?? configParams.center,
      rotate: dynamicParams.rotate ?? configParams.rotate,
      parallels: dynamicParams.parallels ?? configParams.parallels,
      scale: dynamicParams.scale,
      baseScale: dynamicParams.baseScale,
      scaleMultiplier: dynamicParams.scaleMultiplier,
      // ... other parameters
    }
  }
  // Fallback to config params
}
```

### Parameter Updates

**updateTerritoryParameters()** applies parameter changes:
1. Reads updated parameters from parameter provider
2. Applies center/rotate based on projection type
3. Applies parallels if supported
4. Re-applies scale (respects parameter overrides)
5. Applies precision if supported
6. Forces composite projection rebuild

**Parameter change flow:**
```
User changes parameter slider
  ↓
handleParameterChange() in TerritoryParameterControls
  ↓
parameterStore.setTerritoryParameter(code, key, value)
  ↓
emit('parameterChanged', code, key, value)
  ↓
handleParameterChange() in TerritoryControls
  ↓
cartographer.updateTerritoryParameters(code)
  ↓
compositeProjection.updateTerritoryParameters(code)
  → Reads latest parameters
  → Applies to D3 projection
  → Sets compositeProjection = null (force rebuild)
  ↓
Next render: build() uses updated projection
```

## Initialization Sequence

### Race Condition Prevention

The initialization sequence prevents race conditions where CompositeProjection initializes before preset parameters load:

**Problem:** Without proper sequencing, territories render with default parameters before preset loads, causing incorrect initial scales and positions.

**Solution:** `useAtlasData.initialize()` awaits preset loading:
```typescript
async function initialize() {
  const configStore = useConfigStore()
  const geoDataStore = useGeoDataStore()

  // CRITICAL: Wait for preset metadata to load before initializing geodata
  // This ensures territory projections from presets are available before first render
  if (typeof configStore.initializeWithPresetMetadata === 'function') {
    await configStore.initializeWithPresetMetadata()
  }

  // Now initialize geodata with preset parameters available
  if (!geoDataStore.isInitialized) {
    await geoDataStore.initialize()
  }
}
```

### Reentrant Initialization Guard

`initializeWithPresetMetadata()` uses promise guard to prevent multiple simultaneous loads:
```typescript
let initializationPromise: Promise<void> | null = null

const initializeWithPresetMetadata = async () => {
  // If already initializing, return the existing promise
  if (initializationPromise) {
    return initializationPromise
  }

  // Create and store the initialization promise
  initializationPromise = (async () => {
    // Load preset and apply to stores
  })()

  return initializationPromise
}
```

### Store Application Order

Preset data applies to stores in this order:
1. **Territory projections** - Sets projection type per territory
2. **Territory translations** - Sets x/y pixel offsets
3. **Parameter store scales** - Sets scaleMultiplier via `setTerritoryParameter(code, 'scaleMultiplier', value)`
4. **Parameter store parameters** - Sets projection parameters (center, rotate, parallels, scale, baseScale, scaleMultiplier)

## Rendering Integration

### CompositeProjection Initialization

During `CompositeProjection.initialize()`:
1. Iterates through territories (mainland + overseas)
2. Calls `getParametersForTerritory()` to merge preset parameters
3. Applies projection type (creates D3 projection)
4. Applies positioning parameters (center or rotate)
5. Applies scale: `projection.scale(baseScale × scaleMultiplier)`
6. Stores projection with metadata in `subProjections` array

### Build-time Processing

During `CompositeProjection.build(width, height)`:
1. Calculates map center from viewport dimensions
2. Applies translation offsets to each territory projection
3. Reads translate parameter from parameter store if set
4. Combines territory offset + parameter translate + viewport center
5. Applies final translate to D3 projection: `projection.translate([x, y])`
6. Applies clip extents if defined in preset
7. Returns composite projection function for Observable Plot

### Cartographer Coordination

`CartographerService.renderCustomComposite()`:
1. Receives custom composite settings from territory store
2. Calls `applyCustomCompositeSettings()` to apply territory-specific overrides
3. Creates projection function: `({ width, height }) => composite.build(width, height)`
4. Passes projection function to Observable Plot
5. Plot calls projection function with actual viewport dimensions
6. CompositeProjection builds and returns multi-territory projection

## Parameter Validation

### Constraint System

Parameter constraints define valid ranges and relevance per projection family:
- Defined in parameter registry (`src/core/parameters/parameter-registry.ts`)
- Includes all exportable parameters: center, rotate, parallels, scaleMultiplier, translateOffset, clipAngle, precision, pixelClipExtent, projectionId
- Provides constraints for all 4 projection families (CONIC, AZIMUTHAL, CYLINDRICAL, PSEUDOCYLINDRICAL)

### Validation Flow

Parameter validation occurs at multiple points:
1. **User input** - Before setting parameter in parameter store
2. **Parameter store** - When calling `setTerritoryParameter()`
3. **Territory controls** - Real-time validation feedback in UI
4. **Preset loading** - Validates preset structure and required parameters

### Preset Validation

When loading presets, validation checks:
1. **Structural validation** - Via CompositeImportService for JSON structure
2. **Required parameters** - Via parameter registry for each territory
   - `projectionId` - Checked at `projection.id` (not in parameters)
   - `translateOffset` - Checked in `layout` section
   - Other required parameters - Checked in `projection.parameters`
3. **Parameter relevance** - Only validates parameters relevant to projection family
4. **Value validation** - Validates parameter values against constraints

## Export System Integration

### Preset Generation

When exporting composite projection configuration:
1. Gets all exportable parameters from parameter provider
2. Separates projection parameters from layout parameters
3. Serializes complete projection configuration with metadata
4. Generates JSON preset file in standard format
5. Stores in `configs/presets/{atlasId}-{presetName}.json`

### Export Format

Exported presets follow standard structure:
- `projection.id` - Projection identifier (e.g., 'conic-conformal')
- `projection.family` - Projection family (e.g., 'CONIC')
- `projection.parameters` - All projection-specific parameters
- `layout.translateOffset` - Territory position offset [x, y]
- `layout.pixelClipExtent` - Optional clipping extent [x1, y1, x2, y2]
- `bounds` - Geographic bounds for each territory
- `metadata` - Export date, creator, version, notes

## Troubleshooting

### Common Issues

**Territories render at incorrect scale on load:**
- Verify preset has `baseScale` and `scaleMultiplier` defined
- Check `PresetLoader.extractTerritoryParameters()` extracts both values
- Ensure `CompositeProjection.getParametersForTerritory()` includes baseScale and scaleMultiplier
- Verify `initializeWithPresetMetadata()` completes before `geoDataStore.initialize()`

**Scale sliders not working:**
- Advanced slider: Check if scale parameter override exists (blocks multiplier updates)
- View parameters slider: Verify `updateTerritoryParameters()` respects params.scale
- Both: Ensure `compositeProjection = null` triggers rebuild after changes

**Mainland uses wrong projection type:**
- Verify preset projection type matches expected value
- Check `configStore.initializeWithPresetMetadata()` applies projections to territory store
- Ensure `cartographer.applyCustomCompositeSettings()` doesn't override projection unnecessarily

**Overseas territories positioned incorrectly:**
- Verify projection uses correct positioning method (center vs rotate)
- Check `isConicProjection` logic in initialization
- Ensure cylindrical projections use `.center()` not `.rotate()`
- Verify `translateOffset` values are appropriate for scale

**Parameters not loading from preset:**
- Check `parameterStore.setTerritoryParameters()` receives extracted parameters
- Verify parameter provider returns correct effective parameters
- Ensure no race condition (preset loads after first render)
- Verify `cartographer.updateTerritoryParameters()` called for each territory after parameter store update

## Manual Preset Loading

### PresetSelector Component

The `PresetSelector` component (`src/components/ui/presets/PresetSelector.vue`) provides UI for manually loading different presets in composite-custom mode.

**Functionality:**
- Displays dropdown with available presets for current atlas
- Loads preset metadata asynchronously for dropdown labels
- Applies selected preset to stores and CompositeProjection
- Applies global parameters (referenceScale, canvasDimensions) to configStore
- Handles loading states and error display

**Preset Application Flow:**
```typescript
async function loadPreset(presetId: string) {
  // 1. Load and validate preset file
  const result = await PresetLoader.loadPreset(presetId)

  // 2. Convert to internal formats
  const defaults = PresetLoader.convertToDefaults(result.preset)
  const territoryParameters = PresetLoader.extractTerritoryParameters(result.preset)

  // 3. Apply global parameters to configStore
  if (result.preset.referenceScale !== undefined) {
    configStore.referenceScale = result.preset.referenceScale
  }
  if (result.preset.canvasDimensions) {
    configStore.canvasDimensions = {
      width: result.preset.canvasDimensions.width,
      height: result.preset.canvasDimensions.height
    }
  }

  // 4. Clear existing parameter overrides
  allCurrentTerritoryCodes.forEach(code => {
    parameterStore.clearAllTerritoryOverrides(code)
  })

  // 5. Apply preset to stores
  parameterStore.initializeFromPreset({}, parametersWithoutScale)
  territoryStore.setTerritoryProjection(code, projection)
  territoryStore.setTerritoryTranslation(code, axis, value)
  parameterStore.setTerritoryParameter(code, 'scaleMultiplier', scale)

  // 6. CRITICAL: Update CompositeProjection with new parameters
  Object.keys(parametersWithoutScale).forEach(territoryCode => {
    cartographer.updateTerritoryParameters(territoryCode)
  })
}
```

**Key Integration Points:**
- **Parameter Store Update**: Uses `initializeFromPreset()` to apply extracted parameters
- **CompositeProjection Sync**: Calls `updateTerritoryParameters()` for each territory to re-read parameters from parameter store
- **Scale Parameter Filtering**: Excludes computed `scale` parameter to prevent conflicts with `baseScale × scaleMultiplier` calculation
- **Store Coordination**: Updates territory store (projections, translations) and parameter store (scaleMultiplier, other parameters) simultaneously

**Critical Fix**: Manual preset loading requires explicit CompositeProjection update after parameter store changes. Without calling `updateTerritoryParameters()`, the CompositeProjection continues using previous parameter values despite the parameter store being updated correctly.

## Reset System

### Reset to Preset Defaults

The reset system restores territories to their preset configuration, managed through `useTerritoryTransforms()` composable.

**Global Reset** (`resetTransforms()`)
- Restores all territories to preset defaults (projections, translations, scales, parameters)
- Checks all territories via `configStore.atlasService.getAllTerritories()` including mainland
- Clears parameter overrides for all territories
- Applies preset projections, translations, scales, and parameters to stores
- Triggers cartographer updates for all territories via `updateTerritoryParameters()`
- Falls back to hardcoded defaults if no preset available

**Territory-Specific Reset** (`resetTerritoryToDefaults()`)
- Restores single territory to its preset configuration
- Clears all parameter overrides for that territory
- Applies preset values (projection, translation, scale, parameters)
- Triggers cartographer update for the specific territory
- Falls back to default values (projection unchanged, translation [0,0], scale 1.0)

**Reset Divergence Detection**
- Global reset button enables when any territory diverges from preset
- Uses `usePresetDefaults().hasDivergingParameters()` to detect changes
- Checks all territories including mainland via `getAllTerritories()`
- Compares current state (projections, translations, scales, parameters) against preset defaults
- Territory-specific reset buttons enable when individual territory has overrides

**Cartographer Integration**
- Reset operations call `cartographer.updateTerritoryParameters(code)` for each modified territory
- Updates trigger projection rebuild via `compositeProjection = null`
- Ensures visual changes reflect immediately after reset

## File References

**Core Services:**
- `src/services/presets/preset-loader.ts` - Preset loading and extraction
- `src/services/atlas/atlas-coordinator.ts` - Preset orchestration
- `src/services/projection/composite-projection.ts` - Projection initialization and updates

**State Management:**
- `src/stores/config.ts` - Preset metadata initialization
- `src/stores/parameters.ts` - Projection parameter management (including scale multipliers)
- `src/stores/territory.ts` - Territory state (projections, translations)

**UI Components:**
- `src/components/TerritoryControls.vue` - Main territory control container with global reset
- `src/components/ui/parameters/TerritoryParameterControls.vue` - Territory-specific parameter controls and reset
- `src/components/ui/presets/PresetSelector.vue` - Preset selection UI

**Composables:**
- `src/composables/useTerritoryTransforms.ts` - Reset functionality and territory transform management
- `src/composables/usePresetDefaults.ts` - Preset defaults tracking and divergence detection
- `src/composables/useAtlasData.ts` - Atlas data initialization with preset sequencing

**Validation:**
- `src/core/parameters/parameter-registry.ts` - Unified parameter validation and constraints (replaces parameter-constraints.ts)

**Preset Files:**
- `configs/presets/{atlasId}-{presetName}.json` - Saved preset configurations for all types (unified location)

## Architectural Improvements (Phase 2 Unification)

### Unified Architecture Benefits

**Single Source of Truth**
- One registry file (`configs/presets/registry.json`) for all preset types
- Single directory (`configs/presets/`) contains all preset files
- Unified `PresetLoader` handles all preset types with type-aware routing
- Discriminated union `Preset` type provides type safety across all operations

**Type Safety**
- `PresetType` discriminator ('composite-custom' | 'unified' | 'split' | 'built-in-composite')
- `LoadResult<T>` generic pattern for consistent error handling
- TypeScript narrows types based on preset.type discriminator
- Compile-time guarantees prevent type mismatches

**Code Reduction**
- Eliminated duplicate loader logic (ViewPresetLoader merged into PresetLoader)
- Removed redundant validation code through unified `validatePreset()` with strategy pattern
- Centralized application logic in `PresetApplicationService`
- Simplified config store by delegating to services

**Extensibility**
- Adding new preset types requires:
  1. Add type to `PresetType` union
  2. Add interface to `Preset` discriminated union
  3. Add validator case to `validatePreset()`
  4. Add application handler to `PresetApplicationService`
- No changes needed to loader, registry, or UI components

### Migration Notes

**Removed Files**
- `src/services/presets/view-preset-loader.ts` - Merged into PresetLoader
- `configs/view-presets/registry.json` - Merged into configs/presets/registry.json
- `configs/view-presets/*.json` - Moved to configs/presets/

**Breaking Changes**
- Config store methods removed: `applyUnifiedPreset()`, `applySplitPreset()`, `applyCompositeExistingPreset()`
- All preset application now goes through `applyViewPresetConfig()` → `PresetApplicationService.applyPreset()`
- Registry structure changed: added `type` discriminator field, simplified name/description to strings

**API Updates**
- `PresetLoader.listPresets(filters)` replaces separate `listAvailablePresets()` and `getAvailablePresets()`
- `PresetLoader.loadMetadata()` replaces `loadPresetMetadata()`
- Filter by `viewMode` now equivalent to filtering by `type` for view presets

