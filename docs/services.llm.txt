# Service Layer Architecture

## Overview
The service layer contains business logic extracted from Vue components and Pinia stores.
Services are organized by concern into subdirectories: atlas/, data/, projection/, rendering/, export/.
Services follow two main patterns: instance-based (for stateful operations) and static (for pure functions).

## Service Patterns

### Instance-Based Pattern
Used when service maintains state, requires initialization, or represents domain objects.

**Characteristics**:
- Has private state (properties)
- Requires instantiation with `new`
- May have complex initialization
- Often caches data or configuration

**Use Cases**:
- Service holds configuration or loaded data
- Service coordinates multiple stateful dependencies
- Service represents a domain object with behavior
- Multiple instances with different configurations needed

**Examples**: GeoDataService (caching), CompositeProjection (domain object), Cartographer (orchestrator)

### Static Pattern
Used when service provides pure transformations, utility functions, or stateless orchestration.

**Characteristics**:
- No instance state
- All methods are static
- Pure functions or stateless coordinators
- Testable without instantiation

**Use Cases**:
- Pure data transformations
- Stateless business rule evaluation
- Orchestration of other services
- Utility calculations
- Factory with singleton caching

**Examples**: TerritoryFilterService (pure functions), AtlasCoordinator (orchestration), MapOverlayService (utilities)

### Pattern Decision Guide
- **Need state?** → Instance pattern
- **Pure function?** → Static pattern
- **Orchestration without state?** → Static pattern
- **Domain object with behavior?** → Instance pattern
- **Factory with caching?** → Static pattern with instance cache
- **Strategy pattern?** → Instance strategies with static coordinator

## Atlas Services (src/services/atlas/)

### AtlasPatternService
Pattern detection and behavioral decisions for different atlas types.
- `isSingleFocus()` - Check if atlas has single mainland
- `isEqualMembers()` - Check if atlas has equal member states
- `supportsSplitView()` - Check if split view is supported
- `getDefaultViewMode()` - Get recommended view mode
- `getPrimaryTerritoryRole()` - Determine mainland vs member role

### AtlasCoordinator
Orchestrates atlas changes and configuration updates.
- `handleAtlasChange()` - Coordinate all updates when changing atlas (always uses atlas's default view mode)
- `getInitialConfiguration()` - Build initial config for atlas

### TerritoryDefaultsService
Initialize territory projections, translations, and scales.
- `initializeAll()` - Initialize all territory defaults
- `mergeCustomConfig()` - Merge custom configuration

### AtlasService
Atlas-aware facade for accessing territory data and configuration.
Instance-based service providing unified API for components.
- `getTerritories()` - Get filtered/grouped territories
- `getTerritoryModes()` - Get available display modes
- `getTerritoryGroups()` - Get territory groupings
- `getProjectionParams()` - Get projection parameters

## Data Services (src/services/data/)

### TerritoryDataLoader
Strategy pattern for loading territory data based on atlas pattern.
- `loadTerritoryData()` - Load data using appropriate strategy
Strategies: SingleFocusLoadStrategy, EqualMembersLoadStrategy

### TerritoryFilterService
Filter and group territories based on display modes.
- `filterTerritories()` - Filter territories by mode
- `groupByRegion()` - Group territories by region

### GeoDataService
Geographic data loading and processing from TopoJSON sources.
Instance-based service managing territory data cache.
- `loadData()` - Load TopoJSON and metadata
- `getAllTerritoriesGeoData()` - Get all territory data
- `getTerritoriesGeoData()` - Get filtered territory data
- `getTerritoryInfo()` - Get territory metadata
- `calculateBounds()` - Calculate geographic bounds

## Projection Services (src/services/projection/)

### ProjectionUIService
Projection grouping and UI visibility logic.
- `getProjectionGroups()` - Group projections by category
- `shouldShowProjectionSelector()` - Visibility for projection selector
- `shouldShowProjectionModeSelector()` - Visibility for mode selector
- `shouldShowCompositeProjectionSelector()` - Visibility for composite selector

### ProjectionService
Projection creation and management using factory/registry pattern.
Instance-based service with region-specific parameters.
- `setProjectionParams()` - Set region parameters
- `getProjection()` - Create projection using factory
- `getAvailableProjections()` - Get filtered projections
- `groupProjectionsByCategory()` - Group projections
- `recommendProjection()` - Get projection recommendation

### CompositeProjection
Custom composite projection with manual territory positioning.
Instance-based service managing sub-projections.
- `initialize()` - Initialize sub-projections
- `setTerritoryProjection()` - Change territory projection
- `setTerritoryTranslation()` - Set territory position
- `setTerritoryScale()` - Set territory scale
- `getProjection()` - Get composite projection function
- `rebuild()` - Rebuild composite projection

## Export/Import Services (src/services/export/)

### CompositeExportService
Orchestrates export of composite projection configurations.
Static methods for configuration serialization and code generation.

**Export Methods**:
- `exportToJSON()` - Serialize projection to ExportedCompositeConfig
- `generateCode()` - Generate code using CodeGenerator
- `validateExportedConfig()` - Validate exported configuration

**Configuration Format**:
- `version` - Schema version (currently '1.0')
- `metadata` - Atlas info, export date, creator
- `pattern` - Atlas pattern (single-focus/equal-members)
- `referenceScale` - Base scale for all territories
- `territories[]` - Array of territory configurations
  - `code, name, role` - Territory identification
  - `projectionId, projectionFamily` - Projection info
  - `parameters` - All projection parameters (center, rotate, parallels, scale, scaleMultiplier)
  - `layout` - Territory positioning (translateOffset, clipExtent)
  - `bounds` - Geographic bounds [[minLon, minLat], [maxLon, maxLat]]

### CompositeImportService
Re-imports exported configurations with validation, automatic version migration, and type safety.
Static methods for JSON parsing and store application.

**Import Methods**:
- `importFromJSON()` - Parse, migrate (if needed), and validate JSON string
- `importFromFile()` - Import from File object (browser File API)
- `checkAtlasCompatibility()` - Check atlas ID compatibility
- `applyToStores()` - Apply configuration to stores (type-safe)

**Import Flow**:
1. Parse JSON string
2. Check version and migrate automatically if needed (via ConfigMigrator)
3. Validate structure (required fields, data types)
4. Check atlas compatibility
5. Return `{ success, config?, errors[], warnings[], migrated?, fromVersion? }`

**Application Flow**:
1. Apply projection to each territory via CompositeProjection service
2. Apply scale multiplier to territory store
3. Apply translation offset to territory store
4. Maintain state consistency

**Type Safety**:
- Replaced all `any` types with proper store types

### ConfigMigrator
Handles automatic migration of exported configurations between schema versions.
Static methods for version detection, migration chain execution, and validation.

**Current Version**: `1.0`

**Migration Methods**:
- `needsMigration()` - Check if config needs migration to current version
- `canMigrate()` - Check if migration is possible (version supported)
- `migrateToCurrentVersion()` - Execute migration chain
- `isCurrentVersion()` - Check if config is already current version
- `compareVersions()` - Compare two version strings

**Migration Architecture**:
- Plugin-based chain (v1.0 → v1.1 → v1.2)
- Pure functions with no side effects
- Automatic integration in import flow
- Detailed logging with messages, errors, warnings

**Adding New Versions**:
Add migration function and update chain in `performMigrationChain()`
- Uses `ReturnType<typeof useConfigStore>` pattern
- Proper CompositeProjection API: `updateTerritoryProjection()`
- Store methods: `setTerritoryProjection`, `setTerritoryScale`, `setTerritoryTranslation`

### CodeGenerator
Generates ready-to-use code in multiple formats.
Static methods for D3.js (JS/TS) and Observable Plot code generation.

**Code Formats**:
- D3 JavaScript - Standalone projection function
- D3 TypeScript - With full type annotations
- Observable Plot - Plot-compatible projection

**Generated Code Pattern**:
```javascript
import { geoConicConformal } from 'd3-geo'
import { loadCompositeProjection, registerProjection } from '@atlas-composer/projection-loader'

export function create[Atlas]Projection() {
  registerProjection('projection-id', () => geoProjectionFunction())
  const config = { /* embedded JSON */ }
  return loadCompositeProjection(config, { width: 800, height: 600 })
}
```

**Features**:
- Uses `@atlas-composer/projection-loader` NPM package
- Embeds full configuration as JSON
- Includes usage examples (optional)
- Includes header comments with metadata
- Number precision: 6 decimals for all coordinates

### StandaloneProjectionLoader
Core loader implementation (copied to NPM package).
Zero-dependency module for loading exported configurations.

**Features**:
- Plugin architecture - users register projection factories
- Stream multiplexing for routing geometry to sub-projections
- D3 stream protocol compliance
- Geographic bounds-based routing

**Public API**:
- `loadCompositeProjection(config, options)` - Main loader function
- `registerProjection(id, factory)` - Register projection factory
- `clearProjections()` - Clear all registered projections

## Rendering Services (src/services/rendering/)

### MapSizeCalculator
Calculate map dimensions with configurable defaults.
- `calculateSize()` - Calculate map size
- `calculateProportionalSize()` - Calculate proportional size

### MapOverlayService
Render map overlays (composition borders and map limits) using D3 selection API.
Static methods for SVG overlay rendering:
- `applyOverlays()` - Apply overlays to rendered SVG map
- `computeSceneBBox()` - Compute viewport-based bounding box with insets
- `boundsToRect()` - Convert projection bounds to SVG rectangle
- `unionRect()` - Compute union of rectangles for accumulated bounds
- `createCompositeBorderPath()` - Create border path for composite projections
- `appendRectOverlay()` - Append dashed rectangle overlay to SVG

Overlay Features:
- **Composition Borders**: Dashed borders around territory regions (dash: 8 4, width: 1.25)
- **Map Limits**: Dashed border around entire rendered content (dash: 4 3, width: 1.5)
- Viewport-based bounds calculation using SVG dimensions and insets
- Inset handling: 20px for composite maps, 0px for individual territory maps
- Automatic overlay group management (removes empty groups)

### CompositeSettingsBuilder
Build custom composite settings from configuration.
- `extractTerritoryCodes()` - Extract territory codes from config
- `buildTerritoryProjections()` - Build projections map
- `buildSettings()` - Build complete settings

### MapRenderCoordinator
Coordinate map rendering by building options and orchestrating services.
- `renderSimpleMap()` - Render simple territory map
- `renderCompositeMap()` - Render composite map
- `applyOverlays()` - Apply overlays to rendered map

### BorderRenderer
Border rendering strategies for different modes.
Classes: CustomCompositeBorderRenderer, ExistingCompositeBorderRenderer
Currently deferred integration, not fully used.

### CartographerService
Main rendering coordinator with unified API.
Instance-based service orchestrating projection, geo-data, and rendering.
- `render()` - Unified rendering API (simple/composite modes)
- `renderSimple()` - Simple projection rendering
- `renderCustomComposite()` - Custom composite rendering
- `renderProjectionComposite()` - Projection-based composite
- `createPlot()` - Common Plot creation logic

### CartographerFactory
Factory for creating region-specific Cartographer instances.
Static factory pattern with instance caching.
- `create()` - Create or retrieve cached Cartographer
- `getInstance()` - Get cached instance

## Export Services (src/services/export/)

### CompositeExportService
Export composite projection configurations to JSON format.
Static methods for configuration serialization:
- `exportToJSON()` - Serialize CompositeProjection to ExportedCompositeConfig
- `validateExportedConfig()` - Validate exported configuration structure
- `exportToFile()` - Create downloadable JSON file
- Applies rounding to all numeric values (6 decimal places)
- Includes metadata (atlasId, exportDate, version)
- Exports territories with projection parameters, layout, and bounds

### CompositeImportService  
Import and restore composite projection configurations from JSON.
Static methods for configuration import:
- `importFromJSON()` - Parse and validate JSON string
- `importFromFile()` - Handle File API objects
- `checkAtlasCompatibility()` - Validate atlas ID matching
- `applyToStores()` - Apply imported config to stores and CompositeProjection
- Validates required fields and data integrity
- Warns if atlas mismatch but allows import

### CodeGenerator
Generate standalone executable code from exported configurations.
Supports multiple formats and languages:
- `generate()` - Main entry point with format/language options
- `generateD3JavaScript()` - D3.js JavaScript code with registration
- `generateD3TypeScript()` - D3.js TypeScript code with type annotations
- `generatePlotCode()` - Observable Plot code with registration
- Implements D3 stream protocol with state machine for geometry routing
- Geographic bounds-based stream multiplexing
- Applies number rounding for floating-point precision (6 decimals)
- Generated code includes projection registration examples (80-92% shorter)

See docs/export.llm.txt for detailed D3 stream protocol implementation.

### Standalone Projection Loader (standalone-projection-loader.ts)
Pure JavaScript/TypeScript module for loading exported configurations.
Zero-dependency plugin architecture - users register projections at runtime.

Registration API:
- `registerProjection(id, factory)` - Register single projection
- `registerProjections(factories)` - Bulk registration
- `unregisterProjection(id)` - Remove projection
- `clearProjections()` - Clear all registrations
- `getRegisteredProjections()` - Query registry
- `isProjectionRegistered(id)` - Check registration

Loading API:
- `loadCompositeProjection(config, options)` - Create projection from config
- `validateConfig(config)` - Validate configuration structure

Features:
- Zero dependencies (no d3-geo imports)
- Plugin architecture with runtime registry
- Self-contained TypeScript types (ProjectionLike, ProjectionFactory, StreamLike)
- D3 stream multiplexing for geometry routing
- Geographic bounds-based territory selection
- Debug mode for logging territory selection
- Supports any projection (D3, Proj4, custom)
- Tree-shakeable imports
- Bundle size: ~6KB (vs 100KB with bundled dependencies)

Optional D3 Helpers (d3-projection-helpers.ts):
- Pre-configured D3 projection factories
- Tree-shakeable individual exports
- Bulk registration helper
- Keeps D3 dependencies separate from main loader
Usage: Standalone D3 projects, Observable notebooks, Node.js rendering

## Design Patterns

### Static Methods
Export/import services use static methods for:
- Testability without Vue context
- Functional programming style
- No state management in services

### Instance-Based Services
Existing services use instance pattern for:
- Stateful operations (caching, configuration)
- Complex initialization requirements
- Legacy compatibility

### Strategy Pattern
TerritoryDataLoader uses strategies for pattern-specific loading logic.

### Coordinator Pattern
AtlasCoordinator and MapRenderCoordinator orchestrate complex multi-step operations.

### Facade Pattern
AtlasService provides simplified API hiding complexity from components.

### Factory Pattern
CartographerFactory and ProjectionFactory create configured instances.

## Usage Guidelines

1. Import services from organized subdirectories
2. Use static methods for stateless operations
3. Use instance methods for stateful operations
4. Services handle business logic, not presentation
5. Components coordinate service calls
6. Stores use services for complex operations
7. Keep services focused on single responsibility

## Benefits

- Clear separation of concerns by domain
- Testable without Vue dependencies
- Reusable across components
- Consistent patterns and conventions
- Easy to navigate and discover
- Reduced component complexity
