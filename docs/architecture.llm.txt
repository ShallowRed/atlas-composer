# Atlas composer - Architecture Overview

## Purpose
Interactive web application for creating custom cartographic visualizations of countries with geographically-scattered territories using composite projections.

## Technology Stack
- Frontend: Vue.js 3 + TypeScript + Vite
- Mapping: D3.js + Observable Plot
- State: Pinia stores
- Styling: Tailwind CSS + DaisyUI 5
- Data: Natural Earth GeoJSON

## Core Concepts

### 1. Atlas System
Domain: Configuration-driven atlas definitions
File: docs/atlases.llm.txt
- JSON-based atlas configurations (configs/*.json)
- Atlas registry and loader
- Territory composition rules
- View modes (composite, split, unified)

### 2. Projection System
Domain: Map projection management
File: docs/projections.llm.txt
- Projection definitions and families (20+ projections)
- Parameter configuration and application
- Projection registry with recommendation engine
- Projection factory and D3/Observable Plot integration

### 3. Service Layer
Domain: Business logic and rendering
File: docs/services.llm.txt
- AtlasService: Configuration management
- ProjectionService: Projection creation
- CartographerService: Rendering coordination
- DataLoaderService: GeoJSON data loading
- TerritoryDataService: Territory positioning

### 4. Vue Layer
Domain: User interface and interaction
File: docs/vue-architecture.llm.txt
- Vue 3 components with Composition API (16 components)
- Pinia stores for state management (3 stores: config, geoData, ui/territory)
- Composables for reusable logic (9 composables)
- Component hierarchy and data flow
- Comprehensive type safety (370 lines of types)
- Test coverage (122 tests, 100% passing)

### 5. Export System
Domain: Code generation for composite projections
File: docs/export.llm.txt
- Configuration serialization
- D3.js code generation (JavaScript/TypeScript)
- Observable Plot code generation
- D3 stream protocol implementation
- Geographic bounds routing and stream multiplexing

### 6. Build System
Domain: Data preparation and validation
File: docs/scripts.llm.txt
- prepare-geodata.ts: Natural Earth processing
- validate-configs.ts: Schema validation
- Development utilities

## Project Structure

```
src/
├── App.vue             # Root component
├── main.ts             # Application entry
├── router/             # Vue Router configuration
├── views/              # Page components
│   └── MapView.vue         # Main application view
├── components/         # Vue components
│   ├── MapRenderer.vue      # Main rendering component
│   ├── TerritoryControls.vue
│   └── ui/                  # Reusable UI components
├── composables/        # Vue composables (reusable logic)
├── stores/             # Pinia state stores
│   ├── config.ts           # Configuration state
│   └── geoData.ts          # Geographic data state
├── core/               # Core domain logic
│   ├── atlases/            # Atlas system
│   ├── projections/        # Projection system
│   └── types/              # Shared types
├── services/           # Business logic layer
│   ├── atlas/              # Atlas management
│   ├── projection/         # Projection creation
│   ├── rendering/          # Rendering coordination
│   └── data/               # Data loading
├── types/              # TypeScript definitions
└── i18n/               # Internationalization

configs/                # Atlas configurations
├── schema.json            # JSON schema
├── france.json
├── portugal.json
└── ...

scripts/                # Build and dev scripts
├── prepare-geodata.ts     # Data preparation
└── validate-configs.ts    # Validation
```

## Key Patterns

### Configuration-Driven Design
- Atlas behavior defined in JSON configs
- Validated against JSON schema
- Loaded dynamically at runtime
- Single source of truth for atlas rules

### Service Layer Pattern
- Clear separation: UI → Service → D3/Plot
- Services are stateless coordinators
- State managed in Pinia stores
- Services use dependency injection

### Projection Parameter Management
- Centralized configuration (projections/parameters.ts)
- Family-based parameter relevance
- Priority: custom → atlas → defaults
- Type-safe with TypeScript

### Reactive Rendering
- Watchers trigger re-renders on state changes
- CartographerService coordinates rendering
- MapRenderer.vue handles DOM updates
- Efficient re-renders with computed properties

## Data Flow

```
User Action
    ↓
Vue Component
    ↓
Pinia Store (state update)
    ↓
Service Layer (business logic)
    ↓
D3/Observable Plot (rendering)
    ↓
DOM Update
```

## Domain Boundaries

1. **Configuration Domain** (core/atlases/)
   - Atlas definitions and metadata
   - Territory composition rules
   - JSON schema validation

2. **Projection Domain** (core/projections/)
   - Projection definitions and families (20+ projections)
   - Parameter configuration and defaults
   - Projection registry with recommendation engine
   - D3 projection factory and creation

3. **Rendering Domain** (services/rendering/)
   - Cartographer coordination
   - Observable Plot integration
   - Map rendering logic

4. **Data Domain** (services/data/)
   - GeoJSON loading and caching
   - Natural Earth data processing
   - Territory data management

5. **UI Domain** (views/, components/, composables/)
   - Vue components and page layouts (16 components)
   - Reusable composables for logic (9 composables)
   - Component-specific state and interactions
   - Type-safe props and events (vue-props.ts, composables.ts)

6. **State Domain** (stores/)
   - Configuration state: configStore (361 lines) - Atlas, view mode, projections
   - Geographic data state: geoData (200 lines) - GeoJSON data, caching
   - UI state: ui.ts - Loading states, modals, toasts
   - Territory state: territory.ts - Territory-specific transforms
   - Reactive computed properties and watchers

## Vue Architecture Details

### Component Hierarchy
```
App.vue
├── AppHeader.vue (navigation, language, theme)
├── RouterView
│   └── MapView.vue (142 lines - main coordinator)
│       ├── MapRenderer.vue (147 lines - D3 rendering)
│       ├── TerritoryControls.vue (119 lines - territory transforms)
│       ├── ProjectionSelector.vue (114 lines - projection selection)
│       └── UI Components (16 total)
│           ├── ViewModeSection, ProjectionInfo, ProjectionParamsControls
│           └── Reusable: CardContainer, FormControl, SectionHeader
└── AppFooter.vue (credits, links)
```

### Composables (9 total)
**Data Loading**:
- useAtlasData (128 lines) - Orchestrates all data loading
- useLoadingState (32 lines) - Skeleton loading state

**Store Abstraction**:
- useProjectionConfig (58 lines) - Projection helpers
- useViewMode (34 lines) - View mode options
- useTerritoryConfig (27 lines) - Territory configuration

**Component Logic**:
- useTerritoryTransforms (155 lines) - Territory control logic
- useProjectionFiltering (91 lines) - Projection search/filter
- useProjectionRecommendations (78 lines) - Recommendation display

**Validation**:
- useProjectionValidation (148 lines) - Projection validation

### State Management
**configStore** (361 lines):
- Atlas selection (current atlas, region, territories)
- View mode (composite, split, unified)
- Projection mode (existing, custom)
- Projection parameters (custom overrides)
- Computed: effective parameters with priority resolution

**geoDataStore** (200 lines):
- GeoJSON data caching
- Territory data management
- Loading states

**ui/territory stores**:
- UI: Loading modals, toasts, dialogs
- Territory: Territory-specific transforms and states

### Type Safety
**vue-props.ts** (130 lines):
- MapRendererProps, ViewComponentProps
- TerritoryControlsProps, ProjectionSelectorProps
- Centralized prop definitions with defaults

**composables.ts** (240 lines):
- Return type interfaces for all composables
- LoadingState, ProjectionConfig, TerritoryConfig, ViewModeConfig
- TerritoryTransforms, AtlasData, ProjectionFiltering


## Reference Files

For detailed information on specific domains:
- Atlas System: docs/atlases.llm.txt
- Projections: docs/projections.llm.txt
- Services: docs/services.llm.txt
- Scripts: docs/scripts.llm.txt
- Vue Architecture: docs/vue-architecture.llm.txt
- Adding New Atlas: docs/add-new-atlas.llm.txt

## Critical Dependencies

- d3-geo: Core projection engine
- d3-geo-projection: Extended projections
- @observablehq/plot: Declarative plotting
- topojson-client: TopoJSON to GeoJSON conversion
- ajv: JSON schema validation
- pinia: Vue state management
- vue-i18n: Internationalization

## Development Commands

```bash
pnpm install              # Install dependencies
pnpm run dev              # Start dev server
pnpm run build            # Build for production
pnpm run prepare-geodata  # Process Natural Earth data
pnpm run validate-configs # Validate atlas configurations
```

## Entry Points

- Application: src/main.ts
- Routing: src/router/index.ts
- Main View: src/views/MapView.vue
- Renderer: src/components/MapRenderer.vue

## State Management

Two primary stores:
1. **configStore** (stores/config.ts)
   - Selected atlas, projection, view mode
   - Custom projection parameters
   - UI preferences (theme, language)
   - Computed: effectiveProjectionParams

2. **geoDataStore** (stores/geoData.ts)
   - Loaded GeoJSON data
   - Cartographer service instance
   - Data loading state

## Type System

Central type definitions:
- types/atlas.ts: Atlas configuration types
- types/composite.ts: Territory composition
- types/geo-data.ts: Geographic data structures
- core/projections/types.ts: Projection metadata
- types/territory.ts: Territory positioning

## Application Features
- Multi-atlas support (France, Portugal, Spain, EU, USA, World)
- 20+ projections with smart recommendations
- Interactive projection parameter controls
- Three view modes (composite-custom, composite-existing, split, unified)
- Real-time territory positioning
- Responsive design with theme support
- Internationalization (EN/FR)

## Zero-Dependency Projection Loader (October 2025)

The standalone projection loader (src/services/export/standalone-projection-loader.ts) was refactored to use a zero-dependency plugin architecture:

### Architecture
- **Runtime Registry**: Map-based projection storage instead of hardcoded factories
- **Plugin Pattern**: Users register projection factories at runtime
- **Zero Dependencies**: No d3-geo or d3-geo-projection imports (was peer dependencies)
- **Self-Contained Types**: ProjectionLike, ProjectionFactory, StreamLike without external imports
- **Custom Wrapper**: createProjectionWrapper() replaces d3.geoProjection()

### Benefits
- No version conflicts with user's D3 installation
- 94% smaller bundle size (~6KB vs ~100KB with bundled deps)
- Tree-shakeable (import only needed projections)
- Works with any D3 version (v7, v8, future)
- Supports custom projection implementations

### API
- registerProjection(id, factory) - Register single projection
- registerProjections(factories) - Bulk registration
- loadCompositeProjection(config, options) - Load composite projection
- getRegisteredProjections() - Query registry
- clearProjections() - Clear registry

### D3 Helpers (Optional)
File: src/services/export/d3-projection-helpers.ts
- Tree-shakeable D3 projection factories
- Bulk registration helper
- Keeps D3 dependencies isolated from main loader

### Code Generation
The code generator (src/services/export/code-generator.ts) was updated to produce loader-based exports:
- Includes projection registration code
- Embeds configuration as JSON
- Calls loadCompositeProjection() with dimensions
- 80-92% shorter generated code
- Self-documenting (shows registration pattern)

### Documentation
- Complete README: src/services/export/README.md (700+ lines)
- API reference with examples
- TypeScript type documentation
- Troubleshooting guide

See docs/export.llm.txt for detailed documentation.
