# Atlas composer - Architecture Overview

## Purpose
Interactive web application for creating custom cartographic visualizations of countries with geographically-scattered territories using composite projections.

## Technology Stack
- Frontend: Vue.js 3 + TypeScript + Vite
- Mapping: D3.js + Observable Plot
- State: Pinia stores
- Styling: Tailwind CSS + DaisyUI 5
- Data: Natural Earth GeoJSON

## Core Concepts

### 1. Atlas System
Domain: Configuration-driven atlas definitions
File: docs/atlases.llm.txt
- JSON-based atlas configurations (configs/*.json)
- Atlas registry and loader
- Territory composition rules
- View modes (composite, split, unified)

### 2. Projection System
Domain: Map projection management
File: docs/projections.llm.txt
- Projection definitions and families (20+ projections)
- Parameter configuration and application
- Projection registry with recommendation engine
- Projection factory and D3/Observable Plot integration

### 3. Parameter Registry System
Domain: Unified parameter management and validation
File: docs/services.llm.txt (Parameter Management section)
- Central parameter registry with metadata and constraints
- Type-safe parameter definitions for all projection families
- Validation integration across stores, UI, presets, and export
- Parameter inheritance with territory → global → atlas → registry defaults
- Registry-driven UI constraints and real-time validation feedback
- Comprehensive test coverage (32 passing tests)

### 4. Service Layer
Domain: Business logic and rendering
File: docs/services.llm.txt
- AtlasService: Configuration management
- ProjectionService: Projection creation
- CartographerService: Rendering coordination
- DataLoaderService: GeoJSON data loading
- TerritoryDataService: Territory positioning

### 5. Vue Layer
Domain: User interface and interaction
File: docs/vue-architecture.llm.txt
- Vue 3 components with Composition API (16 components)
- Pinia stores for state management (4 stores: config, geoData, parameters, ui/territory)
- Composables for reusable logic (16 composables including useAtlasConfig, useParameterProvider)
- Component hierarchy and data flow
- Comprehensive type safety (370 lines of types)
- Test coverage (175 tests, 100% passing)

### 6. Export System
Domain: Code generation for composite projections
File: docs/export.llm.txt
- Registry-based parameter export with complete coverage
- Configuration serialization using parameter registry
- D3.js code generation (JavaScript/TypeScript)
- Observable Plot code generation
- D3 stream protocol implementation
- Geographic bounds routing and stream multiplexing

### 7. Build System
Domain: Data preparation and validation
File: docs/scripts.llm.txt
- prepare-geodata.ts: Natural Earth processing
- validate-configs.ts: Schema validation
- Development utilities

## Project Structure

```
src/
├── App.vue             # Root component
├── main.ts             # Application entry
├── router/             # Vue Router configuration
├── views/              # Page components
│   └── MapView.vue         # Main application view
├── components/         # Vue components
│   ├── MapRenderer.vue      # Main rendering component
│   ├── TerritoryControls.vue
│   └── ui/                  # Reusable UI components
├── composables/        # Vue composables (reusable logic)
├── stores/             # Pinia state stores
│   ├── config.ts           # Configuration state
│   └── geoData.ts          # Geographic data state
├── core/               # Core domain logic
│   ├── atlases/            # Atlas system
│   ├── projections/        # Projection system
│   └── types/              # Shared types
├── services/           # Business logic layer
│   ├── atlas/              # Atlas management
│   ├── projection/         # Projection creation
│   ├── rendering/          # Rendering coordination
│   └── data/               # Data loading
├── types/              # TypeScript definitions
└── i18n/               # Internationalization

configs/                # Atlas configurations
├── schema.json            # JSON schema
├── france.json
├── portugal.json
└── ...

scripts/                # Build and dev scripts
├── prepare-geodata.ts     # Data preparation
└── validate-configs.ts    # Validation
```

## Key Patterns

### Configuration-Driven Design
- Atlas behavior defined in JSON configs
- Validated against JSON schema
- Loaded dynamically at runtime
- Single source of truth for atlas rules

### Service Layer Pattern
- Clear separation: UI → Service → D3/Plot
- Services are stateless coordinators
- State managed in Pinia stores
- Services use dependency injection

### Unified Parameter Registry System
- Central parameter registry with complete metadata and validation
- Type-safe parameter definitions with constraints and defaults
- Family-based parameter relevance and validation rules
- Integrated validation across stores, UI, presets, and export
- Parameter inheritance: territory → global → atlas → registry defaults
- Registry-driven UI constraints and real-time validation feedback

### Reactive Rendering
- Watchers trigger re-renders on state changes
- CartographerService coordinates rendering
- MapRenderer.vue handles DOM updates
- Efficient re-renders with computed properties

## Data Flow

```
User Action
    ↓
Vue Component
    ↓
Pinia Store (state update)
    ↓
Service Layer (business logic)
    ↓
D3/Observable Plot (rendering)
    ↓
DOM Update
```

## Domain Boundaries

1. **Configuration Domain** (core/atlases/)
   - Atlas definitions and metadata
   - Territory composition rules
   - JSON schema validation

2. **Projection Domain** (core/projections/)
   - Projection definitions and families (20+ projections)
   - Parameter configuration and defaults
   - Projection registry with recommendation engine
   - D3 projection factory and creation

3. **Rendering Domain** (services/rendering/)
   - Cartographer coordination
   - Observable Plot integration
   - Map rendering logic

4. **Data Domain** (services/data/)
   - GeoJSON loading and caching
   - Natural Earth data processing
   - Territory data management

5. **UI Domain** (views/, components/, composables/)
   - Vue components and page layouts (16 components)
   - Reusable composables for logic (16 composables including useAtlasConfig, useParameterProvider)
   - Component-specific state and interactions
   - Type-safe props and events (vue-props.ts, composables.ts)

6. **State Domain** (stores/)
   - Configuration state: configStore (361 lines) - Atlas, view mode, projections
   - Geographic data state: geoData (200 lines) - GeoJSON data, caching
   - UI state: ui.ts - Loading states, modals, toasts
   - Territory state: territory.ts - Territory-specific transforms
   - Reactive computed properties and watchers

## Vue Architecture Details

### Component Hierarchy
```
App.vue
├── AppHeader.vue (navigation, language, theme)
├── RouterView
│   └── MapView.vue (142 lines - main coordinator)
│       ├── MapRenderer.vue (147 lines - D3 rendering)
│       ├── TerritoryControls.vue (119 lines - territory transforms)
│       ├── ProjectionSelector.vue (114 lines - projection selection)
│       └── UI Components (16 total)
│           ├── ViewModeSection, ProjectionInfo, ProjectionParamsControls
│           └── Reusable: CardContainer, FormControl, SectionHeader
└── AppFooter.vue (credits, links)
```

### Composables (9 total)
**Data Loading**:
- useAtlasData (128 lines) - Orchestrates all data loading
- useLoadingState (32 lines) - Skeleton loading state

**Store Abstraction**:
- useProjectionConfig (58 lines) - Projection helpers
- useViewMode (34 lines) - View mode options
- useTerritoryConfig (27 lines) - Territory configuration

**Component Logic**:
- useTerritoryTransforms (155 lines) - Territory control logic
- useProjectionFiltering (91 lines) - Projection search/filter
- useProjectionRecommendations (78 lines) - Recommendation display

**Validation**:
- useProjectionValidation (148 lines) - Projection validation

### State Management
**configStore** (361 lines):
- Atlas selection (current atlas, region, territories)
- View mode (composite, split, unified)
- Projection mode (existing, custom)
- Projection parameters (custom overrides)
- Computed: effective parameters with priority resolution

**geoDataStore** (200 lines):
- GeoJSON data caching
- Territory data management
- Loading states

**ui/territory stores**:
- UI: Loading modals, toasts, dialogs
- Territory: Territory-specific transforms and states

### Type Safety
**vue-props.ts** (130 lines):
- MapRendererProps, ViewComponentProps
- TerritoryControlsProps, ProjectionSelectorProps
- Centralized prop definitions with defaults

**composables.ts** (240 lines):
- Return type interfaces for all composables
- LoadingState, ProjectionConfig, TerritoryConfig, ViewModeConfig
- TerritoryTransforms, AtlasData, ProjectionFiltering


## Reference Files

For detailed information on specific domains:
- Atlas System: docs/atlases.llm.txt
- Projections: docs/projections.llm.txt
- Services: docs/services.llm.txt
- Scripts: docs/scripts.llm.txt
- Vue Architecture: docs/vue-architecture.llm.txt
- Adding New Atlas: docs/add-new-atlas.llm.txt

## Critical Dependencies

- d3-geo: Core projection engine
- d3-geo-projection: Extended projections
- @observablehq/plot: Declarative plotting
- topojson-client: TopoJSON to GeoJSON conversion
- ajv: JSON schema validation
- pinia: Vue state management
- vue-i18n: Internationalization

## Development Commands

```bash
pnpm install              # Install dependencies
pnpm run dev              # Start dev server
pnpm run build            # Build for production
pnpm run prepare-geodata  # Process Natural Earth data
pnpm run validate-configs # Validate atlas configurations
```

## Entry Points

- Application: src/main.ts
- Routing: src/router/index.ts
- Main View: src/views/MapView.vue
- Renderer: src/components/MapRenderer.vue

## State Management

Two primary stores:
1. **configStore** (stores/config.ts)
   - Selected atlas, projection, view mode
   - Custom projection parameters
   - UI preferences (theme, language)
   - Computed: effectiveProjectionParams

2. **geoDataStore** (stores/geoData.ts)
   - Loaded GeoJSON data
   - Cartographer service instance
   - Data loading state

## Type System

Central type definitions:
- types/atlas.ts: Atlas configuration types
- types/composite.ts: Territory composition
- types/geo-data.ts: Geographic data structures
- core/projections/types.ts: Projection metadata
- types/territory.ts: Territory positioning

## Application Features
- Multi-atlas support (France, Portugal, Spain, EU, USA, World)
- 20+ projections with smart recommendations
- Interactive projection parameter controls
- Three view modes (composite-custom, composite-existing, split, unified)
- Real-time territory positioning
- Responsive design with theme support
- Internationalization (EN/FR)

## Projection Loader Package (packages/projection-loader/)

The standalone projection loader is published as `@atlas-composer/projection-loader` workspace package:

### Architecture
- **Runtime Registry**: Map-based projection storage
- **Plugin Pattern**: Users register projection factories at runtime
- **Zero Dependencies**: No d3-geo or d3-geo-projection bundled
- **Self-Contained Types**: ProjectionLike, ProjectionFactory, StreamLike without external imports
- **Workspace Package**: Built independently, tested separately

### Package Structure
```
packages/projection-loader/
├── src/
│   ├── standalone-projection-loader.ts    # Core loader (628 lines)
│   ├── d3-projection-helpers.ts           # Optional D3 factories (134 lines)
│   └── index.ts                           # Public exports
├── __tests__/                             # Test suite (19 tests)
├── examples/                              # Usage examples (5 examples)
├── package.json                           # Independent package config
└── README.md                              # User-facing documentation
```

### Benefits
- No version conflicts with user's D3 installation
- 94% smaller bundle size (~6KB vs ~100KB with bundled deps)
- Tree-shakeable exports
- Independent versioning and publishing
- Tree-shakeable (import only needed projections)
- Works with any D3 version (v7, v8, future)
- Supports custom projection implementations

### API
- registerProjection(id, factory) - Register single projection
- registerProjections(factories) - Bulk registration
- loadCompositeProjection(config, options) - Load composite projection
- getRegisteredProjections() - Query registry
- clearProjections() - Clear registry

### D3 Helpers (Optional)
File: packages/projection-loader/src/d3-projection-helpers.ts
- Tree-shakeable D3 projection factories
- Bulk registration helper
- Keeps D3 dependencies isolated from main loader

### Code Generation
The code generator (src/services/export/code-generator.ts) produces loader-based exports:
- Includes projection registration code
- Embeds configuration as JSON
- Calls loadCompositeProjection() with dimensions
- Generates compact code (80-92% smaller than manual implementations)
- Self-documenting (shows registration pattern)

### Build Integration
- Built independently: `pnpm --filter @atlas-composer/projection-loader build`
- Integrated in main build: `pnpm build` runs `build:loader` first
- Independent test suite with 19 tests
- Examples demonstrate usage patterns

See docs/export.llm.txt for detailed documentation.

## Parameter Management Architecture

All projection parameters are managed through a unified parameter provider system:

### Parameter Provider
- **Location**: `src/core/parameters/parameter-definitions.ts` + `src/services/parameters/projection-parameter-manager.ts`
- **Single source of truth** for all runtime parameter access
- Parameters are validated and type-checked through the registry

### Managed Parameters
All parameters accessed exclusively through parameter provider:
- **Geographic**: `center`, `rotate`, `parallels`
- **Scale**: `scaleMultiplier` (baseScale computed from referenceScale)
- **Position**: `translateOffset` (from config), `translate` (adjustment parameter)
- **Clipping**: `pixelClipExtent` [x1, y1, x2, y2] - pixel coordinates relative to territory center
- **Quality**: `clipAngle`, `precision`

### Storage Locations
- **Preset files**: Parameters stored in `projection.parameters` and `layout.pixelClipExtent`
- **Runtime**: ALL parameters accessed through `parameterProvider.getEffectiveParameters(territoryCode)`
- **Stores**: `configStore` and `territoryStore` delegate to `parameterStore`

### Clipping Format
- **Only format**: `pixelClipExtent: [x1, y1, x2, y2]` as 4-element array
- **Coordinates**: Pixel offsets relative to territory center (translateOffset)
- **No legacy formats**: Object `{x1,y1,x2,y2}` and nested array `[[x1,y1],[x2,y2]]` removed
