# Unified Parameter Registry Implementation Plan

## Vision

CompositeProjection requires a loaded preset to operate. All projection parameters flow through a single, unified system:

```
Preset Definition (JSON)
  ↓
Parameter Registry (validates & normalizes)
  ↓
Parameter Store (single source of truth)
  ↓
UI Controls (read/write to store)
  ↓
CompositeProjection (reads from store only)
  ↓
Export (reads from store)
  ↓
Import (writes to store)
```

**Key Principle:** No scattered state. No D3-as-source. Parameter store is authoritative for ALL projection configuration.

## Core Requirements

### R1: Preset Mandatory

CompositeProjection cannot initialize without a preset loaded. No fallback defaults scattered in code.

**Current State:** CompositeProjection falls back to hardcoded values (REFERENCE_SCALE = 2700, etc.)

**Target State:** CompositeProjection constructor requires preset parameters or throws error.

### R2: Single Parameter Source

All parameters live in parameter store. No duplicate storage in CompositeProjection metadata, territory store, or D3 instances.

**Current State:** Parameters scattered across 3+ stores

**Target State:** Parameter store is single source, everything else reads from it.

### R3: Complete Parameter Coverage

All ProjectionParameters fields must be:
- Defined in preset (with defaults)
- Stored in parameter store
- Exposed in UI (where applicable)
- Exported in JSON
- Imported from JSON

**Current State:** translate, clipAngle, precision missing from export/import

**Target State:** 100% coverage - no parameters left behind.

### R4: Type Safety

Parameter registry provides compile-time type safety. Adding a parameter requires updating one central location.

**Current State:** Parameter definitions scattered, easy to miss updates

**Target State:** Single registry, TypeScript enforces completeness.

### R5: Validation

All parameters validated through registry constraints before storage.

**Current State:** Validation in unified-parameter-constraints.ts but disconnected from export/import

**Target State:** Registry validates at every entry point (preset load, import, UI change).

## Architecture Design

### Component 1: Parameter Registry

**Location:** `src/core/parameters/parameter-registry.ts`

**Purpose:** Central definition of all projection parameters with metadata.

**Structure:**

```typescript
/**
 * Parameter definition with full metadata
 */
interface ParameterDefinition {
  // Identity
  key: keyof ProjectionParameters
  displayName: string
  description: string

  // Type information
  type: 'number' | 'tuple2' | 'tuple3' | 'boolean'
  unit?: string  // 'degrees', 'pixels', 'scale', etc.

  // Data flow
  source: 'preset' | 'computed'  // Where it comes from
  mutable: boolean              // Can user change it?
  exportable: boolean           // Include in export?
  requiresPreset: boolean       // Must be in preset?

  // Validation
  constraints: ParameterConstraint | ((family: ProjectionFamilyType) => ParameterConstraint)

  // Relevance
  relevantFor: ProjectionFamilyType[] | 'all'

  // Defaults
  defaultValue?: any
  computeDefault?: (territory: TerritoryConfig) => any
}

/**
 * Central parameter registry
 */
class ParameterRegistry {
  private definitions = new Map<string, ParameterDefinition>()

  // Registration
  register(def: ParameterDefinition): void

  // Queries
  get(key: string): ParameterDefinition | undefined
  getAll(): ParameterDefinition[]
  getExportable(): ParameterDefinition[]
  getRequired(): ParameterDefinition[]
  getRelevant(family: ProjectionFamilyType): ParameterDefinition[]

  // Validation
  validate(key: string, value: any, family: ProjectionFamilyType): ValidationResult
  validateParameters(params: Partial<ProjectionParameters>, family: ProjectionFamilyType): ValidationResult[]

  // Default generation
  getDefaults(territory: TerritoryConfig, family: ProjectionFamilyType): ProjectionParameters
}

// Singleton instance
export const parameterRegistry = new ParameterRegistry()
```

**Parameter Definitions:**

```typescript
// Core positioning parameters
parameterRegistry.register({
  key: 'center',
  displayName: 'Center',
  description: 'Geographic center point [longitude, latitude]',
  type: 'tuple2',
  unit: 'degrees',
  source: 'preset',
  mutable: true,
  exportable: true,
  requiresPreset: true,
  constraints: (family) => ({
    min: [-180, -90],
    max: [180, 90],
    relevant: family !== 'CONIC'  // Conic uses rotate instead
  }),
  relevantFor: ['CYLINDRICAL', 'AZIMUTHAL', 'WORLD'],
})

parameterRegistry.register({
  key: 'rotate',
  displayName: 'Rotation',
  description: 'Three-axis rotation [lambda, phi, gamma]',
  type: 'tuple3',
  unit: 'degrees',
  source: 'preset',
  mutable: true,
  exportable: true,
  requiresPreset: true,
  constraints: (family) => ({
    min: [-180, -90, -180],
    max: [180, 90, 180],
    relevant: family === 'CONIC'
  }),
  relevantFor: ['CONIC'],
})

parameterRegistry.register({
  key: 'parallels',
  displayName: 'Standard Parallels',
  description: 'Standard parallels for conic projections [south, north]',
  type: 'tuple2',
  unit: 'degrees',
  source: 'preset',
  mutable: true,
  exportable: true,
  requiresPreset: true,
  constraints: (family) => ({
    min: [-90, -90],
    max: [90, 90],
    relevant: family === 'CONIC'
  }),
  relevantFor: ['CONIC'],
})

// Scale parameters
parameterRegistry.register({
  key: 'baseScale',
  displayName: 'Base Scale',
  description: 'Base scale value before multiplier',
  type: 'number',
  unit: 'scale',
  source: 'preset',
  mutable: false,  // Not directly user-editable
  exportable: true,
  requiresPreset: true,
  constraints: { min: 100, max: 100000 },
  relevantFor: 'all',
})

parameterRegistry.register({
  key: 'scaleMultiplier',
  displayName: 'Scale Multiplier',
  description: 'Scale adjustment factor',
  type: 'number',
  unit: 'multiplier',
  source: 'preset',
  mutable: true,
  exportable: true,
  requiresPreset: true,
  constraints: { min: 0.1, max: 10, step: 0.1 },
  relevantFor: 'all',
})

parameterRegistry.register({
  key: 'scale',
  displayName: 'Scale',
  description: 'Final scale value (computed or override)',
  type: 'number',
  unit: 'scale',
  source: 'computed',  // Computed from baseScale * scaleMultiplier
  mutable: true,       // Can override
  exportable: true,
  requiresPreset: false,
  constraints: { min: 100, max: 100000, step: 50 },
  relevantFor: 'all',
  computeDefault: (territory) => territory.baseScale * (territory.scaleMultiplier || 1)
})

// Translation parameters
parameterRegistry.register({
  key: 'translateOffset',
  displayName: 'Layout Position',
  description: 'Territory position offset from map center [x, y]',
  type: 'tuple2',
  unit: 'pixels',
  source: 'preset',
  mutable: true,
  exportable: true,
  requiresPreset: true,
  constraints: { min: [-2000, -2000], max: [2000, 2000] },
  relevantFor: 'all',
})

parameterRegistry.register({
  key: 'translate',
  displayName: 'Translation Adjustment',
  description: 'Additional translation on top of layout position [x, y]',
  type: 'tuple2',
  unit: 'pixels',
  source: 'preset',
  mutable: true,
  exportable: true,
  requiresPreset: false,
  constraints: { min: [-1000, -1000], max: [1000, 1000], step: 10 },
  relevantFor: 'all',
  defaultValue: [0, 0]
})

// Advanced parameters
parameterRegistry.register({
  key: 'clipAngle',
  displayName: 'Clip Angle',
  description: 'Clipping angle for azimuthal projections',
  type: 'number',
  unit: 'degrees',
  source: 'preset',
  mutable: true,
  exportable: true,
  requiresPreset: false,
  constraints: (family) => ({
    min: 0,
    max: 180,
    step: 1,
    relevant: family === 'AZIMUTHAL'
  }),
  relevantFor: ['AZIMUTHAL'],
  defaultValue: 90
})

parameterRegistry.register({
  key: 'precision',
  displayName: 'Precision',
  description: 'Adaptive sampling precision',
  type: 'number',
  source: 'preset',
  mutable: true,
  exportable: true,
  requiresPreset: false,
  constraints: { min: 0.01, max: 10, step: 0.01 },
  relevantFor: 'all',
  defaultValue: 0.1
})

// Clipping
parameterRegistry.register({
  key: 'clipExtent',
  displayName: 'Clip Extent',
  description: 'Normalized clipping bounds [[x1, y1], [x2, y2]]',
  type: 'custom',  // Special handling for nested arrays
  source: 'preset',
  mutable: false,
  exportable: true,
  requiresPreset: false,
  relevantFor: 'all',
})
```

### Component 2: Enhanced Parameter Store

**Location:** `src/stores/parameters.ts`

**Changes:** Integrate with parameter registry for validation and defaults.

**New Methods:**

```typescript
export const useParameterStore = defineStore('parameters', () => {
  // ... existing code ...

  /**
   * Initialize from preset with validation
   */
  function initializeFromPreset(
    atlasParams: AtlasProjectionParameters,
    territoryParams: Record<string, ProjectionParameters>
  ): ValidationResult[] {
    const errors: ValidationResult[] = []

    // Validate all required parameters are present
    const required = parameterRegistry.getRequired()
    for (const def of required) {
      for (const [code, params] of Object.entries(territoryParams)) {
        if (!(def.key in params)) {
          errors.push({
            isValid: false,
            error: `Missing required parameter ${def.key} for territory ${code}`
          })
        }
      }
    }

    // Set atlas parameters
    setAtlasParameters(atlasParams)

    // Set territory parameters with validation
    for (const [code, params] of Object.entries(territoryParams)) {
      const family = getTerritoryProjectionFamily(code)
      const validationResults = parameterRegistry.validateParameters(params, family)
      errors.push(...validationResults.filter(r => !r.isValid))

      setTerritoryParameters(code, params)
    }

    return errors
  }

  /**
   * Get complete parameters for export
   */
  function getExportableParameters(territoryCode: string): ProjectionParameters {
    const params = getEffectiveParameters(territoryCode)
    const exportable = parameterRegistry.getExportable()

    const result: ProjectionParameters = {}
    for (const def of exportable) {
      if (def.key in params) {
        result[def.key] = params[def.key]
      }
    }

    return result
  }

  return {
    // ... existing exports ...
    initializeFromPreset,
    getExportableParameters,
  }
})
```

### Component 3: Enhanced Preset Loader

**Location:** `src/services/presets/preset-loader.ts`

**Changes:** Use parameter registry for validation and extraction.

**New Methods:**

```typescript
export class PresetLoader {
  /**
   * Load preset with full parameter validation
   */
  static async loadPreset(atlasId: string, presetName: string): Promise<PresetLoadResult> {
    // Load JSON
    const preset = await this.loadPresetFile(atlasId, presetName)

    // Validate structure
    const structureErrors = this.validateStructure(preset)
    if (structureErrors.length > 0) {
      return { success: false, errors: structureErrors }
    }

    // Validate all parameters using registry
    const paramErrors: string[] = []
    for (const territory of preset.territories) {
      const family = territory.projectionFamily as ProjectionFamilyType

      // Check required parameters
      const required = parameterRegistry.getRequired()
      for (const def of required) {
        if (def.requiresPreset && !(def.key in territory.parameters)) {
          paramErrors.push(`Territory ${territory.code}: missing required parameter ${def.key}`)
        }
      }

      // Validate parameter values
      const validationResults = parameterRegistry.validateParameters(
        territory.parameters,
        family
      )
      for (const result of validationResults) {
        if (!result.isValid) {
          paramErrors.push(`Territory ${territory.code}: ${result.error}`)
        }
      }
    }

    if (paramErrors.length > 0) {
      return { success: false, errors: paramErrors }
    }

    return { success: true, preset }
  }

  /**
   * Extract territory parameters using registry
   */
  static extractTerritoryParameters(
    preset: ExportedCompositeConfig
  ): Record<string, ProjectionParameters> {
    const result: Record<string, ProjectionParameters> = {}

    for (const territory of preset.territories) {
      const family = territory.projectionFamily as ProjectionFamilyType
      const exportable = parameterRegistry.getExportable()

      // Extract all exportable parameters
      const params: ProjectionParameters = {}
      for (const def of exportable) {
        if (def.key in territory.parameters) {
          params[def.key] = territory.parameters[def.key]
        } else if (def.defaultValue !== undefined) {
          params[def.key] = def.defaultValue
        } else if (def.computeDefault) {
          params[def.key] = def.computeDefault(territory)
        }
      }

      result[territory.code] = params
    }

    return result
  }
}
```

### Component 4: Preset Schema Update

**Location:** `configs/presets/schema.json`

**Changes:** Add all missing parameters to schema.

**New Fields:**

```json
{
  "parameters": {
    "type": "object",
    "required": ["center", "rotate", "parallels", "baseScale", "scaleMultiplier"],
    "properties": {
      "center": { "type": "array", "items": { "type": "number" }, "minItems": 2, "maxItems": 2 },
      "rotate": { "type": "array", "items": { "type": "number" }, "minItems": 3, "maxItems": 3 },
      "parallels": { "type": "array", "items": { "type": "number" }, "minItems": 2, "maxItems": 2 },
      "scale": { "type": "number", "minimum": 100 },
      "baseScale": { "type": "number", "minimum": 100 },
      "scaleMultiplier": { "type": "number", "minimum": 0.1, "maximum": 10 },
      "translateOffset": { "type": "array", "items": { "type": "number" }, "minItems": 2, "maxItems": 2 },
      "translate": { "type": "array", "items": { "type": "number" }, "minItems": 2, "maxItems": 2 },
      "clipAngle": { "type": "number", "minimum": 0, "maximum": 180 },
      "precision": { "type": "number", "minimum": 0.01, "maximum": 10 }
    }
  }
}
```

### Component 5: Enhanced CompositeProjection

**Location:** `src/services/projection/composite-projection.ts`

**Changes:** Remove scattered state, read everything from parameter provider.

**Key Changes:**

```typescript
interface SubProjection {
  territoryCode: string
  territoryName: string
  projection: GeoProjection
  projectionType: string
  // REMOVED: baseScale, scaleMultiplier, translateOffset
  // These now ONLY live in parameter store
  clipExtent: [[number, number], [number, number]] | null
  bounds: [[number, number], [number, number]]
}

class CompositeProjection {
  constructor(
    config: CompositeProjectionConfig,
    parameterProvider: ProjectionParameterProvider  // NOW REQUIRED
  ) {
    if (!parameterProvider) {
      throw new Error('CompositeProjection requires a parameter provider (preset must be loaded)')
    }

    this.config = config
    this.parameterProvider = parameterProvider
    this.initialize()
  }

  private initialize() {
    // Read ALL parameters from parameter provider
    const params = this.parameterProvider.getEffectiveParameters(territory.code)

    // Validate required parameters are present
    const required = parameterRegistry.getRequired()
    for (const def of required) {
      if (def.requiresPreset && !(def.key in params)) {
        throw new Error(`Missing required parameter ${def.key} for territory ${territory.code}`)
      }
    }

    // Apply ALL parameters from parameter provider
    const baseScale = params.baseScale!
    const scaleMultiplier = params.scaleMultiplier!
    const translateOffset = params.translateOffset || [0, 0]
    const center = params.center
    const rotate = params.rotate
    const parallels = params.parallels
    const clipAngle = params.clipAngle
    const precision = params.precision

    // Create projection
    projection.scale(baseScale * scaleMultiplier)

    // Apply positioning
    if (isConicProjection) {
      projection.rotate(rotate)
      if (parallels) projection.parallels(parallels)
    } else {
      projection.center(center)
    }

    // Apply advanced parameters
    if (clipAngle !== undefined) projection.clipAngle(clipAngle)
    if (precision !== undefined) projection.precision(precision)

    // Store projection WITHOUT duplicating parameters
    this.addSubProjection({
      territoryCode,
      territoryName,
      projection,
      projectionType,
      // NO baseScale, scaleMultiplier, translateOffset stored here
      clipExtent,
      bounds
    })
  }

  build(width: number, height: number): GeoProjection {
    // Read parameters from parameter provider for each territory
    this.subProjections.forEach(subProj => {
      const params = this.parameterProvider.getEffectiveParameters(subProj.territoryCode)

      // Get all translation components
      const translateOffset = params.translateOffset || [0, 0]
      const translateAdjust = params.translate || [0, 0]

      // Combine: center + layout offset + user adjustment
      const finalTranslate: [number, number] = [
        width / 2 + translateOffset[0] + translateAdjust[0],
        height / 2 + translateOffset[1] + translateAdjust[1]
      ]

      subProj.projection.translate(finalTranslate)

      // Apply scale (may have changed)
      const baseScale = params.baseScale!
      const scaleMultiplier = params.scaleMultiplier!
      const scaleOverride = params.scale

      const finalScale = scaleOverride !== undefined
        ? scaleOverride
        : baseScale * scaleMultiplier

      subProj.projection.scale(finalScale)
    })

    // Return composite projection
    return this.buildComposite()
  }

  exportConfig(): ExportedProjectionConfig {
    // Export reads from parameter provider
    return {
      subProjections: this.subProjections.map(sp => {
        const params = this.parameterProvider.getEffectiveParameters(sp.territoryCode)
        const exportable = parameterRegistry.getExportable()

        const exportedParams: any = {}
        for (const def of exportable) {
          if (def.key in params) {
            exportedParams[def.key] = params[def.key]
          }
        }

        return {
          territoryCode: sp.territoryCode,
          territoryName: sp.territoryName,
          projectionType: sp.projectionType,
          parameters: exportedParams,
          bounds: sp.bounds,
          clipExtent: sp.clipExtent
        }
      })
    }
  }
}
```

### Component 6: Enhanced Export Service

**Location:** `src/services/export/composite-export-service.ts`

**Changes:** Use parameter registry for complete export.

```typescript
export class CompositeExportService {
  static exportToJSON(
    compositeProjection: CompositeProjection,
    atlasId: string,
    atlasName: string,
    compositeConfig: CompositeProjectionConfig,
    parameterStore: ReturnType<typeof useParameterStore>,  // NOW REQUIRED
    notes?: string
  ): ExportedCompositeConfig {
    // Get raw export (now includes ALL parameters from parameter store)
    const rawExport = compositeProjection.exportConfig()

    // Territory transformation remains same
    const territories = rawExport.subProjections.map((subProj): ExportedTerritory => {
      return {
        code: subProj.territoryCode,
        name: subProj.territoryName,
        role: this.determineTerritoryRole(subProj.territoryCode, compositeConfig),
        projectionId: this.resolveProjectionId(subProj.projectionType),
        projectionFamily: projectionRegistry.get(subProj.projectionType)?.family || 'unknown',
        parameters: subProj.parameters,  // Now complete from parameter store
        layout: {
          // translateOffset is now in parameters
          translateOffset: subProj.parameters.translateOffset || [0, 0],
          clipExtent: subProj.clipExtent || null
        },
        bounds: subProj.bounds
      }
    })

    return {
      version: '1.0',
      metadata: { atlasId, atlasName, exportDate: new Date().toISOString(), createdWith: APP_VERSION, notes },
      pattern: compositeConfig.type,
      referenceScale: territories[0]?.parameters.baseScale || 2700,
      territories
    }
  }
}
```

### Component 7: Enhanced Import Service

**Location:** `src/services/export/composite-import-service.ts`

**Changes:** Single-pass import through parameter store.

```typescript
export class CompositeImportService {
  static applyToStores(
    config: ExportedCompositeConfig,
    parameterStore: ReturnType<typeof useParameterStore>,
    territoryStore: ReturnType<typeof useTerritoryStore>,
    compositeProjection: CompositeProjection
  ): void {
    // Validate using parameter registry
    const errors: string[] = []
    for (const territory of config.territories) {
      const family = territory.projectionFamily as ProjectionFamilyType
      const validationResults = parameterRegistry.validateParameters(
        territory.parameters,
        family
      )
      for (const result of validationResults.filter(r => !r.isValid)) {
        errors.push(`Territory ${territory.code}: ${result.error}`)
      }
    }

    if (errors.length > 0) {
      throw new Error(`Import validation failed:\n${errors.join('\n')}`)
    }

    // Single-pass application
    config.territories.forEach(territory => {
      // 1. Apply ALL parameters to parameter store (single source of truth)
      const exportable = parameterRegistry.getExportable()
      const params: ProjectionParameters = {}

      for (const def of exportable) {
        if (def.key in territory.parameters) {
          params[def.key] = territory.parameters[def.key]
        } else if (def.defaultValue !== undefined) {
          params[def.key] = def.defaultValue
        }
      }

      parameterStore.setTerritoryParameters(territory.code, params)

      // 2. Set projection type (if changed)
      territoryStore.setTerritoryProjection(territory.code, territory.projectionId)

      // 3. Trigger CompositeProjection update (reads from parameter store)
      compositeProjection.updateTerritoryParameters(territory.code)
    })

    // No redundant operations - everything flows through parameter store
  }
}
```

## Implementation Plan

### Phase 1: Foundation (4-6 hours)

**Goal:** Create parameter registry infrastructure without breaking existing code.

**Tasks:**

1. **Create ParameterRegistry class** (`src/core/parameters/parameter-registry.ts`)
   - Implement ParameterDefinition interface
   - Implement ParameterRegistry class
   - Create singleton instance
   - Write unit tests

2. **Register all parameters**
   - Define all 12 parameters in registry
   - Include validation constraints
   - Set relevance by projection family
   - Verify completeness against ProjectionParameters interface

3. **Update preset schema** (`configs/presets/schema.json`)
   - Add translate, clipAngle, precision
   - Make translateOffset required in parameters section
   - Update all presets to include new fields

**Deliverables:**
- `src/core/parameters/parameter-registry.ts` (new)
- `src/core/parameters/__tests__/parameter-registry.spec.ts` (new)
- `configs/presets/schema.json` (updated)
- All preset JSON files updated

**Testing:**
- Unit tests for ParameterRegistry
- Schema validation for all presets
- No breaking changes to existing code

### Phase 2: Parameter Store Integration (3-4 hours)

**Goal:** Enhance parameter store to use registry for validation.

**Tasks:**

1. **Add registry integration to parameter store**
   - Import parameterRegistry
   - Add `initializeFromPreset()` method
   - Add `getExportableParameters()` method
   - Use registry for validation in `setTerritoryParameter()`

2. **Update PresetLoader**
   - Use registry for preset validation
   - Use registry for parameter extraction
   - Return validation errors from `loadPreset()`

3. **Update config store initialization**
   - Call `parameterStore.initializeFromPreset()` with preset data
   - Handle validation errors
   - Display validation errors to user

**Deliverables:**
- `src/stores/parameters.ts` (updated)
- `src/services/presets/preset-loader.ts` (updated)
- `src/stores/config.ts` (updated)

**Testing:**
- Test preset loading with validation
- Test invalid preset rejection
- Test parameter extraction completeness
- Verify no regression in existing functionality

### Phase 3: Export Enhancement (2-3 hours)

**Goal:** Export reads from parameter store, includes all parameters.

**Tasks:**

1. **Update CompositeProjection.exportConfig()**
   - Accept parameterProvider as parameter
   - Read exportable parameters from parameterProvider
   - Remove reads from D3 projection instances
   - Use registry to determine what to export

2. **Update CompositeExportService**
   - Require parameterStore parameter
   - Use enhanced exportConfig()
   - Verify complete parameter coverage

3. **Update export UI**
   - Pass parameterStore to export service
   - Display validation errors if export fails

**Deliverables:**
- `src/services/projection/composite-projection.ts:exportConfig()` (updated)
- `src/services/export/composite-export-service.ts` (updated)
- `src/components/ui/export/CompositeExportDialog.vue` (updated)

**Testing:**
- Export preset, verify all parameters present
- Compare exported JSON to schema
- Round-trip test: export then import, verify identical state

### Phase 4: Import Enhancement (2-3 hours)

**Goal:** Single-pass import through parameter store.

**Tasks:**

1. **Simplify import flow**
   - Remove Phase 3 redundant operations
   - Single loop applying parameters to parameter store
   - Remove direct CompositeProjection manipulation

2. **Add validation**
   - Validate imported parameters using registry
   - Reject invalid imports with clear errors
   - Handle partial failures gracefully

3. **Update import UI**
   - Display validation errors
   - Show which parameters will be applied
   - Confirm before overwriting current state

**Deliverables:**
- `src/services/export/composite-import-service.ts` (simplified)
- `src/components/ui/import/ImportModal.vue` (updated)

**Testing:**
- Import valid preset, verify all parameters applied
- Import invalid preset, verify rejection with clear errors
- Import with missing optional parameters, verify defaults applied
- Round-trip test: export then import then export, verify byte-identical JSON

### Phase 5: CompositeProjection Refactor (6-8 hours)

**Goal:** Remove parameter duplication, parameter provider becomes required.

**Tasks:**

1. **Update SubProjection interface**
   - Remove baseScale, scaleMultiplier, translateOffset
   - Keep only projection instance, bounds, clipExtent

2. **Make parameterProvider required**
   - Add validation in constructor
   - Throw error if not provided
   - Update all call sites

3. **Update initialize() method**
   - Read ALL parameters from parameterProvider
   - Validate required parameters present
   - Apply all parameters to D3 projection
   - Remove fallback defaults

4. **Update build() method**
   - Read parameters for each territory from parameterProvider
   - Compute final scale from baseScale/scaleMultiplier/override
   - Compute final translate from translateOffset/translate
   - Apply to projections

5. **Update updateTerritoryParameters() method**
   - Read from parameterProvider only
   - No local state to sync

6. **Update updateScale() method**
   - Write to parameter store
   - Re-read from parameter store
   - Remove direct projection manipulation

7. **Remove updateTranslationOffset() method**
   - Translation changes go through parameter store
   - Call updateTerritoryParameters() to apply

**Deliverables:**
- `src/services/projection/composite-projection.ts` (major refactor)
- All call sites updated

**Testing:**
- All existing tests pass
- Verify preset required (error if not provided)
- Verify all parameters flow through parameter store
- Verify no parameter duplication
- Performance testing (no regression)

### Phase 6: Territory Store Cleanup (2-3 hours)

**Goal:** Remove duplicate scale/translation from territory store.

**Tasks:**

1. **Analyze territory store usage**
   - Identify what still needs to be in territory store
   - Projection type: YES (UI selection)
   - Translation: MOVE to parameter store
   - Scale multiplier: MOVE to parameter store

2. **Move translation to parameter store**
   - Update useTerritoryTransforms composable
   - Update TerritoryControls component
   - Remove from territory store

3. **Move scale multiplier to parameter store**
   - Update useTerritoryTransforms composable
   - Update TerritoryControls component
   - Remove from territory store

4. **Simplify territory store**
   - Keep only projectionId per territory
   - Remove translations, scales

**Deliverables:**
- `src/stores/territory.ts` (simplified)
- `src/composables/useTerritoryTransforms.ts` (updated)
- `src/components/TerritoryControls.vue` (updated)

**Testing:**
- UI controls work identically
- State persistence works
- No regressions

### Phase 7: Documentation & Migration (2-3 hours)

**Goal:** Document new architecture, provide migration guide.

**Tasks:**

1. **Update architecture docs**
   - Update `docs/presets.llm.txt` with new architecture
   - Update `docs/preset-export-import-analysis.llm.txt` with resolution
   - Create `docs/parameter-registry.llm.txt` with registry usage

2. **Create migration guide**
   - Document breaking changes
   - Provide code examples for common tasks
   - Update README if needed

3. **Update preset files**
   - Regenerate all presets with complete parameters
   - Validate against new schema
   - Commit updated presets

**Deliverables:**
- `docs/parameter-registry.llm.txt` (new)
- `docs/presets.llm.txt` (updated)
- `docs/MIGRATION.md` (new)
- All preset JSON files (regenerated)

## Breaking Changes

### For Users

**None** - This is an internal refactor. User-facing functionality remains identical.

### For Developers

1. **CompositeProjection constructor now requires parameterProvider**
   - Before: `new CompositeProjection(config)`
   - After: `new CompositeProjection(config, parameterProvider)`
   - Migration: Always pass parameter provider from parameter store

2. **Export now requires parameter store**
   - Before: `CompositeExportService.exportToJSON(composite, ...)`
   - After: `CompositeExportService.exportToJSON(composite, ..., parameterStore)`
   - Migration: Pass parameter store instance

3. **Preset files must include all parameters**
   - Before: Optional translate, clipAngle, precision
   - After: Must include all parameters (can be null/default)
   - Migration: Regenerate presets with export tool

4. **Territory store no longer stores scale/translation**
   - Before: `territoryStore.setTerritoryScale()`, `setTerritoryTranslation()`
   - After: Use parameter store: `parameterStore.setTerritoryParameter(code, 'scaleMultiplier', value)`
   - Migration: Update composables to use parameter store

## Validation Strategy

### Compile-Time Validation

- TypeScript ensures all parameters in ProjectionParameters interface are registered
- Exhaustiveness checking on parameter keys
- Type-safe parameter access

### Runtime Validation

- Preset loading validates all parameters against registry
- Import validates all parameters against registry
- UI changes validate against registry constraints
- Export validates completeness before writing

### Test Coverage

- Unit tests for ParameterRegistry
- Integration tests for preset loading
- Round-trip tests for export/import
- E2E tests for parameter changes through UI

## Success Criteria

1. **No Scattered State**
   - Parameter store is single source of truth
   - No parameter duplication in CompositeProjection
   - No parameter duplication in territory store

2. **Complete Coverage**
   - All ProjectionParameters fields exportable
   - All ProjectionParameters fields importable
   - 100% round-trip fidelity

3. **Type Safety**
   - Adding parameter requires one change (registry)
   - Compile errors if parameter not handled
   - No runtime surprises

4. **Validation**
   - Invalid presets rejected at load time
   - Invalid imports rejected with clear errors
   - Invalid UI changes prevented

5. **Preset Required**
   - CompositeProjection fails without preset
   - Clear error message
   - No scattered fallback defaults

6. **No Regressions**
   - All existing tests pass
   - Performance identical or better
   - UI behavior unchanged

## Timeline

**Total Estimated Effort:** 23-30 hours

- Phase 1: 4-6 hours
- Phase 2: 3-4 hours
- Phase 3: 2-3 hours
- Phase 4: 2-3 hours
- Phase 5: 6-8 hours
- Phase 6: 2-3 hours
- Phase 7: 2-3 hours

**Recommended Schedule:**

- Week 1: Phases 1-2 (Foundation + Parameter Store)
- Week 2: Phases 3-4 (Export + Import)
- Week 3: Phases 5-6 (CompositeProjection + Territory Store)
- Week 4: Phase 7 (Documentation) + Buffer

## Risk Assessment

### Low Risk

- Phase 1: Additive only, no breaking changes
- Phase 2: Well-defined interfaces, incremental
- Phase 7: Documentation only

### Medium Risk

- Phase 3: Export changes, but backward compatible
- Phase 4: Import changes, but can be tested in isolation
- Phase 6: Store changes, but limited scope

### High Risk

- Phase 5: Large refactor of CompositeProjection, many call sites

**Mitigation:**
- Comprehensive test suite before starting Phase 5
- Feature flag for new architecture
- Ability to roll back to old code path
- Incremental rollout (dev → staging → production)

## Appendix A: Parameter Registry API

```typescript
// Registration
parameterRegistry.register({
  key: 'newParameter',
  // ... definition
})

// Queries
const def = parameterRegistry.get('center')
const all = parameterRegistry.getAll()
const exportable = parameterRegistry.getExportable()
const required = parameterRegistry.getRequired()
const relevant = parameterRegistry.getRelevant('CONIC')

// Validation
const result = parameterRegistry.validate('scale', 5000, 'CONIC')
if (!result.isValid) {
  console.error(result.error)
}

// Defaults
const defaults = parameterRegistry.getDefaults(territory, 'CONIC')
```

## Appendix B: Migration Examples

### Example 1: Creating CompositeProjection

**Before:**
```typescript
const composite = new CompositeProjection(config)
```

**After:**
```typescript
const parameterProvider = {
  getEffectiveParameters: (code: string) => {
    return parameterStore.getEffectiveParameters(code)
  }
}
const composite = new CompositeProjection(config, parameterProvider)
```

### Example 2: Exporting Configuration

**Before:**
```typescript
const exported = CompositeExportService.exportToJSON(
  composite,
  'france',
  'France'
)
```

**After:**
```typescript
const parameterStore = useParameterStore()
const exported = CompositeExportService.exportToJSON(
  composite,
  'france',
  'France',
  compositeConfig,
  parameterStore
)
```

### Example 3: Changing Territory Scale

**Before:**
```typescript
territoryStore.setTerritoryScale('FR-GP', 1.4)
composite.updateScale('FR-GP', 1.4)
```

**After:**
```typescript
parameterStore.setTerritoryParameter('FR-GP', 'scaleMultiplier', 1.4)
composite.updateTerritoryParameters('FR-GP')
```

### Example 4: Loading Preset

**Before:**
```typescript
const preset = await PresetLoader.loadPreset('france', 'default')
const params = PresetLoader.extractTerritoryParameters(preset)
Object.entries(params).forEach(([code, param]) => {
  parameterStore.setTerritoryParameters(code, param)
})
```

**After:**
```typescript
const result = await PresetLoader.loadPreset('france', 'default')
if (!result.success) {
  throw new Error(`Preset validation failed: ${result.errors.join(', ')}`)
}
const params = PresetLoader.extractTerritoryParameters(result.preset)
const errors = parameterStore.initializeFromPreset(atlasParams, params)
if (errors.length > 0) {
  console.warn('Parameter validation warnings:', errors)
}
```
