# Projection Parameters Lifecycle Analysis - Implementation Plan

## Objective
Conduct thorough analysis of projection parameters lifecycle from schema definition to UI rendering updates, identify improvements, cleaner patterns, missing features, unclarities and inconsistencies.

## Affected Domains 
- [ ] Projections (docs/projections.llm.txt) - Core parameter definitions and management
- [ ] Vue Architecture (docs/vue-architecture.llm.txt) - UI controls and reactive updates
- [ ] Services (docs/services.llm.txt) - Parameter application and transformation
- [ ] Atlas System (docs/atlases.llm.txt) - Default parameter configuration

## Context
- Architecture: docs/architecture.llm.txt
- Domain docs: docs/projections.llm.txt, docs/vue-architecture.llm.txt, docs/services.llm.txt
- Related: France preset configuration (configs/presets/france-default.json)

## Analysis Areas

### Phase 1: Schema and Type Definition Analysis
- [x] File: configs/presets/schema.json
  - Action: Analyze projection parameter schema validation
  - Why: Understand format constraints and validation rules
  - Impact: Foundation for all parameter handling

- [x] File: src/core/projections/types.ts
  - Action: Review ProjectionParameters interface and related types
  - Why: Core type definitions drive entire parameter system
  - Impact: Type safety and API consistency

- [x] File: src/core/projections/parameters.ts
  - Action: Examine parameter family mapping and relevance configuration
  - Why: Controls which parameters are available per projection family
  - Impact: UI control visibility and parameter application logic

### Phase 2: Parameter Default and Configuration Analysis
- [x] File: src/core/projections/definitions/*.ts
  - Action: Review defaultParameters in projection definitions
  - Why: Understand how default values are established
  - Impact: Initial parameter values and fallback behavior

- [x] File: src/core/atlases/loader.ts
  - Action: Analyze ProjectionParams interface and atlas-specific defaults
  - Why: Atlas-specific parameter overrides and regional customization
  - Impact: Atlas-aware parameter initialization

- [ ] File: configs/presets/france-default.json
  - Action: Examine actual parameter values in preset configuration
  - Why: Real-world parameter usage and export format
  - Impact: Understanding export/import parameter fidelity

### Phase 3: State Management and Reactive Updates Analysis
- [x] File: src/stores/config.ts
  - Action: Review projection parameter state management
  - Why: Central state for custom parameter overrides
  - Impact: Reactive updates and parameter persistence

- [x] File: src/composables/useProjectionConfig.ts
  - Action: Examine projection configuration composable
  - Why: Business logic for projection parameter handling
  - Impact: Component-store interaction patterns

### Phase 4: UI Controls and User Interaction Analysis
- [x] File: src/components/ui/projections/ProjectionParamsControls.vue
  - Action: Analyze parameter UI controls and binding patterns
  - Why: User interaction with projection parameters
  - Impact: UX consistency and parameter validation

- [x] File: src/components/MapRenderer.vue
  - Action: Review parameter application in rendering pipeline
  - Why: Parameter-to-rendering translation and updates
  - Impact: Visual feedback and rendering performance

### Phase 5: Service Layer Parameter Processing Analysis
- [x] File: src/services/projection/projection-service.ts
  - Action: Examine parameter application strategies
  - Why: Business logic for parameter-to-projection transformation
  - Impact: Projection creation accuracy and consistency

- [x] File: src/services/projection/composite-projection.ts
  - Action: Review composite projection parameter handling
  - Why: Complex multi-projection parameter coordination
  - Impact: Composite projection accuracy and territory positioning

### Phase 6: Export/Import Parameter Fidelity Analysis
- [x] File: src/services/export/composite-export-service.ts
  - Action: Analyze parameter serialization and export format
  - Why: Configuration export accuracy and completeness
  - Impact: Preset creation and sharing capabilities

- [x] File: src/services/export/composite-import-service.ts
  - Action: Review parameter import and validation
  - Why: Configuration import accuracy and error handling
  - Impact: Preset loading reliability and migration

## Key Analysis Questions
1. **Type Safety**: Are parameter types consistently defined and enforced?
2. **Default Hierarchy**: How do defaults flow from projection ‚Üí atlas ‚Üí custom overrides?
3. **Parameter Relevance**: Is family-based parameter filtering comprehensive and accurate?
4. **UI Consistency**: Do UI controls properly reflect parameter availability and constraints?
5. **Validation**: Are parameter values validated at appropriate boundaries?
6. **Performance**: Are parameter changes applied efficiently without unnecessary re-renders?
7. **Export Fidelity**: Do exported configurations capture all necessary parameter state?
8. **Error Handling**: How are invalid parameter values handled throughout the pipeline?

## Expected Findings
- Parameter definition inconsistencies between schema, types, and defaults
- Missing validation or constraint enforcement
- UI control availability mismatches with projection capabilities
- Performance bottlenecks in parameter change propagation
- Export/import parameter loss or transformation issues
- Unclear parameter precedence and override behavior

## Documentation Updates
Documentation will be updated to reflect analysis findings and recommended improvements:
- [x] docs/projections.llm.txt - Parameter system architecture and patterns
- [x] docs/vue-architecture.llm.txt - UI control patterns and reactive updates
- [x] docs/services.llm.txt - Parameter processing and application logic

## Verification
- [ ] All identified issues documented with examples
- [ ] Improvement recommendations prioritized by impact
- [ ] Missing features catalogued with use cases
- [ ] Pattern inconsistencies mapped with standardization proposals
- [ ] Performance implications assessed

## Status
Status: COMPLETE
Last Updated: 2025-01-14

## Analysis Findings

### Critical Issues Identified

#### 1. **Parameter Type Inconsistencies** ‚ö†Ô∏è
**Issue**: Multiple parameter interfaces with overlapping but incompatible definitions
- `ProjectionParameters` (core/projections/types.ts) - Generic D3 projection parameters
- `ExportedProjectionParameters` (types/export-config.ts) - Export format with required scale fields
- `ProjectionParams` (core/atlases/loader.ts) - Atlas-specific parameter structure

**Impact**: Type confusion, potential runtime errors, export/import fidelity issues
**Example**: `rotate` is optional `[number, number, number?]` in core but required `[number, number, number]` in export

#### 2. **Global vs Territory Parameter Pattern Duplication** üîÑ
**Issue**: No reusable patterns between global projection params and territory-specific params
- Global parameters: `configStore.effectiveProjectionParams` (single set)
- Territory parameters: Individual projection instances in `CompositeProjection`
- Parameter UI controls: Separate components with duplicated logic

**Impact**: Code duplication, inconsistent UX, maintenance burden
**Missing**: Unified parameter management system that can handle both global and per-territory parameters

#### 3. **Custom Composite Mode Parameter Controls Gap** üéØ
**Issue**: Limited parameter editing capabilities in composite-custom mode
- Territory projection selection: ‚úÖ Available via `TerritoryControls`
- Territory-specific projection parameters: ‚ùå **MISSING**
- Global parameter controls: Only shows when not in composite-custom mode
- Parameter inheritance: No clear pattern for territory-specific vs global parameters

**Impact**: Users cannot fine-tune individual territory projections in custom composite mode

### Missing Features & Improvements

#### A. **Territory-Specific Parameter Controls**
**Current State**: `TerritoryControls.vue` only provides:
- Projection type selection
- Translation controls (x, y)
- Scale multiplier controls

**Missing**: Per-territory projection parameter controls
- Center point adjustment
- Rotation controls (longitude, latitude)
- Parallel controls (for conic projections)
- Parameter inheritance from global settings

#### B. **Parameter Validation & Constraints**
**Current State**: Limited validation
- UI range controls have min/max bounds
- Schema validation only for export format
- No real-time parameter validation

**Missing**: Comprehensive validation
- Parameter compatibility with projection families
- Geographic bounds validation
- Parameter dependency validation (e.g., parallels order)

#### C. **Parameter Preview & Feedback**
**Current State**: Changes apply immediately to map
**Missing**: 
- Parameter impact preview
- Visual feedback for parameter changes
- Parameter conflict warnings
- Undo/redo for parameter changes

### Architectural Improvements

#### 1. **Unified Parameter Management System**
```typescript
// Proposed: Unified parameter manager
interface ProjectionParameterManager {
  // Global parameters
  getGlobalParameters(): ProjectionParameters
  setGlobalParameter(key: string, value: any): void
  
  // Territory-specific parameters (with inheritance)
  getTerritoryParameters(territoryCode: string): ProjectionParameters
  setTerritoryParameter(territoryCode: string, key: string, value: any): void
  
  // Parameter inheritance and overrides
  getTerritoryParameterSource(territoryCode: string, key: string): 'global' | 'territory' | 'default'
  clearTerritoryOverride(territoryCode: string, key: string): void
}
```

#### 2. **Reusable Parameter Control Components**
```vue
<!-- Proposed: Reusable parameter controls -->
<ProjectionParameterControls 
  :projection-family="projectionFamily"
  :parameters="parameters"
  :inherited-parameters="inheritedParameters"
  @update:parameter="handleParameterUpdate"
/>
```

#### 3. **Parameter Validation Pipeline**
```typescript
// Proposed: Parameter validation system
interface ParameterValidator {
  validateParameter(family: ProjectionFamily, key: string, value: any): ValidationResult
  validateParameterSet(family: ProjectionFamily, parameters: ProjectionParameters): ValidationResult[]
  getParameterConstraints(family: ProjectionFamily, key: string): ParameterConstraints
}
```

### Performance Issues

#### 1. **Reactive Update Cascades**
**Issue**: Parameter changes trigger multiple reactive updates
- `configStore.effectiveProjectionParams` recomputes on any parameter change
- `CompositeProjection.build()` rebuilds entire composite on territory parameter changes
- UI controls recompute values from multiple sources

**Solution**: Batched parameter updates, memoization of expensive computations

#### 2. **Export/Import Parameter Fidelity**
**Issue**: Parameter round-trip may lose precision or introduce inconsistencies
- Scale calculations: `scale = baseScale * scaleMultiplier` may accumulate errors
- Rotation array handling: Inconsistent between 2-element and 3-element arrays
- Parameter serialization: No validation of export completeness

### Custom Composite Mode Specific Issues

#### 1. **No Territory-Level Parameter Controls**
**Current**: Only projection type, translation, and scale
**Needed**: Full parameter controls per territory
- Center/rotation adjustment per territory
- Parallel controls for conic projections per territory
- Parameter inheritance from global settings

#### 2. **Parameter Inheritance Unclear**
**Issue**: No clear UI indication of parameter inheritance
- Which parameters come from global settings?
- Which are overridden at territory level?
- How to reset territory-specific overrides?

#### 3. **Parameter Export Completeness**
**Issue**: Territory-specific parameters may not be fully captured in export
- Custom center/rotation per territory
- Parameter inheritance relationships
- Territory-specific projection family settings