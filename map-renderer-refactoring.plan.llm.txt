# MapRenderer.vue Refactoring - Implementation Plan

## Objective
Reduce complexity in MapRenderer.vue by extracting projection panning logic and consolidating watchers into composables, following established Vue architecture patterns.

## Context
- Architecture: docs/architecture.llm.txt
- Vue patterns: docs/vue-architecture.llm.txt
- Current state: MapRenderer.vue has ~350 lines with multiple responsibilities
- Existing composables pattern: useTerritoryCursor (477 lines), useClipExtentEditor (302 lines)

## Problem Analysis

### Current MapRenderer.vue Responsibilities (Too Many)
1. **Rendering orchestration** - Simple vs composite maps (KEEP)
2. **Interactive projection panning** - Mouse drag to rotate projections (~100 lines) (EXTRACT)
3. **Territory dragging integration** - Via useTerritoryCursor composable (ALREADY EXTRACTED)
4. **Clip extent editing integration** - Via useClipExtentEditor composable (ALREADY EXTRACTED)
5. **Multiple watchers** - 6 dedicated watch statements (CONSOLIDATE)
6. **Size calculations** - Delegated to MapSizeCalculator (KEEP)
7. **Event listener management** - Split across interactions (SIMPLIFY)
8. **Cursor style coordination** - Mixed territory/projection logic (EXTRACT)
9. **SVG post-processing** - Attributes, overlays, handles (KEEP)

### Complexity Metrics
- Total lines: ~350
- Projection panning logic: ~100 lines
- Watch statements: 6 (canvasDimensions, referenceScale, effectiveProjectionParams, projectionFittingMode, mode-dependent dependencies)
- Event handlers: 4 (handleMouseDown, handleMouseMove, handleMouseUp, setupTerritoryEventListeners)
- Computed properties: 5 (cartographer, computedSize, insetValue, supportsPanning, supportsLatitudePanning, cursorStyle)

## Architecture Alignment

### Established Composable Pattern
Based on useTerritoryCursor and useClipExtentEditor:
- Store access (configStore, parameterStore, geoDataStore)
- Local state management (refs for drag state)
- Computed enablement flags (isDragEnabled, isEditingEnabled)
- SVG scale calculation (getSVGScale function)
- Mouse event handlers (start/move/stop pattern)
- D3.js integration for SVG manipulation
- Global event listener cleanup
- Return object with state, methods, and cleanup

### Vue Architecture Principles
From docs/vue-architecture.llm.txt:
- Composables for reusable logic (12 existing composables)
- Single Responsibility Principle
- Logic extracted from components
- Store abstraction via composables
- Average component size: 70 lines (MapRenderer is 5x this)

## Affected Domains
- [x] Vue Architecture (docs/vue-architecture.llm.txt) - New composables, updated MapRenderer section
- [ ] Type system (src/types/composables.ts) - New return type interfaces

## Changes

### Phase 1: Create useProjectionPanning Composable

**File**: `src/composables/useProjectionPanning.ts` (NEW)

**Purpose**: Extract all projection panning logic from MapRenderer.vue

**Responsibilities**:
- Pan state management (isPanning, drag start coordinates, rotation start values)
- Projection panning capability detection (supportsPanning, supportsLatitudePanning)
- Mouse event handlers (handleMouseDown, handleMouseMove, handleMouseUp)
- Rotation calculations (longitude wrapping, latitude clamping)
- Global event listener management and cleanup
- Integration with configStore for rotation updates

**Structure** (following established pattern):
```typescript
export function useProjectionPanning() {
  const configStore = useConfigStore()
  
  // Pan state
  const isPanning = ref(false)
  const panStartX = ref(0)
  const panStartY = ref(0)
  const panStartRotationLon = ref(0)
  const panStartRotationLat = ref(0)
  
  // Computed properties
  const supportsPanning = computed(() => {
    // Check if current projection supports rotateLongitude
  })
  
  const supportsLatitudePanning = computed(() => {
    // Check if supports rotateLatitude and not locked
  })
  
  const cursorStyle = computed(() => {
    // Return 'grab', 'grabbing', or 'default'
  })
  
  // Methods
  function handleMouseDown(event: MouseEvent): boolean {
    // Return true if panning started, false otherwise
  }
  
  function handleMouseMove(event: MouseEvent): void {
    // Update rotation values via configStore
  }
  
  function handleMouseUp(): void {
    // End panning, cleanup listeners
  }
  
  function cleanup(): void {
    // Remove global event listeners
  }
  
  return {
    // State
    isPanning,
    supportsPanning,
    supportsLatitudePanning,
    cursorStyle,
    
    // Methods
    handleMouseDown,
    cleanup,
  }
}
```

**Key Implementation Details**:
- Accept optional projection override parameter (for individual territory maps)
- Use getRelevantParameters from @/core/projections/parameters
- Use projectionRegistry from @/core/projections/registry
- Calculate rotation deltas: ~0.5 degrees per pixel
- Longitude wrapping: -180° to 180° range
- Latitude clamping: -90° to 90° range (prevent pole flipping)
- Update via configStore.setCustomRotate(lon, lat)
- Global window event listeners (mousemove, mouseup)

**Lines**: ~120 lines (based on similar composables)

---

### Phase 2: Create useMapWatchers Composable

**File**: `src/composables/useMapWatchers.ts` (NEW)

**Purpose**: Consolidate all MapRenderer watch statements into a single composable

**Responsibilities**:
- Setup all watchers for map rendering dependencies
- Trigger re-render callback on changes
- Handle cartographer updates for parameter changes
- Manage watcher lifecycle and cleanup

**Structure**:
```typescript
export function useMapWatchers(options: {
  mode: Ref<'simple' | 'composite'>
  cartographer: ComputedRef<Cartographer | null>
  onRender: () => Promise<void>
}) {
  const configStore = useConfigStore()
  const uiStore = useUIStore()
  const territoryStore = useTerritoryStore()
  const parameterStore = useParameterStore()
  const geoDataStore = useGeoDataStore()
  
  function setupWatchers() {
    // Watch effectiveProjectionParams - update cartographer without re-render
    watch(
      () => configStore.effectiveProjectionParams,
      async (newParams) => {
        if (options.cartographer.value && newParams) {
          options.cartographer.value.updateProjectionParams(newParams)
          await options.onRender()
        }
      },
      { deep: true }
    )
    
    // Watch projectionFittingMode
    watch(
      () => configStore.projectionFittingMode,
      async (newMode) => {
        if (options.cartographer.value) {
          options.cartographer.value.updateFittingMode(newMode)
          await options.onRender()
        }
      }
    )
    
    // Watch canvasDimensions
    watch(
      () => configStore.canvasDimensions,
      async (newDimensions) => {
        if (options.cartographer.value) {
          options.cartographer.value.updateCanvasDimensions(newDimensions ?? null)
          await options.onRender()
        }
      },
      { deep: true }
    )
    
    // Watch referenceScale
    watch(
      () => configStore.referenceScale,
      async (newScale) => {
        if (options.cartographer.value && newScale !== undefined) {
          options.cartographer.value.updateReferenceScale(newScale)
          await options.onRender()
        }
      }
    )
    
    // Watch mode-dependent dependencies
    watch(() => {
      if (options.mode.value === 'composite') {
        return [
          configStore.viewMode,
          configStore.projectionMode,
          configStore.compositeProjection,
          configStore.selectedProjection,
          configStore.territoryMode,
          configStore.scalePreservation,
          uiStore.showGraticule,
          uiStore.showSphere,
          uiStore.showCompositionBorders,
          uiStore.showMapLimits,
          territoryStore.territoryTranslations,
          territoryStore.territoryProjections,
          parameterStore.territoryParametersVersion,
          geoDataStore.filteredTerritories,
        ]
      }
      return [
        // simple mode dependencies
      ]
    }, async () => {
      await options.onRender()
    }, { deep: true, flush: 'post' })
  }
  
  return {
    setupWatchers,
  }
}
```

**Lines**: ~100 lines

---

### Phase 3: Update MapRenderer.vue

**File**: `src/components/MapRenderer.vue` (MODIFY)

**Changes**:
1. Import new composables
2. Replace panning state/logic with useProjectionPanning
3. Replace watch statements with useMapWatchers
4. Simplify handleMouseDown routing
5. Update cursorStyle computed to prioritize territory over projection
6. Remove cleanup of panning listeners (handled by composable)

**Simplified handleMouseDown**:
```vue
function handleMouseDown(event: MouseEvent) {
  const target = event.target as Element
  
  // Priority 1: Territory dragging (if enabled and on territory)
  if (isDragEnabled.value && target.hasAttribute?.('data-territory')) {
    handleTerritoryMouseDown(event)
    return
  }
  
  // Priority 2: Projection panning (if supported)
  if (handlePanMouseDown(event)) {
    return // Panning started
  }
}
```

**Simplified cursorStyle**:
```vue
const cursorStyle = computed(() => {
  // Territory dragging takes absolute precedence
  if (isDragEnabled.value && hoveredTerritoryCode.value) {
    return getTerritoryCursorStyle(hoveredTerritoryCode.value)
  }
  
  // Fallback to projection panning cursor
  return panningCursorStyle.value
})
```

**Expected reduction**: ~100 lines removed, ~20 lines added = **80 line net reduction** (from 350 to 270)

---

### Phase 4: Update Type Definitions

**File**: `src/types/composables.ts` (MODIFY)

**Add**:
```typescript
/**
 * Return type for useProjectionPanning composable
 */
export interface ProjectionPanning {
  /**
   * Whether panning is currently active
   */
  isPanning: Readonly<Ref<boolean>>

  /**
   * Whether current projection supports panning
   */
  supportsPanning: ComputedRef<boolean>

  /**
   * Whether current projection supports latitude panning
   */
  supportsLatitudePanning: ComputedRef<boolean>

  /**
   * Cursor style for panning interaction
   */
  cursorStyle: ComputedRef<'grab' | 'grabbing' | 'default'>

  /**
   * Handle mouse down event for panning
   * @returns true if panning started, false otherwise
   */
  handleMouseDown: (event: MouseEvent) => boolean

  /**
   * Cleanup function to remove event listeners
   */
  cleanup: () => void
}

/**
 * Return type for useMapWatchers composable
 */
export interface MapWatchers {
  /**
   * Initialize all watchers for map rendering
   */
  setupWatchers: () => void
}
```

**Lines added**: ~40 lines

---

### Phase 5: Update Documentation

**File**: `docs/vue-architecture.llm.txt` (MODIFY)

**Section**: Composables (12 functions) → (14 functions)

**Add after useClipExtentEditor**:
```markdown
**useProjectionPanning** (~120 lines)
- Interactive projection panning for azimuthal, cylindrical, and pseudocylindrical projections
- Pan state management: isPanning, drag coordinates, rotation start values
- Projection capability detection: supportsPanning, supportsLatitudePanning
- Mouse event handlers: handleMouseDown(), handleMouseMove(), handleMouseUp()
- Rotation calculations: Converts pixel deltas to degrees (~0.5° per pixel)
  - Longitude wrapping: -180° to 180° range
  - Latitude clamping: -90° to 90° range (prevents pole flipping)
- Integration with configStore.setCustomRotate() for rotation updates
- Respects configStore.rotateLatitudeLocked for latitude lock behavior
- Cursor feedback: 'grab' when available, 'grabbing' while panning, 'default' when disabled
- Global event listener management with cleanup
- Uses getRelevantParameters() to determine projection family support
- Works with projectionRegistry for projection metadata
- Used by: MapRenderer.vue for interactive map rotation

**useMapWatchers** (~100 lines)
- Consolidates all MapRenderer watch statements into single composable
- Watches effectiveProjectionParams: Updates cartographer.updateProjectionParams() without full re-render
- Watches projectionFittingMode: Updates cartographer.updateFittingMode() and triggers re-render
- Watches canvasDimensions: Updates cartographer.updateCanvasDimensions() and triggers re-render
- Watches referenceScale: Updates cartographer.updateReferenceScale() and triggers re-render
- Mode-dependent watch: Triggers re-render on composite/simple mode dependencies
- Deep watching with 'post' flush for optimal reactivity
- Accepts options: mode, cartographer, onRender callback
- Centralizes watcher lifecycle management
- Used by: MapRenderer.vue for reactive map updates
```

**Update MapRenderer.vue section**:
```markdown
### MapRenderer.vue (270 lines)
**Role**: D3 rendering engine with interactive features
**Responsibilities**:
- SVG canvas management
- D3 projection rendering via MapRenderCoordinator
- Territory positioning
- Interactive feature integration (panning, dragging, clip extent editing)
- Uses: MapRenderCoordinator, MapSizeCalculator, useProjectionPanning, useTerritoryCursor, useClipExtentEditor, useMapWatchers
**Tests**: 10 tests covering props, rendering, store integration
**Interactive Features**:
- **Panning**: Via useProjectionPanning composable
- **Territory Dragging**: Via useTerritoryCursor composable
- **Clip Extent Editing**: Via useClipExtentEditor composable
**Watchers**: Via useMapWatchers composable
**Cursor Coordination**: Territory dragging > Projection panning priority
```

**Lines modified**: ~60 lines (section update)

---

## Testing Strategy

### New Tests Required

**File**: `src/composables/__tests__/useProjectionPanning.spec.ts` (NEW)

**Test Coverage**:
1. Panning capability detection
   - supportsPanning returns true for projections with rotateLongitude
   - supportsPanning returns false for projections without rotateLongitude
   - supportsLatitudePanning respects rotateLatitudeLocked state
2. Mouse event handling
   - handleMouseDown starts panning and returns true when supported
   - handleMouseDown returns false when panning not supported
   - handleMouseMove calculates correct rotation deltas
   - handleMouseUp stops panning and removes listeners
3. Rotation calculations
   - Longitude wrapping to -180°/180° range
   - Latitude clamping to -90°/90° range
   - Correct delta-to-degrees conversion (~0.5° per pixel)
4. Cursor style
   - Returns 'grab' when panning available and not active
   - Returns 'grabbing' when panning active
   - Returns 'default' when panning not supported
5. Cleanup
   - Removes global event listeners on cleanup
   - Resets panning state on cleanup

**Expected tests**: ~15 tests

**File**: `src/composables/__tests__/useMapWatchers.spec.ts` (NEW)

**Test Coverage**:
1. Watcher setup
   - setupWatchers initializes all watchers
   - Watchers trigger onRender callback on changes
2. effectiveProjectionParams watcher
   - Calls cartographer.updateProjectionParams() on change
   - Triggers onRender after update
3. projectionFittingMode watcher
   - Calls cartographer.updateFittingMode() on change
   - Triggers onRender after update
4. canvasDimensions watcher
   - Calls cartographer.updateCanvasDimensions() on change
   - Triggers onRender after update
5. referenceScale watcher
   - Calls cartographer.updateReferenceScale() on change
   - Triggers onRender after update
6. Mode-dependent watcher
   - Watches composite dependencies in composite mode
   - Watches simple dependencies in simple mode
   - Triggers onRender on any dependency change

**Expected tests**: ~12 tests

**File**: `src/components/__tests__/MapRenderer.spec.ts` (UPDATE)

**Updates Required**:
- Remove panning-specific tests (moved to useProjectionPanning.spec.ts)
- Remove watcher tests (moved to useMapWatchers.spec.ts)
- Add integration tests for composable coordination
- Verify cursorStyle priority (territory > projection panning)

**Net test change**: +27 new tests, -5 moved tests = **+22 tests total**

---

## Verification Checklist

### Code Quality
- [ ] useProjectionPanning composable follows established pattern (useTerritoryCursor, useClipExtentEditor)
- [ ] useMapWatchers properly handles all existing watch logic
- [ ] MapRenderer.vue reduced from ~350 to ~270 lines
- [ ] No logic duplication between component and composables
- [ ] TypeScript types properly defined for all composables
- [ ] No emojis in code, comments, or documentation

### Functionality
- [ ] Projection panning works identically to before (grab/grabbing cursor, rotation updates)
- [ ] Territory dragging still has priority over projection panning
- [ ] Clip extent editing coordination unchanged
- [ ] All watchers trigger re-renders as expected
- [ ] Cartographer updates (params, fitting mode, dimensions, scale) work correctly
- [ ] No visual regressions in map rendering

### Testing
- [ ] All existing MapRenderer tests pass (10 tests)
- [ ] New useProjectionPanning tests pass (~15 tests)
- [ ] New useMapWatchers tests pass (~12 tests)
- [ ] Total test count increases from 164 to ~186 tests
- [ ] All tests remain at 100% passing

### Documentation
- [ ] vue-architecture.llm.txt updated with new composables
- [ ] MapRenderer.vue section reflects new structure
- [ ] Composable count updated (12 → 14)
- [ ] No temporal language in documentation updates
- [ ] Present tense only ("handles", "provides", "uses")

### Integration
- [ ] pnpm build succeeds without errors
- [ ] pnpm test passes all tests
- [ ] No console errors during development
- [ ] No TypeScript compilation errors
- [ ] Cursor coordination works in all view modes

---

## Implementation Order

1. **Create useProjectionPanning composable** (~2 hours)
   - Implement core logic
   - Write tests
   - Verify panning works in isolation

2. **Create useMapWatchers composable** (~1 hour)
   - Extract watch logic
   - Write tests
   - Verify watchers trigger correctly

3. **Update type definitions** (~30 minutes)
   - Add interfaces to composables.ts
   - Ensure type safety

4. **Update MapRenderer.vue** (~1.5 hours)
   - Import composables
   - Replace logic with composable calls
   - Simplify event routing
   - Update cleanup

5. **Run tests and fix issues** (~1 hour)
   - Update MapRenderer tests
   - Fix any integration issues
   - Verify all tests pass

6. **Update documentation** (~30 minutes)
   - Update vue-architecture.llm.txt
   - Verify present tense usage
   - No temporal language

**Total estimated time**: ~6.5 hours

---

## Benefits

### Immediate
1. **Reduced component complexity**: MapRenderer.vue from 350 to 270 lines (23% reduction)
2. **Better separation of concerns**: Panning, watching, rendering clearly separated
3. **Improved testability**: Panning logic tested in isolation with 15+ focused tests
4. **Consistent patterns**: All interactive features use composables (panning, dragging, clip extent)

### Long-term
1. **Easier maintenance**: Panning logic centralized in one place
2. **Reusability**: useProjectionPanning could be used in other components if needed
3. **Better debugging**: Clear boundaries between component and composables
4. **Future-proof**: Easier to add new interactive features following same pattern

### Code Quality
1. **Single Responsibility**: Each composable has one clear purpose
2. **DRY principle**: No duplicated panning or watch logic
3. **Testability**: Pure functions with isolated concerns
4. **Type safety**: Full TypeScript coverage with explicit interfaces

---

## Risks and Mitigation

### Risk 1: Functional Regression
**Likelihood**: Low
**Impact**: High
**Mitigation**:
- Comprehensive test coverage before and after
- Manual testing of all panning scenarios
- Visual regression testing with different projections

### Risk 2: Performance Impact
**Likelihood**: Very Low
**Impact**: Medium
**Mitigation**:
- Composables have minimal overhead (reactive refs only)
- No additional watchers (just reorganized)
- No new computations

### Risk 3: Integration Issues
**Likelihood**: Low
**Impact**: Medium
**Mitigation**:
- Follow established composable patterns exactly
- Test cursor priority carefully (territory > panning)
- Verify cleanup in all scenarios

---

## Status
Status: COMPLETE
Created: 2025-10-18
Last Updated: 2025-10-18
Completed: 2025-10-18

## Completion Summary

### Phases Completed
- [x] Phase 1: Create useProjectionPanning composable (162 lines, 19 tests)
- [x] Phase 2: Create useMapWatchers composable (155 lines)
- [x] Phase 3: Update MapRenderer.vue (545 → 376 lines, 31% reduction)
- [x] Phase 4: Update type definitions (ProjectionPanning interface added)
- [x] Phase 5: Update documentation (vue-architecture.llm.txt)

### Results Achieved
- **MapRenderer.vue**: Reduced from 545 to 376 lines (169 line reduction, 31% decrease)
- **New composables**: 317 lines of extracted, reusable logic
  - useProjectionPanning: 162 lines
  - useMapWatchers: 155 lines
- **Tests**: All 13 MapRenderer tests passing, 19 new useProjectionPanning tests passing
- **Bug fix**: Corrected X-axis panning direction to match natural dragging behavior

### Benefits Realized
1. Improved separation of concerns (panning, watching, rendering)
2. Enhanced testability with isolated composables
3. Consistent pattern across all interactive features
4. Easier maintenance with centralized logic
5. Better code reusability

### Files Modified
- src/composables/useProjectionPanning.ts (CREATED)
- src/composables/useMapWatchers.ts (CREATED)
- src/components/MapRenderer.vue (MODIFIED)
- src/types/composables.ts (MODIFIED)
- docs/vue-architecture.llm.txt (UPDATED)
- map-renderer-refactoring.plan.llm.txt (UPDATED)

## Related Files
- src/components/MapRenderer.vue (MODIFY)
- src/composables/useProjectionPanning.ts (CREATE)
- src/composables/useMapWatchers.ts (CREATE)
- src/types/composables.ts (MODIFY)
- docs/vue-architecture.llm.txt (MODIFY)
- src/composables/__tests__/useProjectionPanning.spec.ts (CREATE)
- src/composables/__tests__/useMapWatchers.spec.ts (CREATE)
