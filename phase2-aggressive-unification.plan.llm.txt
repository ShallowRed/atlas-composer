# Phase 2: Aggressive Unification Plan

## Objective
Maximize code reuse and simplification without backward compatibility constraints. Unify the two preset systems into a single, coherent architecture.

## Context
- Phase 1 complete: Shared utilities in place
- No users: Can break internal APIs freely
- Must preserve: Export format, round-trip fidelity, external reusability

## Aggressive Refactoring Strategy

### 1. Unify Type Hierarchy

**Current State**: Duplicate types for similar concepts
- `PresetLoadResult` vs `ViewPresetLoadResult`
- `ExtendedPresetConfig` vs `ViewModePreset`
- Separate error/warning structures

**Target State**: Single type hierarchy
```typescript
// src/core/presets/types.ts
interface LoadResult<T> {
  success: boolean
  data?: T
  errors: string[]
  warnings: string[]
}

interface PresetMetadata {
  id: string
  name: string | Record<string, string>
  description?: string | Record<string, string>
  atlasId: string
}

interface BasePreset {
  metadata: PresetMetadata
  version: string
}

interface CompositePreset extends BasePreset {
  type: 'composite'
  pattern: 'single-focus' | 'equal-members'
  referenceScale: number
  canvasDimensions?: { width: number, height: number }
  territories: TerritoryConfig[]
}

interface ViewPreset extends BasePreset {
  type: 'view'
  viewMode: 'unified' | 'split' | 'composite-existing'
  config: UnifiedViewConfig | SplitViewConfig | CompositeExistingViewConfig
}

type Preset = CompositePreset | ViewPreset
```

**Actions**:
- [ ] Create unified type hierarchy in `types.ts`
- [ ] Update all loaders to return `LoadResult<Preset>`
- [ ] Remove duplicate result types
- [ ] Update all consumers (no bridge code)

### 2. Consolidate Loaders

**Current State**: Two separate loader classes
- `PresetLoader` - loads composite presets
- `ViewPresetLoader` - loads view presets
- Duplicate registry loading
- Separate caching strategies

**Target State**: Single unified loader
```typescript
// src/services/presets/preset-loader.ts
class PresetLoader {
  private static compositeRegistry: Registry | null = null
  private static viewRegistry: Registry | null = null
  
  // Unified interface
  static async load(presetId: string): Promise<LoadResult<Preset>>
  static async listAvailable(atlasId?: string, type?: PresetType): Promise<PresetMetadata[]>
  static async getMetadata(presetId: string): Promise<PresetMetadata | null>
  
  // Type-specific helpers (private)
  private static async loadComposite(presetId: string): Promise<LoadResult<CompositePreset>>
  private static async loadView(presetId: string): Promise<LoadResult<ViewPreset>>
}
```

**Actions**:
- [ ] Merge loaders into single `PresetLoader` class
- [ ] Combine registries into unified structure
- [ ] Single caching mechanism
- [ ] Delete `ViewPresetLoader` (fold functionality)
- [ ] Update all imports (breaking change, OK)

### 3. Unified Registry Format

**Current State**: Two separate registry files
- `configs/presets/registry.json` - composite presets
- `configs/view-presets/registry.json` - view presets

**Target State**: Single unified registry
```json
// configs/presets/registry.json
{
  "version": "1.0",
  "presets": [
    {
      "id": "france-default",
      "type": "composite",
      "atlasId": "france",
      "name": { "en": "...", "fr": "..." },
      "viewMode": "composite-custom"
    },
    {
      "id": "france-unified-default",
      "type": "view",
      "atlasId": "france",
      "viewMode": "unified",
      "name": { "en": "...", "fr": "..." }
    }
  ]
}
```

**Actions**:
- [ ] Merge both registries into single file
- [ ] Add `type` field to distinguish preset types
- [ ] Update loader to handle unified registry
- [ ] Move view presets to `configs/presets/` directory
- [ ] Delete `configs/view-presets/` directory

### 4. Create Unified Application Service

**Current State**: Scattered application logic
- `configStore.applyUnifiedPreset()`
- `configStore.applySplitPreset()`
- `configStore.applyCompositeExistingPreset()`
- `AtlasCoordinator.handleAtlasChange()`

**Target State**: Single service with strategy pattern
```typescript
// src/services/presets/preset-application-service.ts
class PresetApplicationService {
  /**
   * Apply any preset type to stores
   * Uses strategy pattern internally
   */
  static apply(
    preset: Preset,
    stores: {
      config: ConfigStore
      parameter: ParameterStore
      territory: TerritoryStore
      ui: UIStore
    }
  ): ApplicationResult {
    // Strategy pattern based on preset.type
    if (preset.type === 'composite') {
      return this.applyComposite(preset, stores)
    } else {
      return this.applyView(preset, stores)
    }
  }
  
  private static applyComposite(...)
  private static applyView(...) {
    // Sub-strategy based on viewMode
    switch (preset.viewMode) {
      case 'unified': return this.applyUnified(...)
      case 'split': return this.applySplit(...)
      case 'composite-existing': return this.applyCompositeExisting(...)
    }
  }
}
```

**Actions**:
- [ ] Create `PresetApplicationService`
- [ ] Move all application logic from stores to service
- [ ] Delete mode-specific apply methods from stores
- [ ] Update stores to call unified service
- [ ] Update AtlasCoordinator to use service

### 5. Simplify Store APIs

**Current State**: Inconsistent naming and patterns
- `initializeWithPresetMetadata()`
- `loadViewPreset()`
- `setTerritoryProjection()` vs `setTerritoryParameter()`

**Target State**: Consistent, clear naming
```typescript
// configStore
- loadPreset(presetId: string)  // replaces initializeWithPresetMetadata, loadViewPreset
- applyPreset(preset: Preset)    // uses PresetApplicationService
- resetToPreset()                // unified reset

// parameterStore  
- set(territoryCode, key, value)  // replaces setTerritoryParameter
- setProjection(territoryCode, projectionId)  // replaces setTerritoryProjection
- clear(territoryCode)  // replaces clearAllTerritoryOverrides
```

**Actions**:
- [ ] Rename store methods for consistency
- [ ] Remove redundant methods
- [ ] Update all call sites (breaking OK)
- [ ] Simplify initialization sequence

### 6. Consolidate Validators

**Current State**: Separate validation functions
- `validateCompositePreset()` - complex, uses ImportService
- `validateViewPreset()` - simpler validation
- Different validation patterns

**Target State**: Unified validation with strategy
```typescript
// src/core/presets/validator.ts
function validatePreset(preset: unknown): ValidationResult<Preset> {
  // Common validation (version, atlasId, etc.)
  const commonResult = validateCommon(preset)
  
  // Type-specific validation
  if (preset.type === 'composite') {
    return validateComposite(preset, commonResult)
  } else {
    return validateView(preset, commonResult)
  }
}
```

**Actions**:
- [ ] Create unified `validatePreset()` function
- [ ] Extract common validation
- [ ] Use strategy for type-specific validation
- [ ] Remove duplicate validation code

### 7. Modernize Components

**Current State**: Separate components per preset type
- `PresetSelector.vue` - only for composite presets
- No UI for view preset selection

**Target State**: Unified preset selector
```vue
<!-- src/components/ui/presets/PresetSelector.vue -->
<template>
  <select v-model="selectedPresetId">
    <optgroup
      v-for="group in groupedPresets"
      :label="group.label"
    >
      <option
        v-for="preset in group.presets"
        :value="preset.id"
      >
        {{ preset.name }}
      </option>
    </optgroup>
  </select>
</template>

<script>
// Groups presets by type (composite vs view)
// Works for all view modes
// Shows metadata on hover
</script>
```

**Actions**:
- [ ] Create unified PresetSelector component
- [ ] Add preset type grouping
- [ ] Add metadata preview
- [ ] Replace all mode-specific selectors
- [ ] Add to all view modes (not just composite-custom)

## Breaking Changes Summary

### Method Renames (No Deprecation)

**ConfigStore**:
- `initializeWithPresetMetadata()` → `loadPreset()`
- `loadViewPreset()` → `applyPreset()`
- `applyUnifiedPreset()` → removed (use `applyPreset()`)
- `applySplitPreset()` → removed (use `applyPreset()`)
- `applyCompositeExistingPreset()` → removed (use `applyPreset()`)

**ParameterStore**:
- `setTerritoryParameter()` → `set()`
- `setTerritoryProjection()` → `setProjection()`
- `clearAllTerritoryOverrides()` → `clear()`

**Loaders**:
- `PresetLoader.loadPreset()` → `PresetLoader.load()`
- `ViewPresetLoader.*` → deleted, merged into `PresetLoader`

### Type Renames

- `PresetLoadResult` → `LoadResult<CompositePreset>`
- `ViewPresetLoadResult` → `LoadResult<ViewPreset>`
- `ExtendedPresetConfig` → `CompositePreset`
- `ViewModePreset` → `ViewPreset`

### File Moves

- `src/services/presets/view-preset-loader.ts` → deleted
- `configs/view-presets/*` → `configs/presets/`
- `configs/view-presets/registry.json` → merged into `configs/presets/registry.json`

## Implementation Order

1. **Types First** - Unify type hierarchy
2. **Loaders** - Merge loaders, consolidate registries
3. **Validators** - Unified validation
4. **Application Service** - Create unified application service
5. **Stores** - Update and rename store methods
6. **Components** - Modernize UI components
7. **Clean Up** - Delete old files, remove dead code

## Testing Strategy

- Update existing tests to use new APIs (breaking OK)
- No backward compatibility tests needed
- Focus on round-trip fidelity tests
- Verify export format unchanged

## Success Metrics

- **Code Reduction**: 40-50% reduction in preset code
- **Single Apply Path**: One method applies all preset types
- **Unified Registry**: Single file lists all presets
- **Consistent Naming**: All stores use same naming patterns
- **Test Coverage**: Maintain 100% pass rate
- **Export Format**: Unchanged, verified by round-trip tests

## Status
Status: PLANNED
Last Updated: 2025-10-19
