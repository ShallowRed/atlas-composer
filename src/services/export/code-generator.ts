import type {
  CodeGenerationOptions,
  ExportedCompositeConfig,
} from '@/types/export-config'

export class CodeGenerator {
  generate(config: ExportedCompositeConfig, options: CodeGenerationOptions): string {
    if (options.format === 'd3') {
      if (options.language === 'typescript') {
        return this.generateD3TypeScript(config, options)
      }
      return this.generateD3JavaScript(config, options)
    }
    else if (options.format === 'plot') {
      return this.generatePlotCode(config, options)
    }

    throw new Error(`Unsupported format: ${options.format}`)
  }

  private generateD3JavaScript(
    config: ExportedCompositeConfig,
    options: CodeGenerationOptions,
  ): string {
    const lines: string[] = []

    lines.push(this.generateHeader(config, 'JavaScript'))
    lines.push('')

    lines.push(this.generateD3Imports(config, false))
    lines.push('')

    lines.push(this.generateD3ProjectionFunction(config, false))
    lines.push('')

    if (options.includeExamples) {
      lines.push(this.generateD3UsageExample(config))
    }

    return lines.join('\n')
  }

  private generateD3TypeScript(
    config: ExportedCompositeConfig,
    options: CodeGenerationOptions,
  ): string {
    const lines: string[] = []

    lines.push(this.generateHeader(config, 'TypeScript'))
    lines.push('')

    lines.push(this.generateD3Imports(config, true))
    lines.push('')

    lines.push(this.generateD3ProjectionFunction(config, true))
    lines.push('')

    if (options.includeExamples) {
      lines.push(this.generateD3UsageExample(config))
    }

    return lines.join('\n')
  }

  private generatePlotCode(
    config: ExportedCompositeConfig,
    options: CodeGenerationOptions,
  ): string {
    const lines: string[] = []

    lines.push(this.generateHeader(config, 'Observable Plot'))
    lines.push('')

    lines.push('import * as Plot from "@observablehq/plot";')
    lines.push('import * as d3 from "d3";')
    lines.push('import { loadCompositeProjection, registerProjection } from "@atlas-composer/projection-loader";')
    lines.push('')

    lines.push(this.generatePlotProjectionFunction(config))
    lines.push('')

    if (options.includeExamples) {
      lines.push(this.generatePlotUsageExample(config))
    }

    return lines.join('\n')
  }

  private generateHeader(config: ExportedCompositeConfig, language: string): string {
    const lines = [
      '/**',
      ` * Composite Projection for ${config.metadata.atlasName}`,
      ` * Generated by ${config.metadata.createdWith}`,
      ` * Export date: ${new Date(config.metadata.exportDate).toLocaleDateString()}`,
    ]

    if (config.metadata.notes) {
      lines.push(` * ${config.metadata.notes}`)
    }

    lines.push(' *')
    lines.push(` * Territories: ${config.territories.map(t => t.name).join(', ')}`)
    lines.push(` * Language: ${language}`)
    lines.push(' */')

    return lines.join('\n')
  }

  private generateD3Imports(config: ExportedCompositeConfig, typescript: boolean): string {
    const lines: string[] = []
    const projections = new Set<string>()

    config.territories.forEach((territory) => {
      projections.add(this.getD3ProjectionFunction(territory.projection.id))
    })

    const imports = Array.from(projections).sort()

    if (typescript) {
      lines.push(`import { ${imports.join(', ')} } from 'd3-geo';`)
    }
    else {
      lines.push(`import { ${imports.join(', ')} } from 'd3-geo';`)
    }

    const loaderImports = typescript
      ? 'loadCompositeProjection, registerProjection, type ProjectionLike'
      : 'loadCompositeProjection, registerProjection'

    lines.push(`import { ${loaderImports} } from '@atlas-composer/projection-loader';`)

    return lines.join('\n')
  }

  private generateD3ProjectionFunction(
    config: ExportedCompositeConfig,
    typescript: boolean,
  ): string {
    const lines: string[] = []
    const returnType = typescript ? ': ProjectionLike' : ''

    lines.push(`export function create${this.toPascalCase(config.metadata.atlasId)}Projection()${returnType} {`)

    lines.push(...this.generateProjectionRegistration(config))

    lines.push(...this.generateCompositeLoading(config))

    lines.push('}')

    return lines.join('\n')
  }

  private generateProjectionRegistration(
    config: ExportedCompositeConfig,
  ): string[] {
    const lines: string[] = []
    const projections = new Set<string>()
    const projectionIdToD3: Map<string, string> = new Map()

    config.territories.forEach((territory) => {
      const d3FuncName = this.getD3ProjectionFunction(territory.projection.id)
      projections.add(territory.projection.id)
      projectionIdToD3.set(territory.projection.id, d3FuncName)
    })

    Array.from(projections).sort().forEach((projectionId) => {
      const d3FuncName = projectionIdToD3.get(projectionId)
      lines.push(`  registerProjection('${projectionId}', () => ${d3FuncName}());`)
    })

    lines.push('')

    return lines
  }

  private generateCompositeLoading(
    config: ExportedCompositeConfig,
  ): string[] {
    const lines: string[] = []

    lines.push(`  const config = ${JSON.stringify(config, null, 2).split('\n').join('\n  ')};`)
    lines.push('')
    lines.push('  const projection = loadCompositeProjection(config, {')
    lines.push('    width: 800,')
    lines.push('    height: 600')
    lines.push('  });')
    lines.push('')
    lines.push('  return projection;')

    return lines
  }

  private generateD3UsageExample(config: ExportedCompositeConfig): string {
    const lines: string[] = []
    const funcName = `create${this.toPascalCase(config.metadata.atlasId)}Projection`

    lines.push('/**')
    lines.push(' * Usage Example')
    lines.push(' *')
    lines.push(' * The generated function handles projection registration and loading automatically.')
    lines.push(' * Simply call the function and use the returned projection with D3.')
    lines.push(' */')
    lines.push('/*')
    lines.push(`const projection = ${funcName}();`)
    lines.push('')
    lines.push('const path = d3.geoPath(projection);')
    lines.push('')
    lines.push('svg.selectAll("path")')
    lines.push('  .data(features)')
    lines.push('  .join("path")')
    lines.push('  .attr("d", path)')
    lines.push('  .attr("fill", "lightgray")')
    lines.push('  .attr("stroke", "white");')
    lines.push('*/')

    return lines.join('\n')
  }

  private generatePlotProjectionFunction(
    config: ExportedCompositeConfig,
  ): string {
    const lines: string[] = []
    const funcName = `create${this.toPascalCase(config.metadata.atlasId)}Projection`

    lines.push(`export function ${funcName}() {`)

    lines.push(...this.generateProjectionRegistration(config))

    lines.push(`  const config = ${JSON.stringify(config, null, 2).split('\n').join('\n  ')};`)
    lines.push('')
    lines.push('  return ({ width = 800, height = 600 }) => {')
    lines.push('    return loadCompositeProjection(config, { width, height });')
    lines.push('  };')
    lines.push('}')

    return lines.join('\n')
  }

  private generatePlotUsageExample(config: ExportedCompositeConfig): string {
    const lines: string[] = []
    const funcName = `create${this.toPascalCase(config.metadata.atlasId)}Projection`

    lines.push('/**')
    lines.push(' * Usage Example with Observable Plot')
    lines.push(' *')
    lines.push(' * The generated function returns a Plot-compatible projection factory.')
    lines.push(' * Observable Plot will call it with { width, height } to build the projection.')
    lines.push(' */')
    lines.push('/*')
    lines.push(`const projectionFn = ${funcName}();`)
    lines.push('')
    lines.push('Plot.plot({')
    lines.push('  width: 975,')
    lines.push('  height: 610,')
    lines.push('  projection: projectionFn,')
    lines.push('  marks: [')
    lines.push('    Plot.geo(countries, {')
    lines.push('      fill: "lightgray",')
    lines.push('      stroke: "white",')
    lines.push('      strokeWidth: 0.5')
    lines.push('    }),')
    lines.push('    Plot.sphere()')
    lines.push('  ]')
    lines.push('});')
    lines.push('*/')

    return lines.join('\n')
  }

  private getD3ProjectionFunction(projectionId: string): string {
    const mapping: Record<string, string> = {
      'conic-conformal': 'geoConicConformal',
      'conic-equal-area': 'geoConicEqualArea',
      'conic-equidistant': 'geoConicEquidistant',
      'mercator': 'geoMercator',
      'transverse-mercator': 'geoTransverseMercator',
      'azimuthal-equal-area': 'geoAzimuthalEqualArea',
      'azimuthal-equidistant': 'geoAzimuthalEquidistant',
      'orthographic': 'geoOrthographic',
      'stereographic': 'geoStereographic',
      'gnomonic': 'geoGnomonic',
      'equirectangular': 'geoEquirectangular',
      'natural-earth': 'geoNaturalEarth1',
    }

    return mapping[projectionId] || 'geoMercator'
  }

  private toPascalCase(str: string): string {
    return str
      .split(/[-_\s]/)
      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join('')
  }
}

export function generateCode(
  config: ExportedCompositeConfig,
  options: CodeGenerationOptions,
): string {
  const generator = new CodeGenerator()
  return generator.generate(config, options)
}
