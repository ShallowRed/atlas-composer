import type {
  CodeGenerationOptions,
  ExportedCompositeConfig,
  ExportedTerritory,
} from '@/types/export-config'

/**
 * Generates executable code from exported composite projection configuration
 * Supports D3.js (JavaScript/TypeScript) and Observable Plot code generation
 */
export class CodeGenerator {
  /**
   * Generate code based on options
   */
  generate(config: ExportedCompositeConfig, options: CodeGenerationOptions): string {
    if (options.format === 'd3') {
      if (options.language === 'typescript') {
        return this.generateD3TypeScript(config, options)
      }
      return this.generateD3JavaScript(config, options)
    }
    else if (options.format === 'plot') {
      return this.generatePlotCode(config, options)
    }

    throw new Error(`Unsupported format: ${options.format}`)
  }

  /**
   * Generate D3.js JavaScript code
   */
  private generateD3JavaScript(
    config: ExportedCompositeConfig,
    options: CodeGenerationOptions,
  ): string {
    const lines: string[] = []

    // Add header comment
    lines.push(this.generateHeader(config, 'JavaScript'))
    lines.push('')

    // Add imports
    lines.push(this.generateD3Imports(config, false))
    lines.push('')

    // Generate projection function
    lines.push(this.generateD3ProjectionFunction(config, options, false))
    lines.push('')

    // Add usage example if requested
    if (options.includeExamples) {
      lines.push(this.generateD3UsageExample(config))
    }

    return lines.join('\n')
  }

  /**
   * Generate D3.js TypeScript code
   */
  private generateD3TypeScript(
    config: ExportedCompositeConfig,
    options: CodeGenerationOptions,
  ): string {
    const lines: string[] = []

    // Add header comment
    lines.push(this.generateHeader(config, 'TypeScript'))
    lines.push('')

    // Add imports
    lines.push(this.generateD3Imports(config, true))
    lines.push('')

    // Generate projection function
    lines.push(this.generateD3ProjectionFunction(config, options, true))
    lines.push('')

    // Add usage example if requested
    if (options.includeExamples) {
      lines.push(this.generateD3UsageExample(config))
    }

    return lines.join('\n')
  }

  /**
   * Generate Observable Plot code
   */
  private generatePlotCode(
    config: ExportedCompositeConfig,
    options: CodeGenerationOptions,
  ): string {
    const lines: string[] = []

    // Add header comment
    lines.push(this.generateHeader(config, 'Observable Plot'))
    lines.push('')

    // Add imports
    lines.push('import * as Plot from "@observablehq/plot";')
    lines.push('import * as d3 from "d3";')
    lines.push('')

    // Generate projection function
    lines.push(this.generatePlotProjectionFunction(config, options))
    lines.push('')

    // Add usage example if requested
    if (options.includeExamples) {
      lines.push(this.generatePlotUsageExample(config))
    }

    return lines.join('\n')
  }

  /**
   * Generate header comment
   */
  private generateHeader(config: ExportedCompositeConfig, language: string): string {
    const lines = [
      '/**',
      ` * Composite Projection for ${config.metadata.atlasName}`,
      ` * Generated by ${config.metadata.createdWith}`,
      ` * Export date: ${new Date(config.metadata.exportDate).toLocaleDateString()}`,
    ]

    if (config.metadata.notes) {
      lines.push(` * ${config.metadata.notes}`)
    }

    lines.push(' *')
    lines.push(` * Pattern: ${config.pattern}`)
    lines.push(` * Territories: ${config.territories.map(t => t.name).join(', ')}`)
    lines.push(` * Language: ${language}`)
    lines.push(' */')

    return lines.join('\n')
  }

  /**
   * Generate D3 imports
   */
  private generateD3Imports(config: ExportedCompositeConfig, typescript: boolean): string {
    const projections = new Set<string>()

    // Collect unique projections
    config.territories.forEach((territory) => {
      projections.add(this.getD3ProjectionFunction(territory.projectionId))
    })

    const imports = Array.from(projections).sort()

    if (typescript) {
      return `import { ${imports.join(', ')}, type GeoProjection } from 'd3-geo';`
    }
    else {
      return `import { ${imports.join(', ')} } from 'd3-geo';`
    }
  }

  /**
   * Generate D3 projection function
   */
  private generateD3ProjectionFunction(
    config: ExportedCompositeConfig,
    options: CodeGenerationOptions,
    typescript: boolean,
  ): string {
    const lines: string[] = []
    const returnType = typescript ? ': GeoProjection' : ''

    // Function signature
    lines.push(`export function create${this.toPascalCase(config.metadata.atlasId)}Projection()${returnType} {`)

    if (config.pattern === 'single-focus') {
      lines.push(...this.generateSingleFocusProjection(config, options, typescript))
    }
    else {
      lines.push(...this.generateEqualMembersProjection(config, options, typescript))
    }

    lines.push('}')

    return lines.join('\n')
  }

  /**
   * Generate single-focus pattern projection
   */
  private generateSingleFocusProjection(
    config: ExportedCompositeConfig,
    options: CodeGenerationOptions,
    _typescript: boolean,
  ): string[] {
    const lines: string[] = []
    const primary = config.territories.find(t => t.role === 'primary')
    const secondaries = config.territories.filter(t => t.role === 'secondary')

    if (!primary) {
      throw new Error('Single-focus pattern requires a primary territory')
    }

    lines.push('  // Create projections for each territory')
    lines.push(`  const projections = [];`)
    lines.push('')

    // Primary projection
    lines.push(`  // Primary: ${primary.name}`)
    lines.push(`  const primary = ${this.generateProjectionCreation(primary, 2)};`)
    lines.push(`  projections.push(primary);`)
    lines.push('')

    // Secondary projections
    if (secondaries.length > 0) {
      lines.push('  // Secondary territories')
      secondaries.forEach((territory, index) => {
        lines.push(`  const secondary${index + 1} = ${this.generateProjectionCreation(territory, 2)};`)
        lines.push(`  projections.push(secondary${index + 1});`)
        if (index < secondaries.length - 1) {
          lines.push('')
        }
      })
      lines.push('')
    }

    // Composite function
    lines.push('  // Create composite projection')
    lines.push('  const composite = (coordinates) => {')
    lines.push('    // Use primary projection for all points')
    lines.push('    return primary(coordinates);')
    lines.push('  };')
    lines.push('')

    // Copy properties from primary
    lines.push('  // Copy projection methods from primary')
    lines.push('  Object.setPrototypeOf(composite, primary);')
    lines.push('')

    if (options.includeComments) {
      lines.push('  // Note: Full composite behavior with territory switching')
      lines.push('  // requires additional implementation based on your needs.')
    }

    lines.push('  return composite;')

    return lines
  }

  /**
   * Generate equal-members pattern projection
   */
  private generateEqualMembersProjection(
    config: ExportedCompositeConfig,
    _options: CodeGenerationOptions,
    _typescript: boolean,
  ): string[] {
    const lines: string[] = []
    const mainlands = config.territories.filter(t => t.role === 'member')
    const overseas = config.territories.filter(t => t.role === 'secondary')

    lines.push('  // Create projections for each territory')
    lines.push(`  const projections = [];`)
    lines.push('')

    // Mainland projections
    if (mainlands.length > 0) {
      lines.push('  // Mainland territories')
      mainlands.forEach((territory, index) => {
        lines.push(`  const mainland${index + 1} = ${this.generateProjectionCreation(territory, 2)};`)
        lines.push(`  projections.push(mainland${index + 1});`)
        if (index < mainlands.length - 1) {
          lines.push('')
        }
      })
      lines.push('')
    }

    // Overseas projections
    if (overseas.length > 0) {
      lines.push('  // Overseas territories')
      overseas.forEach((territory, index) => {
        lines.push(`  const overseas${index + 1} = ${this.generateProjectionCreation(territory, 2)};`)
        lines.push(`  projections.push(overseas${index + 1});`)
        if (index < overseas.length - 1) {
          lines.push('')
        }
      })
      lines.push('')
    }

    // Composite function
    lines.push('  // Create composite projection')
    lines.push('  // Note: This simplified version uses the first mainland projection')
    lines.push('  // Implement territory-based projection switching as needed')
    lines.push('  const composite = (coordinates) => {')
    lines.push('    return mainland1(coordinates);')
    lines.push('  };')
    lines.push('')

    // Copy properties
    lines.push('  Object.setPrototypeOf(composite, mainland1);')
    lines.push('')
    lines.push('  return composite;')

    return lines
  }

  /**
   * Generate projection creation code
   */
  private generateProjectionCreation(territory: ExportedTerritory, indent: number): string {
    const indentStr = ' '.repeat(indent)
    const lines: string[] = []
    const func = this.getD3ProjectionFunction(territory.projectionId)

    lines.push(`${func}()`)

    const params = territory.parameters

    // Center and rotate
    if (params.center) {
      lines.push(`${indentStr}  .center([${params.center[0]}, ${params.center[1]}])`)
    }
    if (params.rotate) {
      lines.push(`${indentStr}  .rotate([${params.rotate.join(', ')}])`)
    }

    // Parallels (for conic projections)
    if (params.parallels) {
      lines.push(`${indentStr}  .parallels([${params.parallels.join(', ')}])`)
    }

    // Scale
    if (params.scale) {
      lines.push(`${indentStr}  .scale(${params.scale})`)
    }

    return lines.join(`\n${indentStr}`)
  }

  /**
   * Round number to avoid floating point precision issues
   */
  private roundNumber(num: number, decimals: number = 6): number {
    return Math.round(num * 10 ** decimals) / 10 ** decimals
  }

  /**
   * Format array of numbers with proper rounding
   */
  private formatNumberArray(arr: number[]): string {
    return arr.map(n => this.roundNumber(n)).join(', ')
  }

  /**
   * Generate D3 usage example
   */
  private generateD3UsageExample(config: ExportedCompositeConfig): string {
    const lines: string[] = []
    const funcName = `create${this.toPascalCase(config.metadata.atlasId)}Projection`

    lines.push('/**')
    lines.push(' * Usage Example')
    lines.push(' */')
    lines.push('/*')
    lines.push(`const projection = ${funcName}();`)
    lines.push('const path = d3.geoPath(projection);')
    lines.push('')
    lines.push('// Use with SVG')
    lines.push('svg.selectAll("path")')
    lines.push('  .data(features)')
    lines.push('  .join("path")')
    lines.push('  .attr("d", path);')
    lines.push('*/')

    return lines.join('\n')
  }

  /**
   * Generate Plot projection function
   */
  private generatePlotProjectionFunction(
    config: ExportedCompositeConfig,
    _options: CodeGenerationOptions,
  ): string {
    const lines: string[] = []
    const funcName = `create${this.toPascalCase(config.metadata.atlasId)}Projection`

    lines.push(`export function ${funcName}() {`)
    lines.push('  // Composite projection function compatible with Observable Plot')
    lines.push('  // Returns a function that takes {width, height} and builds the projection')
    lines.push('  return ({ width = 800, height = 600 }) => {')
    lines.push('    const subProjections = []')
    lines.push('    const epsilon = 1e-6  // For geographic bounds calculations')
    lines.push('')

    // Generate sub-projections for each territory with bounds
    config.territories.forEach((territory, index) => {
      const func = this.getD3ProjectionFunction(territory.projectionId)
      const varName = `proj${index}`

      lines.push(`    // ${territory.name} (${territory.code})`)
      lines.push(`    const ${varName} = d3.${func}()`)

      if (territory.parameters.center) {
        lines.push(`      .center([${this.formatNumberArray(territory.parameters.center)}])`)
      }
      if (territory.parameters.rotate) {
        lines.push(`      .rotate([${this.formatNumberArray(territory.parameters.rotate)}])`)
      }
      if (territory.parameters.parallels) {
        lines.push(`      .parallels([${this.formatNumberArray(territory.parameters.parallels)}])`)
      }

      // Calculate final scale based on reference
      const finalScale = this.roundNumber(territory.parameters.scale)
      lines.push(`      .scale(${finalScale})`)

      // Apply translation offset
      const [tx, ty] = territory.layout.translateOffset
      const roundedTx = this.roundNumber(tx)
      const roundedTy = this.roundNumber(ty)
      lines.push(`      .translate([width / 2 + ${roundedTx}, height / 2 + ${roundedTy}])`)

      lines.push('')

      // Calculate and apply clipExtent based on geographic bounds
      const [[minLon, minLat], [maxLon, maxLat]] = territory.bounds
      const roundedMinLon = this.roundNumber(minLon)
      const roundedMinLat = this.roundNumber(minLat)
      const roundedMaxLon = this.roundNumber(maxLon)
      const roundedMaxLat = this.roundNumber(maxLat)
      lines.push(`    // Set clip extent based on geographic bounds`)
      lines.push(`    const topLeft${index} = ${varName}([${roundedMinLon} + epsilon, ${roundedMaxLat} - epsilon])`)
      lines.push(`    const bottomRight${index} = ${varName}([${roundedMaxLon} - epsilon, ${roundedMinLat} + epsilon])`)
      lines.push(`    if (topLeft${index} && bottomRight${index}) {`)
      lines.push(`      ${varName}.clipExtent([topLeft${index}, bottomRight${index}])`)
      lines.push(`    }`)
      lines.push('')

      // Store projection with its geographic bounds for point delegation
      const boundsStr = `bounds: [[${roundedMinLon}, ${roundedMinLat}], [${roundedMaxLon}, ${roundedMaxLat}]]`
      lines.push(`    subProjections.push({ projection: ${varName}, ${boundsStr} })`)
      lines.push('')
    }) // Create point capture mechanism (like albersUsa)
    lines.push('    // Point capture mechanism for coordinate delegation')
    lines.push('    let capturedPoint = null')
    lines.push('    const pointStream = {')
    lines.push('      point: (x, y) => { capturedPoint = [x, y] },')
    lines.push('      lineStart: () => {},')
    lines.push('      lineEnd: () => {},')
    lines.push('      polygonStart: () => {},')
    lines.push('      polygonEnd: () => {},')
    lines.push('      sphere: () => {}')
    lines.push('    }')
    lines.push('')
    lines.push('    // Create point capture streams for each sub-projection')
    lines.push('    const subProjPoints = subProjections.map(sp => ({')
    lines.push('      subProj: sp,')
    lines.push('      stream: sp.projection.stream(pointStream)')
    lines.push('    }))')
    lines.push('')

    // Create composite projection function with proper bounds checking
    lines.push('    // Composite projection that delegates based on geographic bounds')
    lines.push('    function composite(coordinates) {')
    lines.push('      const [lon, lat] = coordinates')
    lines.push('      capturedPoint = null')
    lines.push('')
    lines.push('      // Try each sub-projection based on bounds')
    lines.push('      for (const { subProj, stream } of subProjPoints) {')
    lines.push('        if (subProj.bounds) {')
    lines.push('          const [[minLon, minLat], [maxLon, maxLat]] = subProj.bounds')
    lines.push('          if (lon >= minLon && lon <= maxLon && lat >= minLat && lat <= maxLat) {')
    lines.push('            stream.point(lon, lat)')
    lines.push('            if (capturedPoint) return capturedPoint')
    lines.push('          }')
    lines.push('        }')
    lines.push('      }')
    lines.push('      return null')
    lines.push('    }')
    lines.push('')

    // Multiplex stream for rendering with bounds checking
    lines.push('    // Stream multiplexing implementation for D3 stream protocol')
    lines.push('    // Routes geometry to appropriate sub-projections based on geographic bounds')
    lines.push('    composite.stream = (stream) => {')
    lines.push('      const streams = subProjections.map(sp => ({')
    lines.push('        stream: sp.projection.stream(stream),')
    lines.push('        bounds: sp.bounds')
    lines.push('      }))')
    lines.push('')
    lines.push('      // State machine for tracking stream routing:')
    lines.push('      // - activeStream: currently selected sub-projection stream (null = undecided)')
    lines.push('      // - polygonActive: true between polygonStart() and polygonEnd()')
    lines.push('      // - polygonStarted: true after polygonStart() was called on activeStream')
    lines.push('      // - ringActive: true between lineStart() and lineEnd()')
    lines.push('      let activeStream = null')
    lines.push('      let polygonActive = false')
    lines.push('      let polygonStarted = false')
    lines.push('      let ringActive = false')
    lines.push('')
    lines.push('      return {')
    lines.push('        point: (lon, lat) => {')
    lines.push('          // Route point to appropriate sub-projection by checking geographic bounds')
    lines.push('          for (const { stream: s, bounds } of streams) {')
    lines.push('            if (bounds) {')
    lines.push('              const [[minLon, minLat], [maxLon, maxLat]] = bounds')
    lines.push(`              // Check if point falls within this territory's bounds`)
    lines.push('              if (lon >= minLon && lon <= maxLon && lat >= minLat && lat <= maxLat) {')
    lines.push('                // First point of a ring: select stream and call lineStart()')
    lines.push('                if (!ringActive) {')
    lines.push('                  activeStream = s')
    lines.push('                  ringActive = true')
    lines.push(`                  // If in polygon and haven't called polygonStart yet, call it now`)
    lines.push('                  // (Must wait for first point to determine which stream to use)')
    lines.push('                  if (polygonActive && !polygonStarted) {')
    lines.push('                    s.polygonStart()')
    lines.push('                    polygonStarted = true')
    lines.push('                  }')
    lines.push('                  s.lineStart()')
    lines.push('                }')
    lines.push('                s.point(lon, lat)')
    lines.push('                return')
    lines.push('              }')
    lines.push('            }')
    lines.push('          }')
    lines.push('        },')
    lines.push('        sphere: () => { streams.forEach(({ stream: s }) => s.sphere && s.sphere()) },')
    lines.push('        // lineStart: Reset ring tracking (stream selected by first point)')
    lines.push('        lineStart: () => { ringActive = false },')
    lines.push('        // lineEnd: End ring, reset activeStream if not in polygon (single-ring feature)')
    lines.push('        lineEnd: () => { if (activeStream && ringActive) { activeStream.lineEnd(); ringActive = false; if (!polygonActive) activeStream = null } },')
    lines.push('        // polygonStart: Mark polygon start, reset activeStream for feature independence')
    lines.push('        polygonStart: () => { polygonActive = true; polygonStarted = false; activeStream = null },')
    lines.push('        // polygonEnd: End polygon and cleanup all state')
    lines.push('        polygonEnd: () => { if (activeStream && polygonActive) { activeStream.polygonEnd(); polygonActive = false; polygonStarted = false; activeStream = null } }')
    lines.push('      }')
    lines.push('    }')
    lines.push('')
    lines.push('    return composite')
    lines.push('  }')
    lines.push('}')

    return lines.join('\n')
  }

  /**
   * Generate Plot usage example
   */
  private generatePlotUsageExample(config: ExportedCompositeConfig): string {
    const lines: string[] = []
    const funcName = `create${this.toPascalCase(config.metadata.atlasId)}Projection`

    lines.push('/**')
    lines.push(' * Usage Example with Observable Plot')
    lines.push(' */')
    lines.push('/*')
    lines.push(`const projectionFn = ${funcName}();`)
    lines.push('')
    lines.push('Plot.plot({')
    lines.push('  width: 975,')
    lines.push('  height: 610,')
    lines.push('  projection: projectionFn,  // Plot will call this with {width, height}')
    lines.push('  marks: [')
    lines.push('    Plot.geo(features, {')
    lines.push('      fill: "lightgray",')
    lines.push('      stroke: "white",')
    lines.push('      strokeWidth: 0.5')
    lines.push('    })')
    lines.push('  ]')
    lines.push('});')
    lines.push('*/')

    return lines.join('\n')
  }

  /**
   * Map projection ID to D3 function name
   */
  private getD3ProjectionFunction(projectionId: string): string {
    const mapping: Record<string, string> = {
      'conic-conformal': 'geoConicConformal',
      'conic-equal-area': 'geoConicEqualArea',
      'conic-equidistant': 'geoConicEquidistant',
      'mercator': 'geoMercator',
      'transverse-mercator': 'geoTransverseMercator',
      'azimuthal-equal-area': 'geoAzimuthalEqualArea',
      'azimuthal-equidistant': 'geoAzimuthalEquidistant',
      'orthographic': 'geoOrthographic',
      'stereographic': 'geoStereographic',
      'gnomonic': 'geoGnomonic',
      'equirectangular': 'geoEquirectangular',
      'natural-earth': 'geoNaturalEarth1',
    }

    return mapping[projectionId] || 'geoMercator'
  }

  /**
   * Convert string to PascalCase
   */
  private toPascalCase(str: string): string {
    return str
      .split(/[-_\s]/)
      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join('')
  }
}

/**
 * Convenience function to generate code
 */
export function generateCode(
  config: ExportedCompositeConfig,
  options: CodeGenerationOptions,
): string {
  const generator = new CodeGenerator()
  return generator.generate(config, options)
}
