#!/usr/bin/env node

/**
 * Generate TypeScript Configuration Files from Unified JSON
 * 
 * This script reads unified JSON configs and generates:
 * 1. Backend extraction config (scripts/configs/*.js)
 * 2. Frontend territory data (src/data/territories/*.data.ts)
 * 3. Frontend region config (src/config/regions/*.config.ts)
 * 
 * Usage:
 *   node scripts/generate-configs.js portugal
 *   node scripts/generate-configs.js --all
 */

import fs from 'node:fs'
import path from 'node:path'
import process from 'node:process'
import { fileURLToPath } from 'node:url'

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)
const ROOT_DIR = path.resolve(__dirname, '..')
const CONFIG_DIR = path.join(ROOT_DIR, 'configs')
const BACKEND_CONFIG_DIR = path.join(ROOT_DIR, 'scripts', 'configs')
const FRONTEND_DATA_DIR = path.join(ROOT_DIR, 'src', 'data', 'territories')
const FRONTEND_CONFIG_DIR = path.join(ROOT_DIR, 'src', 'config', 'regions')

/**
 * Load unified JSON config
 */
function loadUnifiedConfig(regionId) {
  const configPath = path.join(CONFIG_DIR, `${regionId}.json`)
  
  if (!fs.existsSync(configPath)) {
    throw new Error(`Config not found: ${configPath}`)
  }
  
  const content = fs.readFileSync(configPath, 'utf-8')
  return JSON.parse(content)
}

/**
 * Generate backend extraction config (scripts/configs/*.js)
 */
function generateBackendConfig(config) {
  const { id, name, description, territories } = config
  
  const backendTerritories = {}
  
  territories.forEach(t => {
    const territory = {
      name: t.name,
      code: t.code,
      iso: t.iso,
    }
    
    if (t.extraction?.mainlandPolygon !== undefined) {
      territory.mainlandPolygon = t.extraction.mainlandPolygon
    }
    
    if (t.extraction?.mainlandBounds) {
      territory.mainlandBounds = t.extraction.mainlandBounds
    }
    
    if (t.extraction?.extractFrom) {
      territory.extractFrom = Number.parseInt(t.extraction.extractFrom)
    }
    
    if (t.extraction?.polygonIndices) {
      territory.polygonIndices = t.extraction.polygonIndices
    }
    
    if (t.bounds) {
      territory.bounds = t.bounds
    }
    
    backendTerritories[t.id] = territory
  })
  
  const output = `/**
 * ${name} Territory Configuration
 * Auto-generated from configs/${id}.json
 * DO NOT EDIT - Use 'npm run geodata:generate ${id}' to regenerate
 */

export default {
  name: '${name}',
  description: '${description}',
  
  territories: ${JSON.stringify(backendTerritories, null, 2)},
  
  outputName: '${id}'
}
`
  
  return output
}

/**
 * Generate frontend territory data (src/data/territories/*.data.ts)
 */
function generateFrontendData(config) {
  const { id, name, territories } = config
  
  const mainland = territories.find(t => t.role === 'mainland')
  const overseas = territories.filter(t => t.role === 'overseas')
  
  if (!mainland) {
    throw new Error(`No mainland territory found in ${id}`)
  }
  
  const mainlandConstName = `MAINLAND_${id.toUpperCase().replace(/-/g, '_')}`
  const overseasConstName = `${id.toUpperCase().replace(/-/g, '_')}_OVERSEAS`
  const allConstName = `${id.toUpperCase().replace(/-/g, '_')}_ALL_TERRITORIES`
  
  let output = `/**
 * ${name} Territory Data
 * Auto-generated from configs/${id}.json
 * DO NOT EDIT - Use 'npm run geodata:generate ${id}' to regenerate
 *
 * Pure territory definitions with NO logic, NO UI concerns, NO utility functions
 */

import type { TerritoryConfig } from '@/types/territory'

/**
 * Mainland ${mainland.name}
 */
export const ${mainlandConstName}: TerritoryConfig = {
  code: '${mainland.code}',
  name: '${mainland.name}',
  center: ${JSON.stringify(mainland.center)},
  offset: ${JSON.stringify(mainland.rendering?.offset || [0, 0])},
  bounds: ${JSON.stringify(mainland.bounds)},
`
  
  if (mainland.rendering?.projectionType) {
    output += `  projectionType: '${mainland.rendering.projectionType}',\n`
  }
  
  output += `}\n\n`
  
  if (overseas.length > 0) {
    output += `/**
 * Overseas Territories
 */
export const ${overseasConstName}: TerritoryConfig[] = [\n`
    
    overseas.forEach((t, i) => {
      output += `  {
    code: '${t.code}',
    name: '${t.name}',`
      
      if (t.region) {
        output += `
    region: '${t.region}',`
      }
      
      output += `
    center: ${JSON.stringify(t.center)},
    offset: ${JSON.stringify(t.rendering?.offset || [0, 0])},
    bounds: ${JSON.stringify(t.bounds)},`
      
      if (t.rendering?.projectionType) {
        output += `
    projectionType: '${t.rendering.projectionType}',`
      }
      
      output += `
  }${i < overseas.length - 1 ? ',' : ''}\n`
    })
    
    output += `]\n\n`
    
    output += `/**
 * All ${name} territories (mainland + overseas)
 */
export const ${allConstName}: TerritoryConfig[] = [
  ${mainlandConstName},
  ...${overseasConstName},
]\n`
  } else {
    output += `/**
 * All ${name} territories
 */
export const ${allConstName}: TerritoryConfig[] = [
  ${mainlandConstName},
]\n`
  }
  
  return output
}

/**
 * Generate frontend region config (src/config/regions/*.config.ts)
 */
function generateFrontendConfig(config) {
  const { id, name, projection, modes, groups, territories } = config
  
  const mainlandConstName = `MAINLAND_${id.toUpperCase().replace(/-/g, '_')}`
  const overseasConstName = `${id.toUpperCase().replace(/-/g, '_')}_OVERSEAS`
  const allConstName = `${id.toUpperCase().replace(/-/g, '_')}_ALL_TERRITORIES`
  
  const mainland = territories.find(t => t.role === 'mainland')
  
  let output = `/**
 * ${name} Region Configuration
 * Auto-generated from configs/${id}.json
 * DO NOT EDIT - Use 'npm run geodata:generate ${id}' to regenerate
 */

import type { CompositeProjectionDefaults, ProjectionParams, RegionSpecificConfig } from './types'
import type { GeoDataConfig, RegionConfig, TerritoryGroupConfig, TerritoryModeConfig } from '@/types/territory'
import {
  ${mainlandConstName},
  ${allConstName},
`
  
  if (territories.some(t => t.role === 'overseas')) {
    output += `  ${overseasConstName},\n`
  }
  
  output += `} from '@/data/territories'

/**
 * Projection parameters for ${name}
 */
export const ${id.toUpperCase().replace(/-/g, '_')}_PROJECTION_PARAMS: ProjectionParams = ${JSON.stringify(projection, null, 2)}

`
  
  if (modes && modes.length > 0) {
    output += `/**
 * Territory mode definitions for ${name}
 */
export const ${id.toUpperCase().replace(/-/g, '_')}_TERRITORY_MODES: Record<string, TerritoryModeConfig> = {\n`
    
    modes.forEach((mode, i) => {
      const modeCodes = mode.territories.filter(code => code !== mainland.code)
      output += `  '${mode.id}': {
    label: '${mode.label}',
    codes: ${JSON.stringify(modeCodes)},
  }${i < modes.length - 1 ? ',' : ''}\n`
    })
    
    output += `}\n\n`
  }
  
  if (groups && groups.length > 0) {
    output += `/**
 * Territory groupings for UI organization
 */
export const ${id.toUpperCase().replace(/-/g, '_')}_TERRITORY_GROUPS: Record<string, TerritoryGroupConfig> = {\n`
    
    groups.forEach((group, i) => {
      output += `  ${group.id.toUpperCase()}: {
    label: '${group.label}',
    codes: ${JSON.stringify(group.territories)},
  }${i < groups.length - 1 ? ',' : ''}\n`
    })
    
    output += `}\n\n`
  }
  
  output += `/**
 * Default composite projection configuration for ${name}
 */
export const ${id.toUpperCase().replace(/-/g, '_')}_DEFAULT_COMPOSITE_CONFIG: CompositeProjectionDefaults = {
  territoryProjections: Object.fromEntries(
    ${allConstName}.map((t: any) => [
      t.code,
      t.projectionType || 'mercator',
    ]),
  ),
  territoryTranslations: Object.fromEntries(
    ${allConstName}.map((t: any) => [t.code, { x: t.offset[0], y: t.offset[1] }]),
  ),
  territoryScales: Object.fromEntries(
    ${allConstName}.map((t: any) => [t.code, 1.0]),
  ),
}

/**
 * Geographic data configuration for ${name}
 */
export const ${id.toUpperCase().replace(/-/g, '_')}_GEO_DATA_CONFIG: GeoDataConfig = {
  dataPath: '/data/${id}-territories-50m.json',
  metadataPath: '/data/${id}-metadata-50m.json',
  topologyObjectName: 'territories',
  mainlandCode: '${mainland.code}',
  mainlandBounds: ${mainlandConstName}.bounds,`
  
  if (territories.some(t => t.role === 'overseas')) {
    output += `
  overseasTerritories: ${overseasConstName},`
  }
  
  output += `
}

/**
 * Composite projection configuration for CustomCompositeProjection
 */
export const ${id.toUpperCase().replace(/-/g, '_')}_COMPOSITE_PROJECTION_CONFIG = {
  mainland: ${mainlandConstName},`
  
  if (territories.some(t => t.role === 'overseas')) {
    output += `
  overseasTerritories: ${overseasConstName},`
  }
  
  output += `
}

/**
 * Complete ${name} region configuration
 */
export const ${id.toUpperCase().replace(/-/g, '_')}_REGION_CONFIG: RegionConfig = {
  id: '${id}',
  name: '${name}',
  geoDataConfig: ${id.toUpperCase().replace(/-/g, '_')}_GEO_DATA_CONFIG,
  supportedViewModes: ['split', 'composite-existing', 'composite-custom', 'unified'],
  defaultViewMode: 'composite-custom',
  defaultTerritoryMode: '${modes?.[modes.length - 1]?.id || 'all-territories'}',
  defaultCompositeConfig: ${id.toUpperCase().replace(/-/g, '_')}_DEFAULT_COMPOSITE_CONFIG,
  compositeProjections: ['conic-conformal-${id}'],
  defaultCompositeProjection: 'conic-conformal-${id}',
  compositeProjectionConfig: ${id.toUpperCase().replace(/-/g, '_')}_COMPOSITE_PROJECTION_CONFIG,
  splitModeConfig: {
    mainlandTitle: '${mainland.name}',
    mainlandCode: '${mainland.code}',
    territoriesTitle: '${territories.some(t => t.role === 'overseas') ? 'Overseas Territories' : 'Territories'}',
  },
  hasTerritorySelector: true,`
  
  if (modes && modes.length > 0) {
    output += `
  territoryModeOptions: [`
    modes.forEach((mode, i) => {
      output += `
    { value: '${mode.id}', label: ${id.toUpperCase().replace(/-/g, '_')}_TERRITORY_MODES['${mode.id}']!.label }${i < modes.length - 1 ? ',' : ''}`
    })
    output += `
  ],`
  }
  
  output += `
}

/**
 * ${name}-specific configuration
 */
export const ${id.toUpperCase().replace(/-/g, '_')}_CONFIG: RegionSpecificConfig = {
  projectionParams: ${id.toUpperCase().replace(/-/g, '_')}_PROJECTION_PARAMS,`
  
  if (modes && modes.length > 0) {
    output += `
  territoryModes: ${id.toUpperCase().replace(/-/g, '_')}_TERRITORY_MODES,`
  }
  
  if (groups && groups.length > 0) {
    output += `
  territoryGroups: ${id.toUpperCase().replace(/-/g, '_')}_TERRITORY_GROUPS,`
  }
  
  output += `
  defaultCompositeConfig: ${id.toUpperCase().replace(/-/g, '_')}_DEFAULT_COMPOSITE_CONFIG,
}
`
  
  return output
}

/**
 * Generate all config files for a region
 */
function generateRegionConfigs(regionId) {
  console.log(`\n📝 Generating configs for: ${regionId}`)
  
  try {
    // Load unified config
    const config = loadUnifiedConfig(regionId)
    console.log(`   ✓ Loaded unified config`)
    
    // Generate backend config
    const backendConfig = generateBackendConfig(config)
    const backendPath = path.join(BACKEND_CONFIG_DIR, `${regionId}.js`)
    fs.writeFileSync(backendPath, backendConfig)
    console.log(`   ✓ Generated backend config: ${path.relative(ROOT_DIR, backendPath)}`)
    
    // Generate frontend data
    const frontendData = generateFrontendData(config)
    const frontendDataPath = path.join(FRONTEND_DATA_DIR, `${regionId}.data.ts`)
    fs.writeFileSync(frontendDataPath, frontendData)
    console.log(`   ✓ Generated frontend data: ${path.relative(ROOT_DIR, frontendDataPath)}`)
    
    // Generate frontend config
    const frontendConfig = generateFrontendConfig(config)
    const frontendConfigPath = path.join(FRONTEND_CONFIG_DIR, `${regionId}.config.ts`)
    fs.writeFileSync(frontendConfigPath, frontendConfig)
    console.log(`   ✓ Generated frontend config: ${path.relative(ROOT_DIR, frontendConfigPath)}`)
    
    console.log(`   ✅ Successfully generated all configs for ${regionId}\n`)
    
  } catch (error) {
    console.error(`   ❌ Error: ${error.message}\n`)
    throw error
  }
}

/**
 * Main execution
 */
function main() {
  const args = process.argv.slice(2)
  
  if (args.length === 0) {
    console.error('Usage: node scripts/generate-configs.js <region-id>')
    console.error('   or: node scripts/generate-configs.js --all')
    process.exit(1)
  }
  
  // Ensure output directories exist
  fs.mkdirSync(BACKEND_CONFIG_DIR, { recursive: true })
  fs.mkdirSync(FRONTEND_DATA_DIR, { recursive: true })
  fs.mkdirSync(FRONTEND_CONFIG_DIR, { recursive: true })
  
  if (args[0] === '--all') {
    // Generate for all configs
    const configFiles = fs.readdirSync(CONFIG_DIR)
      .filter(f => f.endsWith('.json') && f !== 'schema.json')
      .map(f => f.replace('.json', ''))
    
    console.log(`🔄 Generating configs for ${configFiles.length} region(s)`)
    
    let success = 0
    let failed = 0
    
    for (const regionId of configFiles) {
      try {
        generateRegionConfigs(regionId)
        success++
      } catch {
        failed++
      }
    }
    
    console.log(`\n✅ Generated configs for ${success} region(s)`)
    if (failed > 0) {
      console.log(`❌ Failed for ${failed} region(s)`)
      process.exit(1)
    }
    
  } else {
    // Generate for specific region
    const regionId = args[0]
    generateRegionConfigs(regionId)
  }
}

main()
