# Territory Grouping Unification - Implementation Plan

## Executive Summary

This plan unifies territory grouping under a single, flexible schema while enforcing strict separation of concerns:

**Atlas Configs** (`configs/atlases/*.json`):
- ✅ Pure territory data structure
- ✅ Geographic and administrative relationships
- ✅ Collection definitions (how territories are grouped)
- ❌ NO UI behavior, NO defaults, NO preset references

**Atlas Registry** (`configs/atlas-registry.json`):
- ✅ Application-level configuration per atlas
- ✅ UI behavior (which collection for which UI element)
- ✅ Default presets and territory collections
- ✅ Available presets list

**Key Innovation**: Collection type (selection-preset vs visual-grouping) is inferred from registry usage, not declared in atlas config. This keeps atlas configs purely declarative data structures.

## Objective
Unify territory grouping under a single, flexible schema that supports multiple grouping strategies (geographic, administrative, custom) with application behavior defined separately in the registry.

## Current State Analysis

### Current Structure Problems
1. **Dual Systems**: Two separate, overlapping concepts
   - `modes[]` - Administrative/political groupings (DROM, DOM-COM, all territories)
   - `groups[]` - Geographic groupings (Caribbean, Pacific, Indian Ocean)

2. **Naming Confusion**:
   - "Mode" is generic and doesn't reflect its purpose (territory selection preset)
   - "Groups" works but is ambiguous
   - Both contain similar data structures (label + territory codes)

3. **Usage Split**:
   - `modes` → "Territoires à inclure" dropdown (changes active territory set)
   - `groups` → TerritorySetManager tags (visual organization only)

4. **Code Duplication**:
   - Similar processing in `TerritoryModeConfig` and `TerritoryGroupConfig`
   - Separate handling in loader, services, and UI components

### Current JSON Structure (France example)

```json
{
  "modes": [
    {
      "id": "metropole-drom",
      "label": { "en": "Mainland + Overseas Departments", "fr": "Métropole + DROM" },
      "territories": ["FR-MET", "FR-GF", "FR-RE", "FR-GP", "FR-MQ", "FR-YT"]
    }
  ],
  "groups": [
    {
      "id": "caribbean",
      "label": { "en": "Caribbean", "fr": "Caraïbes" },
      "territories": ["FR-GP", "FR-MQ", "FR-GF", "FR-BL", "FR-MF"]
    }
  ]
}
```

## Proposed Solution

### New Schema Design

#### Part 1: Atlas Config (Pure Territory Data)

Replace `modes` and `groups` with a single `territoryCollections` key containing named collection sets.
**Remove all UI/application config** - keep only territory structure:

```json
{
  "id": "france",
  "name": { "en": "France", "fr": "France" },
  "territories": [ /* ... */ ],
  "territoryCollections": {
    "administrative": {
      "label": { "en": "Administrative status", "fr": "Statut administratif" },
      "description": { 
        "en": "Group territories by administrative/political status",
        "fr": "Regrouper les territoires par statut administratif/politique"
      },
      "collections": [
        {
          "id": "metropole-drom",
          "label": { "en": "Mainland + Overseas Departments", "fr": "Métropole + DROM" },
          "territories": ["FR-MET", "FR-GF", "FR-RE", "FR-GP", "FR-MQ", "FR-YT"]
        },
        {
          "id": "metropole-drom-com",
          "label": { "en": "Mainland + DOM + COM", "fr": "Métropole + DROM + COM" },
          "territories": ["FR-MET", "FR-GF", "FR-RE", "FR-GP", "FR-MQ", "FR-YT", "FR-PM", "FR-BL", "FR-PF", "FR-WF", "FR-PF-2", "FR-NC"]
        },
        {
          "id": "all-territories",
          "label": { "en": "All territories", "fr": "Tous les territoires" },
          "territories": "*"
        }
      ]
    },
    "geographic": {
      "label": { "en": "Geographic regions", "fr": "Régions géographiques" },
      "description": {
        "en": "Group territories by ocean/geographic location",
        "fr": "Regrouper les territoires par océan/localisation géographique"
      },
      "collections": [
        {
          "id": "mainland",
          "label": { "en": "Metropolitan France", "fr": "France Métropolitaine" },
          "territories": ["FR-MET"]
        },
        {
          "id": "caribbean",
          "label": { "en": "Caribbean", "fr": "Caraïbes" },
          "territories": ["FR-GP", "FR-MQ", "FR-GF", "FR-BL", "FR-MF"]
        },
        {
          "id": "indian-ocean",
          "label": { "en": "Indian Ocean", "fr": "Océan Indien" },
          "territories": ["FR-RE", "FR-YT", "FR-TF"]
        },
        {
          "id": "pacific",
          "label": { "en": "Pacific Ocean", "fr": "Océan Pacifique" },
          "territories": ["FR-NC", "FR-PF", "FR-PF-2", "FR-WF"]
        },
        {
          "id": "north-atlantic",
          "label": { "en": "North Atlantic", "fr": "Atlantique Nord" },
          "territories": ["FR-PM"]
        }
      ]
    }
  }
}
```

**Note**: No `type`, `ui`, `defaultTerritoryCollection`, `availablePresets`, or `defaultPreset` in atlas config.

#### Part 2: Atlas Registry (Application Behavior)

Move all UI and application configuration to the registry:

```json
{
  "$schema": "./atlas-registry.schema.json",
  "defaultAtlas": "france",
  "groups": [ /* ... */ ],
  "atlases": [
    {
      "id": "france",
      "name": { "en": "France", "fr": "France" },
      "group": "country",
      "sortOrder": 10,
      "configPath": "./atlases/france.json",
      
      "behavior": {
        "defaultPreset": "france-default",
        "availablePresets": ["france-default", "france-test", "france-nsp"],
        "defaultTerritoryCollection": "administrative:metropole-drom-com",
        "ui": {
          "territorySelectorCollection": "administrative",
          "territoryTagsCollection": "geographic"
        }
      }
    },
    {
      "id": "portugal",
      "name": { "en": "Portugal", "fr": "Portugal" },
      "group": "country",
      "sortOrder": 20,
      "configPath": "./atlases/portugal.json",
      
      "behavior": {
        "defaultPreset": "portugal-default",
        "availablePresets": ["portugal-default", "portugal-split", "portugal-unified"],
        "defaultTerritoryCollection": "administrative:all-territories",
        "ui": {
          "territorySelectorCollection": "administrative",
          "territoryTagsCollection": "geographic"
        }
      }
    }
  ]
}
```

### Key Design Decisions

#### 1. Naming: `territoryCollections`
**Rationale**: 
- Clear, self-documenting name
- "Collections" is neutral - works for both selection presets and visual groupings
- Plural form indicates it contains multiple collection sets
- Avoids overloaded terms like "mode", "group", "set"

**Alternatives Considered**:
- ❌ `territoryGroupings` - Too similar to old "groups"
- ❌ `territorySets` - Could be confused with a set of territories
- ❌ `territoryOrganization` - Too abstract
- ❌ `territoryClassifications` - Too formal
- ✅ `territoryCollections` - Clear, flexible, semantic

#### 2. Collection Set Keys: Arbitrary User-Defined
**Rationale**:
- Not hardcoded (`administrative`, `geographic`) - users define their own
- Enables custom groupings: `economic`, `language`, `timezone`, `population`, etc.
- Schema validates structure but doesn't constrain keys
- Maximum flexibility for atlas-specific needs

**Example - Custom Collections**:
```json
{
  "territoryCollections": {
    "timezone": {
      "label": { "en": "Time Zones", "fr": "Fuseaux horaires" },
      "collections": [
        {
          "id": "utc-plus-4",
          "label": { "en": "UTC+4 (Réunion, Mayotte)", "fr": "UTC+4 (Réunion, Mayotte)" },
          "territories": ["FR-RE", "FR-YT"]
        }
      ]
    },
    "population": {
      "label": { "en": "By population", "fr": "Par population" },
      "collections": [
        {
          "id": "major-territories",
          "label": { "en": "Major territories (>100k pop.)", "fr": "Territoires majeurs (>100k hab.)" },
          "territories": ["FR-MET", "FR-RE", "FR-GP", "FR-MQ", "FR-NC", "FR-PF", "FR-GF"]
        }
      ]
    }
  }
}
```

#### 3. Separation of Concerns: Atlas vs Registry
**NEW - Critical Design Principle**

**Atlas Config** (`configs/atlases/*.json`):
- ✅ Pure territory data structure
- ✅ Geographic/administrative relationships
- ✅ Collection definitions (how territories are grouped)
- ❌ NO UI behavior
- ❌ NO application defaults
- ❌ NO preset references

**Atlas Registry** (`configs/atlas-registry.json`):
- ✅ Application-level configuration
- ✅ UI behavior per atlas
- ✅ Default presets and collections
- ✅ Available presets list
- ✅ Collection usage mapping (which collection for which UI element)

**Rationale**:
- **Reusability**: Atlas configs can be used in different contexts (web app, CLI tools, exports) with different UI needs
- **Single Responsibility**: Atlas = data structure, Registry = application behavior
- **Flexibility**: Same atlas can have different defaults in different apps
- **Clarity**: Clear separation makes both schemas simpler and easier to understand
- **Maintainability**: UI changes don't require atlas config updates

#### 4. Collection Type Inference from Registry
**Instead of `type: "selection-preset" | "visual-grouping"` in atlas config, infer from registry usage**:

```json
// In registry:
{
  "behavior": {
    "ui": {
      "territorySelectorCollection": "administrative",  // ← Implies selection-preset behavior
      "territoryTagsCollection": "geographic"           // ← Implies visual-grouping behavior
    }
  }
}
```

**Rationale**:
- Collections are just data - behavior is determined by how they're used
- Same collection could be used for both purposes in different contexts
- Keeps atlas config purely declarative
- Application decides behavior, not data structure

#### 5. Collection Reference Format
Use `collectionSetKey:collectionId` format:
- `defaultTerritoryCollection: "administrative:metropole-drom-com"`
- In registry `behavior.ui.territorySelectorCollection: "administrative"`

**Rationale**:
- Explicit and unambiguous
- Easy to parse (`split(':')`)
- Self-documenting in config files
- Allows same collection ID in different sets

#### 6. Behavior Object in Registry
New `behavior` object per atlas in registry for all application-level config:
```json
{
  "behavior": {
    "defaultPreset": "france-default",
    "availablePresets": ["france-default", "france-test", "france-nsp"],
    "defaultTerritoryCollection": "administrative:metropole-drom-com",
    "ui": {
      "territorySelectorCollection": "administrative",
      "territoryTagsCollection": "geographic"
    }
  }
}
```

**Rationale**:
- Single place for all application behavior per atlas
- Clear namespace separation from structural metadata (name, group, sortOrder)
- Easy to understand and modify
- Extensible for future behavior options

## Migration Path

### Phase 1: Schema & Type Definitions

#### 1.1 Update Atlas JSON Schema
**File**: `configs/atlases/atlas.schema.json`

**Remove these properties**:
- `defaultPreset`
- `availablePresets`
- `defaultTerritoryMode`
- `modes` (will be replaced by `territoryCollections`)
- `groups` (will be replaced by `territoryCollections`)

**Add this property**:
```json
{
  "territoryCollections": {
    "type": "object",
    "description": "Named sets of territory collections for different grouping strategies. Pure data structure - application behavior defined in registry.",
    "patternProperties": {
      "^[a-z][a-z0-9-]*$": {
        "type": "object",
        "required": ["label", "collections"],
        "properties": {
          "label": {
            "oneOf": [
              { "type": "string" },
              {
                "type": "object",
                "properties": {
                  "en": { "type": "string" },
                  "fr": { "type": "string" }
                },
                "required": ["en"],
                "additionalProperties": { "type": "string" }
              }
            ],
            "description": "Display label for the collection set"
          },
          "description": {
            "oneOf": [
              { "type": "string" },
              {
                "type": "object",
                "properties": {
                  "en": { "type": "string" },
                  "fr": { "type": "string" }
                },
                "additionalProperties": { "type": "string" }
              }
            ],
            "description": "Optional description explaining the grouping strategy"
          },
          "collections": {
            "type": "array",
            "minItems": 1,
            "items": {
              "type": "object",
              "required": ["id", "label", "territories"],
              "properties": {
                "id": {
                  "type": "string",
                  "pattern": "^[a-z][a-z0-9-]*$",
                  "description": "Collection identifier"
                },
                "label": {
                  "oneOf": [
                    { "type": "string" },
                    {
                      "type": "object",
                      "properties": {
                        "en": { "type": "string" },
                        "fr": { "type": "string" }
                      },
                      "required": ["en"],
                      "additionalProperties": { "type": "string" }
                    }
                  ],
                  "description": "Display label for this collection"
                },
                "territories": {
                  "oneOf": [
                    {
                      "type": "string",
                      "enum": ["*"],
                      "description": "Use '*' to include all territories"
                    },
                    {
                      "type": "array",
                      "items": { "type": "string" },
                      "minItems": 1,
                      "description": "Array of territory codes"
                    }
                  ]
                },
                "exclude": {
                  "type": "array",
                  "items": { "type": "string" },
                  "description": "Territory codes to exclude when using '*'"
                }
              }
            }
          }
        }
      }
    },
    "additionalProperties": false
  }
}
```

**Note**: No `type`, `ui`, `defaultTerritoryCollection` fields - atlas is purely data structure.

#### 1.2 Update Atlas Registry JSON Schema
**File**: `configs/atlas-registry.schema.json`

**Add to atlas entry schema**:
```json
{
  "properties": {
    "atlases": {
      "items": {
        "properties": {
          "id": { "type": "string" },
          "name": { /* existing */ },
          "group": { /* existing */ },
          "sortOrder": { /* existing */ },
          "configPath": { /* existing */ },
          
          "behavior": {
            "type": "object",
            "description": "Application behavior and UI configuration for this atlas",
            "properties": {
              "defaultPreset": {
                "type": "string",
                "description": "Default preset ID to load for this atlas",
                "examples": ["france-default", "portugal-default"]
              },
              "availablePresets": {
                "type": "array",
                "description": "List of available preset IDs for this atlas",
                "items": { "type": "string" },
                "examples": [["france-default", "france-test", "france-nsp"]]
              },
              "defaultTerritoryCollection": {
                "type": "string",
                "pattern": "^[a-z][a-z0-9-]*:[a-z][a-z0-9-]*$",
                "description": "Default collection to apply on load (format: 'collectionSetKey:collectionId')",
                "examples": ["administrative:metropole-drom-com", "geographic:all-regions"]
              },
              "ui": {
                "type": "object",
                "description": "UI behavior configuration - which collection to use for which UI element",
                "properties": {
                  "territorySelectorCollection": {
                    "type": "string",
                    "pattern": "^[a-z][a-z0-9-]*$",
                    "description": "Collection set key to use for 'Territoires à inclure' dropdown"
                  },
                  "territoryTagsCollection": {
                    "type": "string",
                    "pattern": "^[a-z][a-z0-9-]*$",
                    "description": "Collection set key to use for territory tag grouping"
                  },
                  "territoryListCollection": {
                    "type": "string",
                    "pattern": "^[a-z][a-z0-9-]*$",
                    "description": "Collection set key to use for territory list organization"
                  },
                  "exportGroupingCollection": {
                    "type": "string",
                    "pattern": "^[a-z][a-z0-9-]*$",
                    "description": "Collection set key to use for export grouping"
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
```

#### 1.2 Update TypeScript Types
**File**: `types/atlas-config.ts`

Add to `JSONAtlasConfig`:
```typescript
export interface JSONTerritoryCollection {
  id: string
  label: I18nValue
  territories: '*' | string[]
  exclude?: string[]
}

export interface JSONTerritoryCollectionSet {
  label: I18nValue
  description?: I18nValue
  collections: JSONTerritoryCollection[]
}

export interface JSONAtlasConfig {
  // ... existing fields ...
  
  /** 
   * Unified territory collections
   * Replaces legacy 'modes' and 'groups' fields
   * Pure data structure - behavior defined in registry
   */
  territoryCollections?: Record<string, JSONTerritoryCollectionSet>
  
  // Legacy fields - kept for migration period
  /** @deprecated Use territoryCollections instead */
  modes?: Array<{
    id: string
    label: I18nValue
    territories: string[]
  }>
  
  /** @deprecated Use territoryCollections instead */
  groups?: Array<{
    id: string
    label: I18nValue
    territories: string[]
  }>
  
  // REMOVED from atlas config - moved to registry:
  // - defaultPreset
  // - availablePresets
  // - defaultTerritoryMode
  // - ui
}
```

**File**: `configs/atlas-registry.ts` (NEW TYPE FILE)

Create types for registry with behavior config:
```typescript
import type { I18nValue } from '#types'

export interface AtlasRegistryEntry {
  id: string
  name: I18nValue
  group: 'country' | 'region' | 'world'
  sortOrder: number
  configPath: string
  behavior?: AtlasBehaviorConfig
}

export interface AtlasBehaviorConfig {
  /** Default preset to load */
  defaultPreset?: string
  
  /** Available presets for this atlas */
  availablePresets?: string[]
  
  /** Default collection to apply on load (format: 'setKey:collectionId') */
  defaultTerritoryCollection?: string
  
  /** UI behavior configuration */
  ui?: {
    /** Collection set for territory selector dropdown */
    territorySelectorCollection?: string
    
    /** Collection set for territory tags grouping */
    territoryTagsCollection?: string
    
    /** Collection set for territory list organization */
    territoryListCollection?: string
    
    /** Collection set for export grouping */
    exportGroupingCollection?: string
  }
}

export interface AtlasRegistryConfig {
  defaultAtlas: string
  groups: AtlasGroupDefinition[]
  atlases: AtlasRegistryEntry[]
}
```

**File**: `src/types/territory.ts`

Replace `TerritoryModeConfig` and `TerritoryGroupConfig` with unified types:
```typescript
/**
 * Territory collection definition
 * 
 * Represents a single collection of territories (e.g., "Caribbean", 
 * "Mainland + DOM", "All territories")
 */
export interface TerritoryCollection {
  /** Collection identifier */
  id: string
  
  /** Display label (localized) */
  label: string
  
  /** Territory codes in this collection. Can include "*" for all territories */
  territories: string[]
  
  /** Territory codes to exclude when using wildcard */
  exclude?: string[]
}

/**
 * Territory collection set definition
 * 
 * Groups multiple collections under a common strategy
 * (e.g., "administrative", "geographic", "timezone")
 */
export interface TerritoryCollectionSet {
  /** Collection set identifier */
  id: string
  
  /** Display label for the collection set (localized) */
  label: string
  
  /** Optional description (localized) */
  description?: string
  
  /** Individual collections in this set */
  collections: TerritoryCollection[]
}

// Legacy type aliases for backward compatibility during migration
/** @deprecated Use TerritoryCollection instead */
export type TerritoryModeConfig = TerritoryCollection

/** @deprecated Use TerritoryCollection instead */
export type TerritoryGroupConfig = Omit<TerritoryCollection, 'id' | 'exclude'>
```

**File**: `src/types/atlas.ts`

Update `AtlasConfig` to remove UI fields (now in registry):
```typescript
export interface AtlasConfig {
  // ... existing fields ...
  
  // REMOVED - now in registry behavior config:
  // - defaultPreset
  // - availablePresets
  // - defaultTerritoryMode
  // - ui
}
```

### Phase 2: Loader & Service Updates

#### 2.1 Update Atlas Registry Loader
**File**: `src/core/atlases/registry.ts`

Update `AtlasRegistryEntry` interface and add behavior config:
```typescript
import type { AtlasBehaviorConfig } from '#configs/atlas-registry'

export interface AtlasRegistryEntry {
  id: string
  name: I18nValue | string
  group: 'country' | 'region' | 'world'
  sortOrder: number
  configPath: string
  behavior?: AtlasBehaviorConfig  // NEW
}

// Add new function to get behavior config
export function getAtlasBehavior(atlasId: string): AtlasBehaviorConfig | undefined {
  const entry = REGISTRY_METADATA.atlases.find(a => a.id === atlasId)
  return entry?.behavior
}

// Add helper functions for specific behavior properties
export function getDefaultPreset(atlasId: string): string | undefined {
  return getAtlasBehavior(atlasId)?.defaultPreset
}

export function getAvailablePresets(atlasId: string): string[] {
  return getAtlasBehavior(atlasId)?.availablePresets || []
}

export function getDefaultTerritoryCollection(atlasId: string): string | undefined {
  return getAtlasBehavior(atlasId)?.defaultTerritoryCollection
}

export function getUICollectionConfig(atlasId: string): AtlasBehaviorConfig['ui'] | undefined {
  return getAtlasBehavior(atlasId)?.ui
}
```

#### 2.2 Update Atlas Config Loader
**File**: `src/core/atlases/loader.ts`

Add new function:
```typescript
/**
 * Transform territory collections from JSON to runtime format
 */
function transformTerritoryCollections(
  config: JSONAtlasConfig,
  locale: string,
  allTerritoryCodes: string[]
): Record<string, TerritoryCollectionSet> {
  const collections = config.territoryCollections || {}
  
  return Object.fromEntries(
    Object.entries(collections).map(([setKey, setConfig]) => [
      setKey,
      {
        id: setKey,
        label: resolveI18nValue(setConfig.label, locale),
        description: setConfig.description 
          ? resolveI18nValue(setConfig.description, locale)
          : undefined,
        collections: setConfig.collections.map(collection => ({
          id: collection.id,
          label: resolveI18nValue(collection.label, locale),
          territories: expandTerritories(
            collection.territories,
            collection.exclude,
            allTerritoryCodes
          ),
          exclude: collection.exclude,
        })),
      },
    ])
  )
}

/**
 * Expand wildcard territories
 */
function expandTerritories(
  territories: '*' | string[],
  exclude: string[] | undefined,
  allCodes: string[]
): string[] {
  if (territories === '*') {
    return exclude 
      ? allCodes.filter(code => !exclude.includes(code))
      : allCodes
  }
  return territories
}

/**
 * Create legacy territory modes from territoryCollections for backward compatibility
 * Gets UI configuration from registry to determine which collection set to use
 */
function createLegacyTerritoryModes(
  atlasId: string,
  config: JSONAtlasConfig,
  collectionSets: Record<string, TerritoryCollectionSet>,
  mainlandCode: string,
  isSingleFocusPattern: boolean
): Record<string, TerritoryCollection> {
  // Get behavior config from registry
  const uiConfig = getUICollectionConfig(atlasId)
  
  // If using new schema, extract from specified collection set
  if (config.territoryCollections && uiConfig?.territorySelectorCollection) {
    const selectorSet = collectionSets[uiConfig.territorySelectorCollection]
    if (selectorSet) {
      return Object.fromEntries(
        selectorSet.collections.map(c => [
          c.id,
          {
            ...c,
            // Filter out mainland for single-focus atlases
            territories: isSingleFocusPattern
              ? c.territories.filter(code => code !== mainlandCode && code !== '*')
              : c.territories,
          },
        ])
      )
    }
  }
  
  // Fallback to legacy modes
  return createTerritoryModes(config, mainlandCode, isSingleFocusPattern, locale, allTerritoryCodes)
}

/**
 * Create legacy territory groups from territoryCollections for backward compatibility
 * Gets UI configuration from registry to determine which collection set to use
 */
function createLegacyTerritoryGroups(
  atlasId: string,
  config: JSONAtlasConfig,
  collectionSets: Record<string, TerritoryCollectionSet>
): Record<string, Omit<TerritoryCollection, 'id'>> {
  // Get behavior config from registry
  const uiConfig = getUICollectionConfig(atlasId)
  
  // If using new schema, extract from specified collection set
  if (config.territoryCollections && uiConfig?.territoryTagsCollection) {
    const tagsSet = collectionSets[uiConfig.territoryTagsCollection]
    if (tagsSet) {
      return Object.fromEntries(
        tagsSet.collections.map(c => [
          c.id.toUpperCase(),
          {
            label: c.label,
            territories: c.territories,
          },
        ])
      )
    }
  }
  
  // Fallback to legacy groups
  return createTerritoryGroups(config, locale)
}
```

Update `AtlasSpecificConfig`:
```typescript
export interface AtlasSpecificConfig {
  projectionParams: ProjectionParameters
  
  // New unified collections
  territoryCollectionSets: Record<string, TerritoryCollectionSet>
  
  // Legacy fields - derived from collections for backward compatibility
  territoryModes: Record<string, TerritoryCollection>
  territoryGroups?: Record<string, Omit<TerritoryCollection, 'id'>>
  
  projectionPreferences?: ProjectionPreferences
  rawModeLabels: Record<string, I18nValue>
  rawGroupLabels?: Record<string, I18nValue>
  
  // New raw labels for collections
  rawCollectionLabels?: Record<string, Record<string, I18nValue>>
}
```

Update `loadAtlasConfig` signature and implementation:
```typescript
export function loadAtlasConfig(atlasId: string, jsonConfig: JSONAtlasConfig): LoadedAtlasConfig {
  const locale = getCurrentLocale()
  const territories = extractTerritories(jsonConfig, locale)
  const allTerritoryCodes = territories.all.map(t => t.code)
  
  // Transform new unified collections
  const collectionSets = transformTerritoryCollections(
    jsonConfig,
    locale,
    allTerritoryCodes
  )
  
  // Create legacy modes/groups for backward compatibility
  // Now uses registry behavior config to determine which collections to use
  const isSingleFocusPattern = territories.type === 'single-focus'
  const territoryModes = createLegacyTerritoryModes(
    atlasId,  // NEW: pass atlas ID to access registry
    jsonConfig,
    collectionSets,
    territories.mainland.code,
    isSingleFocusPattern
  )
  const territoryGroups = createLegacyTerritoryGroups(
    atlasId,  // NEW: pass atlas ID to access registry
    jsonConfig,
    collectionSets
  )
  
  // ... rest of existing code ...
  
  const atlasSpecificConfig: AtlasSpecificConfig = {
    projectionParams,
    territoryCollectionSets: collectionSets,
    territoryModes,
    territoryGroups,
    projectionPreferences,
    rawModeLabels,
    rawGroupLabels,
    rawCollectionLabels: extractRawCollectionLabels(jsonConfig),
  }
  
  return { atlasConfig, atlasSpecificConfig, territories }
}
```

Update `loadAtlasAsync` to pass atlas ID:
```typescript
export async function loadAtlasAsync(atlasId: string): Promise<LoadedAtlasConfig> {
  // ... existing fetch logic ...
  
  // Transform the config (now passing atlasId)
  const loaded = loadAtlasConfig(atlasId, jsonConfig)
  
  // Cache and return
  LOADED_CONFIGS.set(atlasId, loaded)
  return loaded
}

#### 2.3 Update Atlas Service
**File**: `src/services/atlas/atlas-service.ts`

Add new methods and update to use registry behavior:
```typescript
import { getUICollectionConfig } from '@/core/atlases/registry'

export class AtlasService {
  // ... existing code ...
  
  /**
   * Get all territory collection sets
   */
  getTerritoryCollectionSets(): Record<string, TerritoryCollectionSet> {
    return this.specificConfig.territoryCollectionSets
  }
  
  /**
   * Get a specific collection set by key
   */
  getCollectionSet(setKey: string): TerritoryCollectionSet | undefined {
    return this.specificConfig.territoryCollectionSets[setKey]
  }
  
  /**
   * Get a specific collection from a set
   */
  getCollection(setKey: string, collectionId: string): TerritoryCollection | undefined {
    const set = this.getCollectionSet(setKey)
    return set?.collections.find(c => c.id === collectionId)
  }
  
  /**
   * Get collection set to use for territory selector dropdown
   * Gets configuration from registry behavior
   */
  getTerritorySelectorCollectionSet(): TerritoryCollectionSet | undefined {
    const uiConfig = getUICollectionConfig(this.atlasId)
    const setKey = uiConfig?.territorySelectorCollection
    return setKey ? this.getCollectionSet(setKey) : undefined
  }
  
  /**
   * Get collection set to use for territory tags
   * Gets configuration from registry behavior
   */
  getTerritoryTagsCollectionSet(): TerritoryCollectionSet | undefined {
    const uiConfig = getUICollectionConfig(this.atlasId)
    const setKey = uiConfig?.territoryTagsCollection
    return setKey ? this.getCollectionSet(setKey) : undefined
  }
  
  /**
   * Get UI collection configuration from registry
   */
  getUICollectionConfig(): AtlasBehaviorConfig['ui'] | undefined {
    return getUICollectionConfig(this.atlasId)
  }
}
```

Update `AtlasConfig` interface to remove UI fields:
**File**: `src/types/atlas.ts`

```typescript
export interface AtlasConfig {
  // ... existing fields ...
  
  // REMOVED - now in registry behavior config:
  // - defaultPreset
  // - availablePresets
  // - defaultTerritoryMode
  // - territoryModeOptions (derived from modes)
  // - ui
}
```

### Phase 3: Update Configuration Files

#### 3.1 Update Atlas Registry
**File**: `configs/atlas-registry.json`

```json
{
  "$schema": "./atlas-registry.schema.json",
  "defaultAtlas": "france",
  "groups": [
    {
      "id": "country",
      "label": { "en": "Countries", "fr": "Pays" },
      "sortOrder": 1
    },
    {
      "id": "region",
      "label": { "en": "Regions & Unions", "fr": "Régions & Unions" },
      "sortOrder": 2
    },
    {
      "id": "world",
      "label": { "en": "World", "fr": "Monde" },
      "sortOrder": 3
    }
  ],
  "atlases": [
    {
      "id": "france",
      "name": { "en": "France", "fr": "France" },
      "group": "country",
      "sortOrder": 10,
      "configPath": "./atlases/france.json",
      "behavior": {
        "defaultPreset": "france-default",
        "availablePresets": ["france-default", "france-test", "france-nsp"],
        "defaultTerritoryCollection": "administrative:metropole-drom-com",
        "ui": {
          "territorySelectorCollection": "administrative",
          "territoryTagsCollection": "geographic"
        }
      }
    },
    {
      "id": "portugal",
      "name": { "en": "Portugal", "fr": "Portugal" },
      "group": "country",
      "sortOrder": 20,
      "configPath": "./atlases/portugal.json",
      "behavior": {
        "defaultPreset": "portugal-default",
        "availablePresets": ["portugal-default", "portugal-split", "portugal-unified"],
        "defaultTerritoryCollection": "administrative:all-territories",
        "ui": {
          "territorySelectorCollection": "administrative",
          "territoryTagsCollection": "geographic"
        }
      }
    },
    {
      "id": "usa",
      "name": { "en": "United States", "fr": "États-Unis" },
      "group": "country",
      "sortOrder": 30,
      "configPath": "./atlases/usa.json",
      "behavior": {
        "defaultPreset": "usa-default",
        "availablePresets": ["usa-default", "usa-split", "usa-unified"],
        "defaultTerritoryCollection": "administrative:all-states",
        "ui": {
          "territorySelectorCollection": "administrative",
          "territoryTagsCollection": "geographic"
        }
      }
    },
    {
      "id": "eu",
      "name": { "en": "European Union", "fr": "Union Européenne" },
      "group": "region",
      "sortOrder": 100,
      "configPath": "./atlases/eu.json",
      "behavior": {
        "defaultPreset": "eu-default",
        "availablePresets": ["eu-default", "eu-split", "eu-unified"],
        "defaultTerritoryCollection": "administrative:all-members",
        "ui": {
          "territorySelectorCollection": "administrative",
          "territoryTagsCollection": "geographic"
        }
      }
    },
    {
      "id": "world",
      "name": { "en": "World", "fr": "Monde" },
      "group": "world",
      "sortOrder": 200,
      "configPath": "./atlases/world.json",
      "behavior": {
        "availablePresets": ["world-unified"],
        "defaultTerritoryCollection": "administrative:without-antarctica",
        "ui": {
          "territorySelectorCollection": "administrative",
          "territoryTagsCollection": "geographic"
        }
      }
    }
  ]
}
```

#### 3.2 France Atlas
**File**: `configs/atlases/france.json`

Remove UI/application fields and add territoryCollections:

```json
{
  "$schema": "./atlas.schema.json",
  "id": "france",
  "name": { "en": "France", "fr": "France" },
  "description": {
    "en": "Metropolitan France and overseas territories",
    "fr": "France métropolitaine et territoires d'outre-mer"
  },
  "category": "country",
  "dataSources": {
    "territories": "france-territories-50m.json",
    "metadata": "france-metadata-50m.json"
  },
  
  "territories": [
    // ... existing territories array unchanged ...
  ],
  
  "territoryCollections": {
    "administrative": {
      "label": {
        "en": "Administrative status",
        "fr": "Statut administratif"
      },
      "description": {
        "en": "Territories grouped by political and administrative status",
        "fr": "Territoires regroupés par statut politique et administratif"
      },
      "collections": [
        {
          "id": "metropole-only",
          "label": {
            "en": "Metropolitan France only",
            "fr": "France métropolitaine uniquement"
          },
          "territories": ["FR-MET"]
        },
        {
          "id": "metropole-drom",
          "label": {
            "en": "Mainland + Overseas Departments",
            "fr": "Métropole + DROM"
          },
          "territories": ["FR-MET", "FR-GF", "FR-RE", "FR-GP", "FR-MQ", "FR-YT"]
        },
        {
          "id": "metropole-drom-com",
          "label": {
            "en": "Mainland + Overseas Departments + Collectivities",
            "fr": "Métropole + DROM + COM"
          },
          "territories": ["FR-MET", "FR-GF", "FR-RE", "FR-GP", "FR-MQ", "FR-YT", "FR-PM", "FR-BL", "FR-PF", "FR-WF", "FR-PF-2", "FR-NC"]
        },
        {
          "id": "all-territories",
          "label": {
            "en": "All territories",
            "fr": "Tous les territoires"
          },
          "territories": "*"
        }
      ]
    },
    "geographic": {
      "label": {
        "en": "Geographic regions",
        "fr": "Régions géographiques"
      },
      "description": {
        "en": "Territories grouped by ocean and geographic location",
        "fr": "Territoires regroupés par océan et localisation géographique"
      },
      "collections": [
        {
          "id": "mainland",
          "label": {
            "en": "Metropolitan France",
            "fr": "France Métropolitaine"
          },
          "territories": ["FR-MET"]
        },
        {
          "id": "caribbean",
          "label": {
            "en": "Caribbean",
            "fr": "Caraïbes"
          },
          "territories": ["FR-GP", "FR-MQ", "FR-GF", "FR-BL", "FR-MF"]
        },
        {
          "id": "indian-ocean",
          "label": {
            "en": "Indian Ocean",
            "fr": "Océan Indien"
          },
          "territories": ["FR-RE", "FR-YT", "FR-TF"]
        },
        {
          "id": "pacific",
          "label": {
            "en": "Pacific Ocean",
            "fr": "Océan Pacifique"
          },
          "territories": ["FR-NC", "FR-PF", "FR-PF-2", "FR-WF"]
        },
        {
          "id": "north-atlantic",
          "label": {
            "en": "North Atlantic",
            "fr": "Atlantique Nord"
          },
          "territories": ["FR-PM"]
        }
      ]
    }
  }
}
```

**REMOVED from france.json**:
- `availablePresets`
- `defaultPreset`
- `defaultTerritoryMode`
- `modes`
- `groups`

#### 3.3 Portugal Atlas
**File**: `configs/atlases/portugal.json`

Remove UI/application fields and add territoryCollections:

```json
{
  "$schema": "./atlas.schema.json",
  "id": "portugal",
  "name": { "en": "Portugal", "fr": "Portugal" },
  "description": {
    "en": "Continental Portugal and autonomous regions",
    "fr": "Portugal continental et régions autonomes"
  },
  "category": "country",
  "dataSources": {
    "territories": "portugal-territories-50m.json",
    "metadata": "portugal-metadata-50m.json"
  },
  
  "territories": [
    // ... existing territories array unchanged ...
  ],
  
  "territoryCollections": {
    "administrative": {
      "label": {
        "en": "Administrative regions",
        "fr": "Régions administratives"
      },
      "collections": [
        {
          "id": "mainland-only",
          "label": {
            "en": "Continental Portugal only",
            "fr": "Portugal continental uniquement"
          },
          "territories": ["PT-CONT"]
        },
        {
          "id": "with-madeira",
          "label": {
            "en": "Continental + Madeira",
            "fr": "Continental + Madère"
          },
          "territories": ["PT-CONT", "PT-20"]
        },
        {
          "id": "all-territories",
          "label": {
            "en": "All autonomous regions",
            "fr": "Toutes les régions autonomes"
          },
          "territories": "*"
        }
      ]
    },
    "geographic": {
      "label": {
        "en": "Geographic location",
        "fr": "Localisation géographique"
      },
      "collections": [
        {
          "id": "mainland",
          "label": {
            "en": "Continental Portugal",
            "fr": "Portugal continental"
          },
          "territories": ["PT-CONT"]
        },
        {
          "id": "atlantic",
          "label": {
            "en": "Atlantic autonomous regions",
            "fr": "Régions autonomes atlantique"
          },
          "territories": ["PT-20", "PT-30"]
        }
      ]
    }
  }
}
```

**REMOVED from portugal.json**:
- `defaultPreset`
- `availablePresets`
- `defaultTerritoryMode`
- `modes`
- `groups`

### Phase 4: UI Component Updates

#### 4.1 Update TerritorySetManager
**File**: `src/components/ui/parameters/TerritorySetManager.vue`

```vue
<script setup lang="ts">
import { computed } from 'vue'
import { useI18n } from 'vue-i18n'
import { useConfigStore } from '@/stores/config'
import { useGeoDataStore } from '@/stores/geoData'

const { t } = useI18n()
const configStore = useConfigStore()
const geoDataStore = useGeoDataStore()

// Get the collection set to use for tags (from atlas UI config)
const tagsCollectionSet = computed(() => {
  const atlasConfig = configStore.currentAtlasConfig
  const setKey = atlasConfig?.ui?.territoryTagsCollection
  
  if (!setKey) return null
  
  return configStore.atlasService?.getCollectionSet(setKey)
})

// Transform collections into UI groups
const territoryGroups = computed(() => {
  const collectionSet = tagsCollectionSet.value
  if (!collectionSet) return []
  
  const mainlandCode = configStore.currentAtlasConfig?.splitModeConfig?.mainlandCode
  const loadedTerritories = geoDataStore.overseasTerritoriesData
  const activeCodes = new Set(geoDataStore.overseasTerritories.map(t => t.code))
  const territoriesByCode = new Map(loadedTerritories.map(t => [t.code, t]))
  
  return collectionSet.collections
    .map(collection => ({
      id: collection.id,
      label: collection.label,
      territories: collection.territories
        .filter(code => code !== mainlandCode && territoriesByCode.has(code))
        .map(code => {
          const territory = territoriesByCode.get(code)!
          return {
            code,
            name: territory.name,
            isActive: activeCodes.has(code),
          }
        }),
    }))
    .filter(group => group.territories.length > 0)
})

function toggleTerritory(code: string, isActive: boolean) {
  if (isActive) {
    configStore.removeTerritoryFromComposite(code)
  } else {
    configStore.addTerritoryToComposite(code)
  }
  geoDataStore.triggerRender()
}
</script>

<template>
  <!-- Template remains the same -->
</template>
```

#### 4.2 Update Territory Selector Dropdown
**File**: `src/components/configuration/AtlasConfigSection.vue`

Update to use registry behavior config:

```vue
<script setup lang="ts">
import { computed } from 'vue'
import { useConfigStore } from '@/stores/config'
import { getUICollectionConfig } from '@/core/atlases/registry'

const configStore = useConfigStore()

// Get territory selector options from registry-specified collection
const territorySelectorOptions = computed(() => {
  const atlasId = configStore.selectedAtlas
  const uiConfig = getUICollectionConfig(atlasId)
  const setKey = uiConfig?.territorySelectorCollection
  
  if (!setKey) return []
  
  const collectionSet = configStore.atlasService?.getCollectionSet(setKey)
  if (!collectionSet) return []
  
  return collectionSet.collections.map(collection => ({
    value: collection.id,
    label: collection.label,
  }))
})
</script>
```

### Phase 5: Remove Legacy Code

After verifying the new system works:

1. Remove `modes` and `groups` from all JSON config files
2. Remove `createTerritoryModes()` and `createTerritoryGroups()` from loader
3. Remove legacy fields from `AtlasSpecificConfig`
4. Remove `TerritoryModeConfig` and `TerritoryGroupConfig` type definitions
5. Update all documentation

## Benefits of New Schema

### 1. **Unified & Extensible**
- Single `territoryCollections` concept instead of two overlapping systems (`modes` + `groups`)
- User-defined collection set keys enable unlimited grouping strategies
- Easy to add new grouping dimensions (timezone, language, population, historical, etc.)
- Same collection data can be used in multiple UI contexts

### 2. **Clear Separation of Concerns**
- **Atlas configs**: Pure territory data structure and relationships
- **Registry**: Application behavior, UI configuration, defaults
- Data layer completely independent from presentation layer
- Same atlas can be used in different applications with different UI behaviors

### 3. **Reusability & Portability**
- Atlas configs can be used by CLI tools, export generators, documentation builders
- No UI assumptions in data structure
- Easy to create different frontends with same data
- Collections defined once, used flexibly

### 4. **Better DX**
- Self-documenting config structure
- Type-safe with clear interfaces
- Validation via JSON schema
- Easy to understand what goes where

### 5. **Flexible UI Mapping**
- Registry specifies which collection for which UI element
- Easy to A/B test different grouping strategies
- No need to edit atlas configs to change UI behavior
- Per-atlas customization in one place (registry)

### 6. **Future-Proof**
- Can add new UI contexts without touching atlas configs
- Extensible `behavior.ui` object for new UI elements
- Supports arbitrary custom groupings per atlas
- No breaking changes when adding features

### 7. **Maintainability**
- UI changes only touch registry
- Territory structure changes only touch atlas configs
- Clear boundaries reduce coupling
- Easier to reason about changes

## Example Use Cases

### Use Case 1: Geographic Tags, Administrative Selector
**Registry (behavior config)**:
```json
{
  "behavior": {
    "ui": {
      "territorySelectorCollection": "administrative",
      "territoryTagsCollection": "geographic"
    }
  }
}
```
Dropdown shows "Métropole + DROM", tags grouped by ocean.

### Use Case 2: Both Use Same Grouping
**Registry (behavior config)**:
```json
{
  "behavior": {
    "ui": {
      "territorySelectorCollection": "administrative",
      "territoryTagsCollection": "administrative"
    }
  }
}
```
Both dropdown and tags use administrative grouping.

### Use Case 3: Custom Historical Grouping
**Atlas config (data structure)**:
```json
{
  "territoryCollections": {
    "historical": {
      "label": { "en": "Historical periods", "fr": "Périodes historiques" },
      "collections": [
        {
          "id": "pre-1946",
          "label": { "en": "Territories before 1946", "fr": "Territoires avant 1946" },
          "territories": ["FR-MET", "FR-GP", "FR-MQ", "FR-GF", "FR-RE"]
        },
        {
          "id": "post-war",
          "label": { "en": "Modern territories (post-1946)", "fr": "Territoires modernes (après 1946)" },
          "territories": "*"
        }
      ]
    }
  }
}
```

**Registry (application behavior)**:
```json
{
  "behavior": {
    "defaultTerritoryCollection": "historical:pre-1946",
    "ui": {
      "territorySelectorCollection": "historical",
      "territoryTagsCollection": "geographic"
    }
  }
}
```
Selector uses historical periods, tags show by ocean.

### Use Case 4: CLI Tool with Different Defaults
**Same atlas config**, different registry for CLI:
```json
{
  "behavior": {
    "defaultTerritoryCollection": "administrative:all-territories",
    "outputGrouping": "geographic"
  }
}
```
CLI tool generates files grouped by ocean, includes all territories by default.

## Migration Checklist

- [ ] Phase 1: Update schema & types
  - [ ] Update `atlas.schema.json`
  - [ ] Update `types/atlas-config.ts`
  - [ ] Update `src/types/territory.ts`
  
- [ ] Phase 2: Update loader & services
  - [ ] Add `transformTerritoryCollections()` to loader
  - [ ] Add legacy compatibility functions
  - [ ] Update `AtlasSpecificConfig` interface
  - [ ] Update `AtlasService` with new methods
  
- [ ] Phase 3: Update JSON configs
  - [ ] Migrate `france.json`
  - [ ] Migrate `portugal.json`
  - [ ] Migrate `usa.json`
  - [ ] Migrate `eu.json`
  - [ ] Migrate `world.json`
  
- [ ] Phase 4: Update UI components
  - [ ] Update `TerritorySetManager.vue`
  - [ ] Update `AtlasConfigSection.vue`
  - [ ] Update any other components using modes/groups
  
- [ ] Phase 5: Testing
  - [ ] Verify territory selector dropdown works
  - [ ] Verify territory tags grouping works
  - [ ] Test switching between atlases
  - [ ] Test custom collections
  - [ ] Validate all configs against schema
  
- [ ] Phase 6: Documentation
  - [ ] Update `docs/atlases.llm.txt`
  - [ ] Update `docs/add-new-atlas.llm.txt`
  - [ ] Add examples for custom collections
  
- [ ] Phase 7: Cleanup
  - [ ] Remove legacy `modes` from configs
  - [ ] Remove legacy `groups` from configs
  - [ ] Remove legacy functions from loader
  - [ ] Remove legacy type definitions
  - [ ] Remove deprecated fields from interfaces

## Backward Compatibility Strategy

During migration, support both old and new schemas:

1. **Loader checks for new schema first**:
   - If `territoryCollections` exists → use new system
   - If missing → fall back to legacy `modes` + `groups`

2. **Legacy adapters**:
   - `createLegacyTerritoryModes()` - converts selection-preset → modes
   - `createLegacyTerritoryGroups()` - converts visual-grouping → groups

3. **Gradual migration**:
   - Migrate one atlas at a time
   - Test thoroughly before moving to next
   - Keep legacy support until all configs migrated

4. **Final cleanup**:
   - Only after ALL configs migrated
   - Remove legacy functions
   - Simplify loader code

## Status
Status: COMPLETE
Started: 2025-10-18
Completed: 2025-10-20
Last Updated: 2025-10-20

## Implementation Notes

### Completed Work
All phases 1-5 completed successfully:
- Phase 1: Schema and type system with deprecation markers
- Phase 2: Loaders and services with backward compatibility
- Phase 3: Config migration (france.json, portugal.json, atlas-registry.json)
- Phase 4: UI components (TerritorySetManager.vue)
- Phase 5: Testing, service layer fixes, and validation

### Key Pattern Established
All services and components now use registry behavior instead of atlas config for preset-related fields:
```typescript
// Pattern: Reading from registry behavior
const behavior = getAtlasBehavior(atlasId)
const preset = behavior?.defaultPreset
const presets = behavior?.availablePresets
```

### Files Updated in Phase 5
- src/services/initialization/initialization-service.ts
- src/components/ui/presets/PresetSelector.vue
- src/components/MapRenderer.vue
- src/composables/useProjectionConfig.ts
- src/composables/useViewState.ts

### Remaining Work
- Migrate remaining atlases (eu.json, usa.json, world.json)
- Add missing translation key: territory.setManager.noCollections
- Remove legacy compatibility code after all atlases migrated
