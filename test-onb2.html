<!doctype html>
<notebook theme="air">
  <title>Untitled</title>
  <script id="1" type="text/markdown">
    # Untitled
  </script>
  <script id="13" type="module" pinned="">
    // Load CSV from a file
    const data = FileAttachment("your-file.csv").csv();
  </script>
  <script id="7" type="module" pinned="">
    import d3CompositeProjections from "npm:d3-composite-projections@1"
  </script>
  <script id="9" type="application/vnd.observable.javascript" pinned="">
    /**
     * Génère un choroplèthe pour une couche géo donnée et des données tabulaires.
     * Ajout : interaction pointer/tip via des centroïdes (Observable Plot).
     *
     * @param {Object} options - options de rendu (voir détails ci-dessous)
     * @returns {SVGElement|Figure} - le graphique Plot
     */
    function renderChoropleth(options = {}) {

      // ----- 1) Configuration (identique à ta version) ---------------------------
      const {
        // Données & jointure
        tabularData,                                // Array d'objets: lignes CSV/JSON
        featureCollection,                          // FeatureCollection GeoJSON
        featureKey = f => f.properties?.INSEE_DEP,  // fn: Feature -> clé (ex: "04")
        rowKey = r => r.DEP,                        // fn: Row -> clé (ex: "04")
        valueAccessor = r => r.pct_pop,             // fn: Row -> valeur numérique
        rowFilter = null,                           // fn: Row -> boolean (ex: r.Libelle === ...)
        numberNormalizer = v => {
          if (v == null || v === "") return null;
          return typeof v === "number" ? v : +String(v).replace(",", ".");
        },

        // Mise en forme / couleurs
        colorScale = {
          legend: true,
          type: "quantize",
          scheme: "blues",
          domain: [0, 1],
          label: ""
        },
        fillUnknown = "#eee",

        // Projection / dimensions
        projection = d3CompositeProjections.geoConicConformalFrance(),
        width = 960,
        height = 500,
        inset = 8,
        showLegend = true, // conservé pour compat (même si non utilisé ici)

        // Overlays (meshes / aplats)
        backgroundFill = "#d8d8d8",
        backgroundGeometry = null,                  // ex: departementsOuterMesh
        overlayMeshes = [],                         // ex: [{geo: epciMesh, stroke: 'white', strokeWidth: .5}, ...]
        outlineGeometry = null,                     // ex: departementsOuterMesh
        outlineStroke = "#222",
        outlineStrokeWidth = 1,

        // Titre/tooltip
        titleBuilder = (feature, value, row) => {
          const nom = feature.properties?.NOM ?? feature.properties?.nom ?? featureKey(feature);
          const txtVal = value == null ? "—" : (value <= 1 && value >= 0 ? `${(value*100).toFixed(1)} %` : `${value}`);
          return `${nom}\n${txtVal}`;
        },

        // Option titre global (facultatif)
        plotTitle = null
      } = options;

      // ----- 2) Index de jointure (clé -> {row, value}) -------------------------
      const filteredRows = rowFilter ? tabularData.filter(rowFilter) : tabularData;

      const rowIndex = new Map();
      for (const row of filteredRows) {
        const key = String(rowKey(row)).padStart(2, "0"); // "4" -> "04"
        const value = numberNormalizer(valueAccessor(row));
        rowIndex.set(key, { row, value });
      }

      // Accesseurs communs aux marks
      const fillByFeature = (feature) => {
        const key = String(featureKey(feature)).padStart(2, "0");
        const hit = rowIndex.get(key);
        return hit ? hit.value : null;
      };

      const titleByFeature = (feature) => {
        const key = String(featureKey(feature)).padStart(2, "0");
        const hit = rowIndex.get(key);
        return titleBuilder(feature, hit?.value ?? null, hit?.row ?? null);
      };

      // ----- 2.b Centroïdes pour l’interaction pointer --------------------------
      // Plot.pointer fonctionne au mieux avec des points. On ajoute donc une
      // petite couche de points (centroïdes) : elle n’altère pas le rendu,
      // mais porte la logique “nearest point to cursor”.
      const centroidData = featureCollection.features.map((f) => {
        const [lon, lat] = d3.geoCentroid(f);                // coordonnées géographiques
        const key = String(featureKey(f)).padStart(2, "0");
        const hit = rowIndex.get(key) || {};
        return {
          lon, lat,                                          // utilisés par Plot + projection
          value: hit?.value ?? null,
          feature: f,
          row: hit?.row ?? null,
          name: f.properties?.NOM ?? f.properties?.nom ?? key
        };
      });

      // ----- 3) Construction du graphique ---------------------------------------
      const chart = Plot.plot({
        title: plotTitle ?? null,
        width,
        height,
        inset,
        projection,
        color: { ...colorScale },
        marks: [

          // (a) Aplat de fond (optionnel) - non interactif
          ...(backgroundGeometry
            ? [Plot.geo(backgroundGeometry, { fill: backgroundFill, pointerEvents: "none" })]
            : []),

          // (b) Polygones colorés : la couche choroplèthe principale
          //     -> on garde title pour un fallback tooltip natif
          Plot.geo(featureCollection, {
            fill: f => fillByFeature(f) ?? fillUnknown,
            title: titleByFeature,
            stroke: null
          }),

          // (c) Interaction pointer via centroïdes :
          //     - Plot.pointer garde le point le plus proche du curseur
          //     - Plot.tip affiche une infobulle utile
          //     - Le point est visuellement discret (r=0, ou fill:"none") mais
          //       on dessine un petit halo de survol pour le feedback.
          Plot.tip(
            Plot.pointer(
              Plot.dot(centroidData, {
                x: d => d.lon,           // lon/lat, laissés en degrés: Plot gère la projection
                y: d => d.lat,
                r: 4,                    // petit halo de survol
                // fill: "none",            // pas de remplissage permanent
                stroke: "black",
                strokeWidth: 1.25,
                // Texte du tooltip :
                title: d => {
                  const v = d.value;
                  const vTxt = v == null ? "—" : (v <= 1 && v >= 0 ? `${(v * 100).toFixed(1)} %` : `${v}`);
                  return `${d.name}\n${vTxt}`;
                }
              }),
              // options pointer (facultatif) — par défaut, rayon ~40px
              // {x: "lon", y: "lat"} // (Plot les infère des channels)
            )
          ),

          // (d) Overlays/meshes au-dessus, mais non interactifs
          ...overlayMeshes.map(({ geo, ...rest }) =>
            Plot.geo(geo, { pointerEvents: "none", ...rest })
          ),

          // (e) Contour externe (au-dessus), non interactif
          ...(outlineGeometry
            ? [Plot.geo(outlineGeometry, { stroke: outlineStroke, strokeWidth: outlineStrokeWidth, pointerEvents: "none" })]
            : [])
        ]
      });

      // ----- 4) Limites de composition (Corse + DROM) ---------------------------
      // Ajout dans le bon repère, que Plot retourne un <svg> direct ou un <figure>.
      const svg = d3.select(chart).select("svg").node()
        ? d3.select(chart).select("svg")
        : d3.select(chart);

      svg.select("g[aria-label='plot'], g.plot, g.layer")
        .append("path")
        .attr("d", projection.getCompositionBorders?.())
        .attr("fill", "none")
        .attr("stroke", "#ddd")
        .attr("stroke-width", 1)
        .attr("pointer-events", "none");

      return chart;
    }
  </script>
</notebook>
