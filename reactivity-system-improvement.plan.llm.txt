# Reactivity System Improvement Plan

## Objective
Simplify and strengthen the reactivity system by removing fallback mechanisms, making rendering depend entirely on valid preset data, and establishing clear, predictable initialization and data flow paths.

## Current Architecture Analysis

### Problem Areas

#### 1. Multiple Initialization Paths
**Current State:**
- **Atlas Initialization**: `AtlasCoordinator.handleAtlasChange()` → loads preset → converts to defaults → applies to stores
- **Preset Switching (Composite-Custom)**: `PresetSelector.vue` → duplicates AtlasCoordinator logic → manual store updates
- **View Preset Loading**: `configStore.loadViewPreset()` → `PresetApplicationService` → simpler parameter setting
- **Import Feature**: `ImportModal.vue` → `CompositeImportService` → direct store manipulation

**Issues:**
- Logic duplication between AtlasCoordinator and PresetSelector
- Import feature bypasses normal initialization paths
- Different code paths can result in inconsistent state

#### 2. Fallback Mechanisms Creating Complexity
**Current State:**
- `configStore` initializes with fallback projection ('natural-earth') before preset loads
- Territory defaults commented out but complexity remains
- Parameter store has defensive null/undefined checks everywhere
- Cartographer filters territories without parameters during initialization
- Multiple "preset not loaded yet" guards throughout codebase

**Issues:**
- Hard to debug when fallbacks trigger vs preset values used
- Unclear what state is "valid" vs "temporary"
- Defensive programming hides missing data issues
- Cannot distinguish "loading" from "invalid preset"

#### 3. Data Loading Based on View Mode
**Current State:**
- `useAtlasData.ts` loads different data based on view mode
- Split/composite-custom → load territory data
- Unified → load unified data
- Built-in-composite → uses composite projection library

**Issues:**
- Not all data is loaded upfront
- Switching view modes triggers async data loading
- Unclear if data is preserved when switching back
- Some params should reset on atlas change but don't

#### 4. Complex Watcher Network
**Current State:**
- `configStore`: 3 watchers (viewMode, selectedAtlas × 2)
- `useAtlasData`: 3 watchers (viewMode, currentAtlasConfig, territoryMode)
- `useMapWatchers`: 6 watchers (projectionParams, fittingMode, canvasDimensions, referenceScale, renderKey, dependencies)
- Multiple duplicate watchers for same events (selectedAtlas watched twice in configStore)

**Issues:**
- Difficult to trace execution order
- Race conditions possible (atlas changes while preset loading)
- Unclear which watcher is responsible for what
- Some watchers clear parameters, others restore them

#### 5. Parameter Preservation vs Reset Issues
**Current State:**
- Some parameters preserved across atlas changes
- Global parameters cleared on view mode change, then restored from preset
- Territory parameters may persist when they shouldn't
- `presetDefaults` tracks original values but reset logic inconsistent

**Issues:**
- Cannot tell what should persist vs reset
- User edits can be lost unexpectedly
- Or conversely, old parameters contaminate new atlas

#### 6. View Mode Suitability Not Enforced
**Current State:**
- Atlas configs declare `supportedViewModes`
- Code switches to `defaultViewMode` if current not supported
- But UI doesn't prevent manual switching to unsupported modes

**Issues:**
- Users can force unsupported view modes
- Results in broken rendering or fallback behavior
- Unclear which combinations are valid

### Affected Domains
- [x] Atlas System (docs/atlases.llm.txt) - initialization flow
- [x] Preset System (docs/presets.llm.txt) - loading paths and validation
- [x] Parameter Management (docs/services.llm.txt) - store initialization
- [x] Vue Architecture (docs/vue-architecture.llm.txt) - composables and watchers
- [x] Rendering (docs/services.llm.txt) - cartographer initialization

## Context
- Architecture: docs/architecture.llm.txt
- Domain docs: docs/atlases.llm.txt, docs/presets.llm.txt, docs/services.llm.txt, docs/vue-architecture.llm.txt

## Proposed Solution

### Phase 1: Consolidate Initialization Paths

#### 1.1 Create Single Initialization Service
**File**: `src/services/initialization/initialization-service.ts` (NEW)

**Responsibilities:**
- Single entry point for all initialization scenarios
- Orchestrates preset loading, validation, and store application
- Replaces duplicated logic in AtlasCoordinator, PresetSelector, ImportModal

**API:**
```typescript
class InitializationService {
  // Atlas initialization (app startup, atlas change)
  static async initializeAtlas(atlasId: string): Promise<InitializationResult>
  
  // Preset switching (within same atlas)
  static async loadPreset(presetId: string): Promise<InitializationResult>
  
  // Import feature (user uploads JSON)
  static async importConfiguration(config: ExportedCompositeConfig): Promise<InitializationResult>
  
  // View mode change (switches between unified/split/built-in-composite)
  static async changeViewMode(viewMode: ViewMode): Promise<InitializationResult>
}

interface InitializationResult {
  success: boolean
  errors: string[]
  warnings: string[]
  state: ApplicationState // Complete state snapshot
}
```

**Benefits:**
- All initialization flows go through same validation
- Easier to trace and debug
- Consistent error handling
- Single place to enforce business rules

#### 1.2 Refactor Store Initialization
**Files**: 
- `src/stores/config.ts` - remove duplicate atlas change watchers
- `src/stores/parameters.ts` - simplify initialization
- `src/composables/useAtlasData.ts` - delegate to InitializationService

**Changes:**
- Remove `initializeWithPresetMetadata()` from configStore (move to InitializationService)
- Remove duplicate `watch(selectedAtlas)` watchers (keep only one)
- Remove manual store updates from PresetSelector
- Use InitializationService for all initialization scenarios

#### 1.3 Update UI Components
**Files**:
- `src/components/ui/presets/PresetSelector.vue` - use InitializationService
- `src/components/ui/import/ImportModal.vue` - use InitializationService

**Changes:**
- Remove duplicated converter logic
- Call `InitializationService.loadPreset()` or `importConfiguration()`
- Display errors/warnings from InitializationResult

### Phase 2: Remove Fallback Mechanisms

#### 2.1 Enforce Valid Preset Loading
**File**: `src/stores/config.ts`

**Changes:**
- Remove fallback initial values ('natural-earth', 'conic-conformal-france')
- Make `selectedProjection`, `compositeProjection` nullable
- Components must check for null and show loading state
- Fail fast if preset loading fails (no silent fallbacks)

**Result:**
- Clear distinction between "loading" and "loaded with data"
- Easier to spot missing preset data
- Forces proper error handling

#### 2.2 Strict Territory Filtering
**File**: `src/stores/geoData.ts`

**Current:**
```typescript
// Filter compositeConfig to only include territories with projectionId
const filteredOverseas = compositeConfig.overseasTerritories.filter((territory) => {
  const params = parameterStore.getEffectiveParameters(territory.code)
  return !!params.projectionId
})
```

**Proposed:**
- Remove filtering during initialization
- Validate preset completeness BEFORE initialization
- Throw error if preset is missing territories that atlas requires
- Or accept that preset defines which territories to render (current behavior but make explicit)

**Result:**
- No silent territory omission
- Clear validation errors if preset is incomplete
- Easier to debug missing territories

#### 2.3 Remove Defensive Null Checks
**Files**: `src/stores/parameters.ts`, various components

**Current:**
```typescript
if (value === null || value === undefined) {
  console.warn(`Attempted to set null/undefined value...`)
  return
}
```

**Proposed:**
- Remove silent failures
- Throw errors for invalid inputs
- Let initialization service handle validation upfront
- Components should never pass null/undefined if they have valid data

**Result:**
- Bugs surface immediately instead of silently failing
- Clearer contract: parameters must be valid or operation fails
- Easier to trace where invalid data originates

### Phase 3: Simplify Data Loading

#### 3.1 Preload All Required Data
**File**: `src/services/initialization/initialization-service.ts`

**Strategy:**
- During atlas initialization, load ALL data types upfront:
  - Mainland data (if applicable)
  - Territory data (for all territories in preset)
  - Unified data (if atlas supports unified mode)
  - Built-in composite projections list
- Store all data in geoDataStore
- View mode switching becomes synchronous (data already loaded)

**Benefits:**
- No async delays when switching view modes
- Simpler state management (data either all loaded or not)
- Easier to show loading progress (single loading phase)

#### 3.2 Reset Strategy
**File**: `src/services/initialization/initialization-service.ts`

**Define clear reset rules:**

**On Atlas Change:**
- Clear ALL parameter store data (global + all territories)
- Clear ALL preset defaults
- Clear ALL geo data
- Reload everything from new atlas preset

**On View Mode Change (same atlas):**
- Keep territory data loaded
- Clear ONLY global projection parameters
- Load view mode preset if available
- Preserve territory-specific edits in composite-custom mode

**On Preset Switch (same atlas, same view mode):**
- Clear ALL parameters
- Apply new preset parameters
- Keep geo data loaded (unchanged)
- Update preset defaults for reset functionality

**Result:**
- Predictable behavior
- No contamination between atlases
- Clear mental model for users

### Phase 4: Consolidate Watchers

#### 4.1 Create Central Orchestration Watcher
**File**: `src/composables/useApplicationState.ts` (NEW)

**Responsibilities:**
- Single watcher for selectedAtlas (remove duplicates)
- Single watcher for viewMode
- Coordinates initialization service calls
- Manages loading states
- Handles errors globally

**Pattern:**
```typescript
export function useApplicationState() {
  const configStore = useConfigStore()
  const initService = InitializationService
  
  // Single atlas change watcher
  watch(() => configStore.selectedAtlas, async (newAtlas, oldAtlas) => {
    if (!oldAtlas) return // Initial load handled separately
    
    await initService.initializeAtlas(newAtlas)
  })
  
  // Single view mode watcher
  watch(() => configStore.viewMode, async (newMode, oldMode) => {
    if (!oldMode) return
    
    await initService.changeViewMode(newMode)
  })
  
  // ...
}
```

#### 4.2 Simplify Component Watchers
**File**: `src/composables/useMapWatchers.ts`

**Changes:**
- Keep rendering-specific watchers (projectionParams, fittingMode, etc.)
- Remove data loading watchers (delegated to useApplicationState)
- Focus on "what to render" not "what to load"

#### 4.3 Remove Redundant Watchers
**File**: `src/stores/config.ts`

**Current Issues:**
- Two `watch(selectedAtlas)` at lines 482 and 508
- Both trigger on atlas change, doing similar work

**Proposed:**
- Remove both watchers from store
- Move to `useApplicationState` composable
- Store becomes passive (actions only, no watchers)

### Phase 5: Enforce View Mode Suitability

#### 5.1 Disable Unsupported View Modes in UI
**File**: `src/components/ui/forms/ViewModeSelector.vue` (or similar)

**Changes:**
- Mark unsupported view modes as disabled in dropdown
- Show tooltip explaining why disabled
- Prevent manual selection

#### 5.2 Strict View Mode Validation
**File**: `src/services/initialization/initialization-service.ts`

**Logic:**
```typescript
async changeViewMode(viewMode: ViewMode): Promise<InitializationResult> {
  const atlas = configStore.currentAtlasConfig
  
  if (!atlas.supportedViewModes.includes(viewMode)) {
    return {
      success: false,
      errors: [`View mode '${viewMode}' not supported by atlas '${atlas.id}'`],
      warnings: [],
      state: null
    }
  }
  
  // Proceed with change...
}
```

#### 5.3 Auto-Select Compatible View Mode
**Strategy:**
- When switching atlas, if current view mode not supported
- Auto-select atlas's defaultViewMode
- Show notification to user explaining the switch
- Don't allow manual override

**Result:**
- Impossible to get into invalid state
- Clear feedback to users
- Predictable behavior

### Phase 6: Implement Strict Validation

#### 6.1 Preset Validation Service
**File**: `src/services/validation/preset-validation-service.ts` (NEW)

**Responsibilities:**
- Validate preset structure before loading
- Check required parameters are present
- Verify parameter values are in valid ranges
- Ensure territories in preset match atlas territories (or explain mismatch)
- Return actionable error messages

**API:**
```typescript
class PresetValidationService {
  static validatePreset(preset: Preset, atlas: AtlasConfig): ValidationResult
  
  static validateImport(config: ExportedCompositeConfig, atlas: AtlasConfig): ValidationResult
  
  static validateViewModeCompatibility(preset: Preset, viewMode: ViewMode): ValidationResult
}
```

#### 6.2 Fail-Fast Initialization
**File**: `src/services/initialization/initialization-service.ts`

**Strategy:**
- Validate preset BEFORE applying to stores
- If validation fails, show error modal to user
- Don't partially apply invalid data
- Keep previous valid state if new preset fails

**Benefits:**
- Never in half-initialized state
- Clear error messages
- Easy to fix preset issues

### Phase 7: State Machine for Loading States

#### 7.1 Define Application States
**File**: `src/types/application-state.ts` (NEW)

```typescript
type ApplicationState =
  | { status: 'uninitialized' }
  | { status: 'loading-atlas', atlasId: string }
  | { status: 'loading-preset', presetId: string }
  | { status: 'ready', atlas: AtlasConfig, preset: Preset }
  | { status: 'error', error: Error, previousState?: ApplicationState }
```

#### 7.2 Use State Machine
**File**: `src/stores/application.ts` (NEW)

**Benefits:**
- Explicit state transitions
- Impossible states are unrepresentable
- Components can switch on state.status
- Easier to reason about valid transitions

### Phase 8: Documentation Updates

Update all affected .llm.txt files to reflect new architecture:

- `docs/architecture.llm.txt` - Update data flow section
- `docs/presets.llm.txt` - Document new loading paths (single InitializationService)
- `docs/vue-architecture.llm.txt` - Update composables section
- `docs/services.llm.txt` - Add InitializationService, PresetValidationService

## Implementation Order

### Sprint 1: Foundation (Days 1-3)
1. Create `InitializationService` with basic structure
2. Create `PresetValidationService`
3. Create `ApplicationState` types
4. Write comprehensive tests for services

### Sprint 2: Consolidate Initialization (Days 4-6)
5. Migrate atlas initialization to use InitializationService
6. Update PresetSelector to use InitializationService
7. Update ImportModal to use InitializationService
8. Remove duplicated logic from AtlasCoordinator

### Sprint 3: Remove Fallbacks (Days 7-9)
9. Remove fallback initial values from configStore
10. Make projections nullable, update UI for loading states
11. Implement strict territory filtering with validation
12. Remove defensive null checks, add proper error handling

### Sprint 4: Simplify Data Loading (Days 10-12)
13. Implement preload-all-data strategy in InitializationService
14. Update geoDataStore to hold all data types
15. Remove async data loading from view mode switches
16. Implement clear reset strategies

### Sprint 5: Consolidate Watchers (Days 13-15)
17. Create `useApplicationState` composable
18. Remove duplicate watchers from configStore
19. Migrate initialization watchers to useApplicationState
20. Simplify useMapWatchers to focus on rendering

### Sprint 6: Polish & Validation (Days 16-18)
21. Implement view mode suitability enforcement in UI
22. Add strict validation to all initialization paths
23. Implement state machine if time permits
24. Comprehensive testing of all flows

### Sprint 7: Documentation (Days 19-20)
25. Update all .llm.txt files
26. Create migration guide for future developers
27. Add inline comments explaining key decisions
28. Create troubleshooting guide

## Verification

After implementation, verify:

- [ ] Single initialization path for all scenarios (atlas change, preset switch, import)
- [ ] No fallback values - either valid preset loaded or explicit loading/error state
- [ ] All data loaded upfront during initialization (no lazy loading on view mode switch)
- [ ] No duplicate watchers
- [ ] Clear reset strategy documented and enforced
- [ ] Unsupported view modes disabled in UI
- [ ] Validation prevents invalid states
- [ ] All .llm.txt documentation updated
- [ ] No temporal language in .llm.txt files

## Breaking Changes

This is a major refactor. Expected breaking changes:

1. **API Changes**: Some composables and stores will have different APIs
2. **State Shape**: Application state structure will change
3. **Loading Behavior**: Users will see loading state while all data preloads
4. **Error Handling**: Strict validation may reveal previously-hidden issues
5. **View Mode Switching**: Some previously-allowed mode switches may be blocked

## Migration Strategy

Since no users exist yet:
- No backward compatibility needed
- Can aggressively refactor
- Focus on correctness over migration path
- Use this opportunity to establish strong patterns

## Status
Status: IN_PROGRESS
Created: 2025-10-20
Last Updated: 2025-10-20

## Completed Work

### Phase 1: Foundation (COMPLETE)
- [x] Created `InitializationService` with complete structure
- [x] Created `PresetValidationService`  
- [x] Created `ApplicationState` types in `src/types/initialization.ts`
- [x] Wrote comprehensive tests for InitializationService (17 test cases)
- [x] All files compile without errors
- [x] Tests ready to run once mocks are properly configured

**Files Created:**
- `src/services/initialization/initialization-service.ts` (615 lines)
- `src/services/validation/preset-validation-service.ts` (134 lines)
- `src/types/initialization.ts` (95 lines)
- `src/services/initialization/__tests__/initialization-service.test.ts` (344 lines)

**Key Features Implemented:**
- Single entry point for all initialization scenarios
- Atomic state updates (all-or-nothing)
- Comprehensive validation before applying state
- Fail-fast error handling
- Support for atlas initialization, preset loading, imports, and view mode changes

### Phase 2: Consolidate Initialization Paths (COMPLETE)
- [x] Refactored `PresetSelector.vue` to use InitializationService
- [x] Refactored `ImportModal.vue` to use InitializationService
- [x] Consolidated duplicate `watch(selectedAtlas)` in configStore
- [x] Added InitializationService import to configStore
- [x] All files compile without errors

**Files Modified:**
- `src/components/ui/presets/PresetSelector.vue` (262 → ~170 lines)
  - Eliminated ~100 lines of duplicated preset loading logic
  - Now uses `InitializationService.loadPreset()` instead of manual PresetLoader + converter
  - Removed: convertToDefaults(), extractTerritoryParameters(), manual store updates
  
- `src/components/ui/import/ImportModal.vue` 
  - Replaced `CompositeImportService.applyToStores()` with `InitializationService.importConfiguration()`
  - Now includes cartographer updates after successful import
  - Removed manual parameterStore dependency
  
- `src/stores/config.ts`
  - Consolidated TWO `watch(selectedAtlas)` watchers into ONE
  - Removed duplicate logic that used both AtlasCoordinator and manual preset loading
  - Now uses `InitializationService.initializeAtlas()` for atlas changes
  - Added InitializationService import

**Code Reduction:**
- PresetSelector: ~92 lines removed
- configStore: ~80 lines removed (duplicate watcher + old AtlasCoordinator call)
- ImportModal: Simplified import application logic

**Benefits Achieved:**
- Single initialization code path established
- Eliminated ~170+ lines of duplicated initialization logic
- Consistent validation and error handling across all init scenarios
- Easier debugging (single service to trace)
- Type-safe state management via ApplicationState

### Phase 3: Remove Fallback Mechanisms (COMPLETE)
- [x] Made `selectedProjection` nullable (no fallback to 'natural-earth')
- [x] Made `compositeProjection` nullable (no fallback to 'conic-conformal-france')
- [x] Removed defensive null check in `setTerritoryParameter()` - now throws errors
- [x] Changed error handling to throw instead of silently failing
- [x] Updated components to handle null projections gracefully
- [x] Added loading state checks in MapRenderer
- [x] Updated ApplicationState type to support nullable projections
- [x] Fixed URL state handling to use nullish coalescing

**Files Modified:**
- `src/stores/config.ts`
  - `selectedProjection: ref<string | null>(null)` - no fallback value
  - `compositeProjection: ref<string | null>(null)` - no fallback value
  - Removed `getInitialProjection()` function with 'natural-earth' fallback
  - Comments updated to indicate InitializationService must load valid preset
  
- `src/stores/parameters.ts`
  - `setTerritoryParameter()` now throws Error instead of console.warn + return
  - Errors are re-thrown instead of silently caught
  - Clear error message indicates InitializationService should validate upfront
  - Removed unused `watch` import
  
- `src/components/MapRenderer.vue`
  - Added null checks before rendering (lines 204-207)
  - Skips simple map render if projection is null
  - Added validation in `renderComposite()` to throw error if selectedProjection is null
  - Conditional overlay rendering only when projectionId exists
  - Removed unsafe `as string` type assertions (replaced with proper null handling)
  
- `src/composables/useUrlState.ts`
  - Changed `||` to `??` for nullish coalescing (lines 29, 58)
  - Added null check for compositeProjection before adding to URL state (line 51)
  - Better semantics: only use fallback if value is null/undefined, not falsy
  
- `src/types/initialization.ts`
  - `ApplicationState.projections.selected` now `string | null`
  - `ApplicationState.projections.composite` now `string | null` (was optional string)
  - Type system enforces that initialization may start with null projections

**Benefits Achieved:**
- Clear distinction between "not yet loaded" (null) vs "loaded with value"
- Bugs surface immediately instead of hidden by fallbacks
- Forces proper loading state handling in components
- Easier to spot missing preset data during debugging
- Type-safe null handling throughout the stack
- No silent failures - errors are thrown and visible

**Known Patterns Preserved:**
- Territory filtering in geoData store (lines 116-159) - filters territories without projectionId
  - This is intentional: preset defines which territories to render
  - Could be made more explicit with validation in future iteration
- URL state uses 'mercator' fallback for URL generation (acceptable for this use case)

### Phase 4: Simplify Data Loading (COMPLETE)
- [x] Implemented preload-all-data strategy in InitializationService
- [x] Added `loadAllAtlasData()` method to geoDataStore (already existed)
- [x] Integrated data preloading into `initializeAtlas()`, `loadPreset()`, and `importConfiguration()`
- [x] Removed async data loading from view mode switches in useAtlasData
- [x] Implemented clear reset strategies with documentation:
  - Atlas change: Clear ALL data (parameters, geodata, preset defaults)
  - View mode change: Keep data loaded, clear only global projection parameters
  - Preset switch: Clear parameters, keep geodata, update preset defaults
- [x] Added `clearAll()` method to ProjectionParameterManager
- [x] Added `clearAll()` method to ParameterStore
- [x] Added `clearAll()` alias to usePresetDefaults
- [x] Added `clearAllApplicationData()` private method to InitializationService

**Files Modified:**
- `src/services/initialization/initialization-service.ts`
  - Added `preloadAtlasData()` and `ensureAtlasDataLoaded()` methods
  - Added `clearAllApplicationData()` method for atlas changes
  - Integrated data preloading into all initialization paths
  - Documented reset strategies for each scenario (atlas/preset/view mode change)

- `src/composables/useAtlasData.ts`
  - Removed conditional data loading from `initialize()` method
  - Removed conditional data loading from `reinitialize()` method
  - Removed async data loading from view mode watcher
  - Added comments explaining Phase 4 changes

- `src/stores/parameters.ts`
  - Added `clearAll()` method to clear global and all territory parameters
  - Exported `clearAll()` method

- `src/services/parameters/projection-parameter-manager.ts`
  - Added `clearAll()` method to clear global, atlas, and territory parameters

- `src/composables/usePresetDefaults.ts`
  - Added `clearAll()` alias for consistency with InitializationService

**Benefits Achieved:**
- View mode switching is now synchronous (no async delays)
- All data types preloaded upfront during atlas initialization
- Clear, documented reset strategies for different scenarios
- No data contamination between atlases
- Predictable behavior for users

**Data Already Available:**
- `geoDataStore` already had `loadAllAtlasData()` method (lines 266-325)
- Method loads territory + unified data in parallel
- Already integrated into store API

## Next Steps
1. Phase 5: Consolidate Watchers
   - Create useApplicationState composable
   - Remove duplicate watchers
2. Phase 6: Enforce View Mode Suitability
   - Disable unsupported view modes in UI
3. Phase 7: Update Documentation
   - Update all .llm.txt files with new architecture
   - Remove temporal language
   - Document initialization flow
